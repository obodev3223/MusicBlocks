This file is a merged representation of the entire codebase, combined into a single document by Repomix. The content has been processed where comments have been removed, empty lines have been removed, line numbers have been added, security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Security check has been disabled - content may contain sensitive information
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
MusicBlocks/
  Assets.xcassets/
    AccentColor.colorset/
      Contents.json
    AppIcon.appiconset/
      Contents.json
    Avatares/
      avatar1.imageset/
        Contents.json
      avatar10.imageset/
        Contents.json
      avatar11.imageset/
        Contents.json
      avatar12.imageset/
        Contents.json
      avatar13.imageset/
        Contents.json
      avatar14.imageset/
        Contents.json
      avatar2.imageset/
        Contents.json
      avatar3.imageset/
        Contents.json
      avatar4.imageset/
        Contents.json
      avatar5.imageset/
        Contents.json
      avatar6.imageset/
        Contents.json
      avatar7.imageset/
        Contents.json
      avatar8.imageset/
        Contents.json
      avatar9.imageset/
        Contents.json
      Contents.json
    Badges/
      Badge-azul-1.imageset/
        Contents.json
      Badge-azul-2.imageset/
        Contents.json
      Badge-azul-3.imageset/
        Contents.json
      Badge-azul-4.imageset/
        Contents.json
      Badge-azul-5.imageset/
        Contents.json
      Badge-multi-1.imageset/
        Contents.json
      Badge-multi-2.imageset/
        Contents.json
      Badge-multi-3.imageset/
        Contents.json
      Badge-multi-4.imageset/
        Contents.json
      Badge-multi-5.imageset/
        Contents.json
      Badge-oro-1.imageset/
        Contents.json
      Badge-oro-2.imageset/
        Contents.json
      Badge-oro-3.imageset/
        Contents.json
      Badge-oro-4.imageset/
        Contents.json
      Badge-oro-5.imageset/
        Contents.json
      Badge-rojo-1.imageset/
        Contents.json
      Badge-rojo-2.imageset/
        Contents.json
      Badge-rojo-3.imageset/
        Contents.json
      Badge-rojo-4.imageset/
        Contents.json
      Badge-rojo-5.imageset/
        Contents.json
      Badge-verde-1.imageset/
        Contents.json
      Badge-verde-2.imageset/
        Contents.json
      Badge-verde-3.imageset/
        Contents.json
      Badge-verde-4.imageset/
        Contents.json
      Badge-verde-5.imageset/
        Contents.json
      Contents.json
    Blocks/
      changingBlock.imageset/
        Contents.json
      defaultBlock.imageset/
        Contents.json
      explosiveBlock.imageset/
        Contents.json
      ghostBlock.imageset/
        Contents.json
      hardIceBlock.imageset/
        Contents.json
      iceBlock.imageset/
        Contents.json
      Contents.json
    flat.imageset/
      Contents.json
      flat.svg
    Icons/
      changingBlock_icon.imageset/
        Contents.json
      coin_icon.imageset/
        Contents.json
      defaultBlock_icon.imageset/
        Contents.json
      explosiveBlock_icon.imageset/
        Contents.json
      ghostBlock_icon.imageset/
        Contents.json
      hardiceBlock_icon.imageset/
        Contents.json
      heart_empty.imageset/
        Contents.json
      heart_extra.imageset/
        Contents.json
      heart_filled.imageset/
        Contents.json
      iceBlock_icon.imageset/
        Contents.json
      note_icon.imageset/
        Contents.json
      star_empty.imageset/
        Contents.json
      star_filled.imageset/
        Contents.json
      target_icon.imageset/
        Contents.json
      timer_icon.imageset/
        Contents.json
      Contents.json
    logoMusicBlocks.imageset/
      Contents.json
    MusicSymbols/
      MusicalSymbol_01.imageset/
        Contents.json
      MusicalSymbol_02.imageset/
        Contents.json
      MusicalSymbol_03.imageset/
        Contents.json
      MusicalSymbol_04.imageset/
        Contents.json
      MusicalSymbol_05.imageset/
        Contents.json
      MusicalSymbol_06.imageset/
        Contents.json
      MusicalSymbol_07.imageset/
        Contents.json
      MusicalSymbol_08.imageset/
        Contents.json
      MusicalSymbol_09.imageset/
        Contents.json
      MusicalSymbol_10.imageset/
        Contents.json
      MusicalSymbol_11.imageset/
        Contents.json
      MusicalSymbol_12.imageset/
        Contents.json
      MusicalSymbol_13.imageset/
        Contents.json
      MusicalSymbol_14.imageset/
        Contents.json
      MusicalSymbol_15.imageset/
        Contents.json
      MusicalSymbol_16.imageset/
        Contents.json
      MusicalSymbol_17.imageset/
        Contents.json
      MusicalSymbol_18.imageset/
        Contents.json
      MusicalSymbol_19.imageset/
        Contents.json
      MusicalSymbol_20.imageset/
        Contents.json
      MusicalSymbol_21.imageset/
        Contents.json
      MusicalSymbol_22.imageset/
        Contents.json
      MusicalSymbol_23.imageset/
        Contents.json
      Contents.json
    sharp.imageset/
      Contents.json
      sharp.svg
    Texturas Bloques/
      explosionTexture.imageset/
        Contents.json
      ghostTexture.imageset/
        Contents.json
      iceTexture.imageset/
        Contents.json
      iceTexture2.imageset/
        Contents.json
      iceTexture3.imageset/
        Contents.json
      iceTexture4.imageset/
        Contents.json
      wavesTexture.imageset/
        Contents.json
      Contents.json
    trebleClef.imageset/
      Contents.json
      treble-clef.svg
    wholeNote.imageset/
      Contents.json
      whole-note.svg
    Contents.json
  Audio/
    AudioController.swift
    TunerEngine.swift
  Bloques/
    BlockContentGenerator.swift
    BlocksManager.swift
    BlockStyle.swift
    MusicalNote.swift
  Inicio y Profile/
    AchievementBadge.swift
    AchievementsView.swift
    AvatarPickerViewController.swift
    ContentView.swift
    ExpandableSectionView.swift
    MusicBlocksApp.swift
    ProfileHeaderView.swift
    ProfileViewController.swift
    StatsView.swift
    UserProfile.swift
  Paneles/
    DetectedNoteCounterNode.swift
    GameOverlayNode.swift
    ScoreProgressNode.swift
    StabilityCounterNode.swift
    StabilityIndicatorNode.swift
    TopBar.swift
    TopBarComponents.swift
    TuningIndicatorNode.swift
    UIContainer.swift
  Pantallazos/
    repomix-output-MusicBlocks.zip.xml
  Preview Content/
    Preview Assets.xcassets/
      Contents.json
  BackgroundPatternNode.swift
  game_levels.json
  GameEngine.swift
  GameLevelProcessor.swift
  GameManager.swift
  GameTypes.swift
  GameUIManager.swift
  LevelObjectiveTracker.swift
  MusicBlocksScene.swift
MusicBlocks.xcodeproj/
  project.xcworkspace/
    xcshareddata/
      swiftpm/
        Package.resolved
    contents.xcworkspacedata
  project.pbxproj
MusicBlocksTests/
  MusicBlocksTests.swift
MusicBlocksUITests/
  MusicBlocksUITests.swift
  MusicBlocksUITestsLaunchTests.swift
.gitignore
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="MusicBlocks/Assets.xcassets/AccentColor.colorset/Contents.json">
 1: {
 2:   "colors" : [
 3:     {
 4:       "idiom" : "universal"
 5:     }
 6:   ],
 7:   "info" : {
 8:     "author" : "xcode",
 9:     "version" : 1
10:   }
11: }
</file>

<file path="MusicBlocks/Assets.xcassets/AppIcon.appiconset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "logoMusicBlocks.png",
 5:       "idiom" : "universal",
 6:       "platform" : "ios",
 7:       "size" : "1024x1024"
 8:     },
 9:     {
10:       "appearances" : [
11:         {
12:           "appearance" : "luminosity",
13:           "value" : "dark"
14:         }
15:       ],
16:       "idiom" : "universal",
17:       "platform" : "ios",
18:       "size" : "1024x1024"
19:     },
20:     {
21:       "appearances" : [
22:         {
23:           "appearance" : "luminosity",
24:           "value" : "tinted"
25:         }
26:       ],
27:       "idiom" : "universal",
28:       "platform" : "ios",
29:       "size" : "1024x1024"
30:     }
31:   ],
32:   "info" : {
33:     "author" : "xcode",
34:     "version" : 1
35:   }
36: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar1.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar1.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar10.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar10.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar11.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar11.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar12.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar12.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar13.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar13.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar14.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar14.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar2.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar2.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar3.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar3.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar4.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar4.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar5.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar5.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar6.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar6.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar7.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar7.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar8.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar8.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/avatar9.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "avatar9.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Avatares/Contents.json">
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-azul-1.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-azul-1.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-azul-2.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-azul-2.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-azul-3.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-azul-3.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-azul-4.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-azul-4.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-azul-5.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-azul-5.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-multi-1.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-multi-1.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-multi-2.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-multi-2.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-multi-3.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-multi-3.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-multi-4.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-multi-4.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-multi-5.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-multi-5.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-oro-1.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-oro-1.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-oro-2.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-oro-2.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-oro-3.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-oro-3.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-oro-4.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-oro-4.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-oro-5.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-oro-5.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-rojo-1.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-rojo-1.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-rojo-2.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-rojo-2.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-rojo-3.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-rojo-3.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-rojo-4.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-rojo-4.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-rojo-5.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-rojo-5.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-verde-1.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-verde-1.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-verde-2.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-verde-2.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-verde-3.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-verde-3.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-verde-4.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-verde-4.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Badge-verde-5.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Badge-verde-5.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Badges/Contents.json">
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
</file>

<file path="MusicBlocks/Assets.xcassets/Blocks/changingBlock.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "changingBlock.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Blocks/defaultBlock.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "defaultBlock.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Blocks/explosiveBlock.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "explosiveBlock.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Blocks/ghostBlock.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "ghostBlock.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Blocks/hardIceBlock.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "hardIceBlock.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Blocks/iceBlock.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "iceBlock.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Blocks/Contents.json">
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
</file>

<file path="MusicBlocks/Assets.xcassets/flat.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "flat.svg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/flat.imageset/flat.svg">
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
 3: <!-- Creator: CorelDRAW -->
 4: <svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="42.3332mm" height="76.1998mm" version="1.1" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
 5: viewBox="0 0 4233.32 7619.98"
 6:  xmlns:xlink="http://www.w3.org/1999/xlink"
 7:  xmlns:xodm="http://www.corel.com/coreldraw/odm/2003">
 8:  <defs>
 9:   <style type="text/css">
10:    <![CDATA[
11:     .str0 {stroke:#2B2A29;stroke-width:20;stroke-miterlimit:22.9256}
12:     .fil0 {fill:black;fill-rule:nonzero}
13:    ]]>
14:   </style>
15:  </defs>
16:  <g id="Capa_x0020_1">
17:   <metadata id="CorelCorpID_0Corel-Layer"/>
18:   <path class="fil0 str0" d="M2398 3572.47c0,4.74 -8.89,458.62 -581.16,819.55l-0.3 -799.21c77.4,-137.05 274.79,-261.2 443.73,-233.38 104.91,17.29 144.9,117.03 137.73,213.04zm-110.54 -351.45c-174.16,-28.49 -348.47,42.4 -470.99,151.63l-0.55 -1283.79c0,-12.11 -8.78,-21.95 -19.58,-21.95l-94.55 0c-10.88,0 -19.64,9.94 -19.57,22.16l-0.59 2447.12c-1.44,4.07 -0.04,10.87 -0.04,15.26 -0.03,5.44 -0.03,10.86 -0.07,16.64 0,5.08 0,9.82 0,14.91 0.04,3.07 0.37,6.12 0.63,9.17 0.22,2.71 -0.3,4.06 2.63,4.4 12.06,1.03 24.15,-8.47 34.25,-13.57 23.16,-11.19 47.21,-20.69 70.36,-31.87 48.42,-23.42 93.56,-52.58 138.84,-82.1 26.92,-17.3 52.3,-36.63 78.67,-54.61 16.58,-12.55 33.27,-25.12 49.58,-37.99 38.84,-30.53 76.28,-62.76 112.05,-96.35 32.73,-30.86 64.07,-63.09 93.74,-96.34 27.15,-30.53 52.9,-62.08 77.06,-94.63 22.05,-29.53 42.76,-60.07 62.03,-91.27 17.39,-28.48 33.63,-57.32 48.57,-86.5 13.32,-26.46 25.64,-52.92 36.81,-80.04 9.77,-23.76 18.69,-47.84 26.63,-71.93 6.74,-20.68 12.81,-41.39 18.09,-62.42 4.26,-16.96 8.04,-33.92 11.21,-50.87 2.34,-12.55 4.33,-25.45 5.89,-38 0.96,-8.15 1.81,-15.95 2.29,-23.75 0.11,-2.38 0.07,-4.76 0.26,-6.78 14.02,-181.83 -94.48,-328.37 -263.65,-356.53z"/>
19:  </g>
20: </svg>
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/changingBlock_icon.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "changingBlock_icon.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/coin_icon.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "icon-coin.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/defaultBlock_icon.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "defaultBlock_icon.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/explosiveBlock_icon.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "explosiveBlock_icon.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/ghostBlock_icon.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "ghostBlock_icon.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/hardiceBlock_icon.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "hardiceBlock_icon.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/heart_empty.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "icon-heart-empty.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/heart_extra.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "icon-heart-extra.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/heart_filled.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "icon-heart-full.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/iceBlock_icon.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "iceBlock_icon.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/note_icon.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "icon-note.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/star_empty.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "icon-star-empty.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/star_filled.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "icon-star-full.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/target_icon.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "icon-accuracy.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/timer_icon.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "icon-time.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Icons/Contents.json">
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
</file>

<file path="MusicBlocks/Assets.xcassets/logoMusicBlocks.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "logoMusicBlocks.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_01.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_01.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_02.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_02.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_03.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_03.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_04.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_04.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_05.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_05.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_06.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_06.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_07.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_07.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_08.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_08.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_09.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_09.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_10.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_10.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_11.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_11.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_12.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_12.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_13.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_13.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_14.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_14.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_15.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_15.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_16.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_16.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_17.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_17.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_18.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_18.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_19.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_19.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_20.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_20.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_21.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_21.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_22.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_22.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/MusicalSymbol_23.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "MusicalSymbol_23.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/MusicSymbols/Contents.json">
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
</file>

<file path="MusicBlocks/Assets.xcassets/sharp.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "sharp.svg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/sharp.imageset/sharp.svg">
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
 3: <!-- Creator: CorelDRAW -->
 4: <svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="42.3332mm" height="76.1998mm" version="1.1" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
 5: viewBox="0 0 4233.32 7619.98"
 6:  xmlns:xlink="http://www.w3.org/1999/xlink"
 7:  xmlns:xodm="http://www.corel.com/coreldraw/odm/2003">
 8:  <defs>
 9:   <style type="text/css">
10:    <![CDATA[
11:     .str0 {stroke:#FEFEFE;stroke-width:20;stroke-miterlimit:22.9256}
12:     .fil0 {fill:black;fill-rule:nonzero}
13:    ]]>
14:   </style>
15:  </defs>
16:  <g id="Capa_x0020_1">
17:   <metadata id="CorelCorpID_0Corel-Layer"/>
18:   <path class="fil0 str0" d="M2282.87 4155.14l-378.01 103.22 71.51 -793.69 378.01 -102.78 -71.51 793.25zm551.68 -887.69c4.64,-0.89 8.09,-6.59 8.09,-13.18l0 -204.69c0,-7.91 -4.91,-14.06 -10.47,-13.17l-293.24 59.74 41.43 -459.54c0.74,-7.99 -3.6,-15.11 -9.18,-15.11l-141.91 0c-4.67,0 -8.6,5.01 -9.21,11.64l-44.48 493.75 -378.01 102.78 53.45 -593.06c0.7,-7.99 -3.61,-15.11 -9.22,-15.11l-141.91 0c-4.67,0 -8.6,5.01 -9.18,11.64l-56.53 626.84 -435.42 81.7c-4.65,0.87 -8.09,6.58 -8.09,13.17l0 204.24c0,7.91 4.91,14.51 10.46,13.19l411.85 -76.87 -71.5 793.27 -342.72 64.12c-4.65,0.87 -8.09,6.59 -8.09,13.17l0 204.25c0,8.35 4.91,14.5 10.46,13.17l319.14 -59.29 -41.39 459.45c-0.73,7.92 3.61,14.92 9.18,14.92l141.91 0c4.67,0 8.6,-4.81 9.22,-11.4l44.47 -493.71 378.01 -102.79 -53.44 592.98c-0.73,7.92 3.6,14.92 9.18,14.92l141.94 0c4.64,0 8.58,-4.81 9.18,-11.4l56.5 -627.24 409.52 -81.26c4.64,-0.87 8.09,-6.59 8.09,-13.18l0 -204.24c0,-8.35 -4.91,-14.51 -10.47,-13.62l-385.94 77.31 71.51 -793.26 316.81 -64.13z"/>
19:  </g>
20: </svg>
</file>

<file path="MusicBlocks/Assets.xcassets/Texturas Bloques/explosionTexture.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "explosionTexture.jpg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Texturas Bloques/ghostTexture.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "halloween-ghosts-made-paper-with-funny-faces (1).jpg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Texturas Bloques/iceTexture.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "ice-texture.jpg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Texturas Bloques/iceTexture2.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "ice-texture2.jpg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Texturas Bloques/iceTexture3.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "ice-texture3.jpg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Texturas Bloques/iceTexture4.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "ice-texture4.jpg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Texturas Bloques/wavesTexture.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "wavesTexture.jpg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/Texturas Bloques/Contents.json">
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
</file>

<file path="MusicBlocks/Assets.xcassets/trebleClef.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "treble-clef.svg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/trebleClef.imageset/treble-clef.svg">
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
 3: <!-- Creator: CorelDRAW -->
 4: <svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="42.3332mm" height="76.1998mm" version="1.1" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
 5: viewBox="0 0 4233.32 7619.98"
 6:  xmlns:xlink="http://www.w3.org/1999/xlink"
 7:  xmlns:xodm="http://www.corel.com/coreldraw/odm/2003">
 8:  <defs>
 9:   <style type="text/css">
10:    <![CDATA[
11:     .fil0 {fill:black;fill-rule:nonzero}
12:    ]]>
13:   </style>
14:  </defs>
15:  <g id="Capa_x0020_1">
16:   <metadata id="CorelCorpID_0Corel-Layer"/>
17:   <path class="fil0" d="M2748.86 5266.61l-31.48 -165.27c-0.77,-4.59 -0.72,-9.12 -1.68,-13.76l-197.21 -936.05c125.49,6.69 476.63,67.88 567.63,538.13 0,0 78.15,353.77 -337.26,576.95zm-1224.32 -148.95c-186.52,-158.27 -322.31,-386.1 -334.03,-630.46 -13.46,-280.68 133.42,-544.93 309.44,-763.97 178.84,-222.57 392.6,-417.05 631.04,-574.15 40.96,177.14 81.88,354.31 122.78,531.44 8.64,37.31 16.97,77.88 0.96,112.68 -17.46,37.91 -58.41,57.84 -95.07,77.81 -269.25,146.63 -434.27,441.15 -439.75,745.1 -2.08,114.7 15.16,233.5 76.27,330.61 61.07,97.09 172.95,167.86 287.01,155.58 -49,5.28 -127.47,-206.49 -138.35,-242.55 -30.37,-100.58 -36.59,-208.96 -17.38,-312.28 40.77,-219.19 206.73,-369.58 430.9,-390.5 80.57,363.12 174.04,794.35 249.91,1172.35 0.34,1.9 0.72,3.73 1.11,5.59 -366.86,116.82 -791.27,31.86 -1084.84,-217.25zm723.88 -3923.57c178.88,-241.09 565.2,-133.85 592.81,165.04 0,0 54.42,428.57 -318.79,852.96 -60.61,82.52 -189.64,208.77 -340.04,344.15l-44.91 -212.95c-3.23,-15.6 -5.36,-55.53 -7.83,-71.49 -39.67,-255.17 -46.34,-621.76 -22.25,-763.6 31.94,-187.85 141.01,-314.11 141.01,-314.11zm785.5 2734.91c-123.78,-95.99 -329.43,-135.57 -479.84,-142.91 -79.01,-3.84 -88.76,12.36 -127.74,-45.03 -36.19,-53.27 -37.22,-180.09 -50.49,-244.13 -33.65,-162.23 -67.35,-324.45 -101,-486.68 357.08,-220.52 624.71,-581.78 731.91,-987.53 107.24,-405.76 52.87,-851.83 -148.65,-1219.94 -64.23,-117.49 -166.94,-239.95 -300.53,-232.34 -99.98,5.71 -180.03,83.29 -240.98,162.76 -193.21,251.75 -294.36,565.85 -324.95,881.86 -30.57,315.62 6.17,634.67 67.19,946.12 5.82,29.67 11.77,61.23 1.89,89.74 -10.7,30.81 -37.89,52.87 -63.84,72.65 -376.33,290.67 -781.4,583.49 -980.4,1015.22 -118.09,256.22 -153.47,549.76 -99.62,826.72 55.5,285.31 212.28,558.35 457.85,713.88 160.87,101.92 350.17,149.26 538.25,179.23 238.1,37.95 484.32,50.12 718.27,-8.11 26.93,142.34 49.82,285.44 67.46,429.23 13.96,113.43 28.07,229 33.24,343.95 1.67,36.73 -1.26,72.55 -1.26,109.06 -7.37,75.03 -36.69,149.07 -77.08,212.32 -17.98,28.13 -38.64,54.59 -61.61,78.9 -69.51,73.58 -157.05,128.04 -249.38,168.42 -65.67,28.75 -136.51,46.32 -208.24,49.75 -36.05,1.7 -72.29,-0.16 -107.91,-5.97 -2.9,-0.47 -6.23,-1.07 -9.29,-1.57 142.56,-77.01 240.56,-225.96 240.56,-399.37 0,-251.66 -204,-455.64 -455.65,-455.64 -251.64,0 -455.64,203.98 -455.64,455.64 0,76.29 20.52,147.1 53.67,210.26l-2.64 -0.8c6.43,12.4 14.11,23.16 21.11,34.84 2.83,4.44 5.18,9.16 8.14,13.46 238.75,377.12 762.33,356.47 762.33,356.47 63.78,2.96 131.43,-10.68 192.66,-26.39 136.85,-35.1 265.31,-103.71 364.42,-205.12 47.3,-48.41 87.49,-103.55 120.2,-162.76 26.84,-48.56 50.58,-99.41 63.12,-153.67 17.42,-75.33 11.9,-152.31 4.61,-228.51 -16.89,-176.82 -49.67,-351.72 -84.58,-526.38 -8.29,-41.25 -16.55,-82.56 -24.79,-123.85 -14.76,-73.78 -29.52,-147.54 -44.26,-221.32 -0.73,-3.73 -1.49,-7.46 -2.26,-11.19 0,0 438.39,-127.84 529.73,-511.43 0,0 173.53,-602.76 -273.98,-949.84z"/>
18:  </g>
19: </svg>
</file>

<file path="MusicBlocks/Assets.xcassets/wholeNote.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "whole-note.svg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="MusicBlocks/Assets.xcassets/wholeNote.imageset/whole-note.svg">
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
 3: <!-- Creator: CorelDRAW -->
 4: <svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="6.7732mm" height="6.7732mm" version="1.1" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
 5: viewBox="0 0 677.32 677.32"
 6:  xmlns:xlink="http://www.w3.org/1999/xlink"
 7:  xmlns:xodm="http://www.corel.com/coreldraw/odm/2003">
 8:  <defs>
 9:   <style type="text/css">
10:    <![CDATA[
11:     .fil1 {fill:none}
12:     .fil0 {fill:black;fill-rule:nonzero}
13:    ]]>
14:   </style>
15:  </defs>
16:  <g id="Capa_x0020_1">
17:   <metadata id="CorelCorpID_0Corel-Layer"/>
18:   <path class="fil0" d="M338.65 203.1c-116.84,0 -215.57,62.15 -215.57,135.48 0,73.5 98.73,135.47 215.57,135.47 116.86,0 215.59,-61.97 215.59,-135.47 0,-73.33 -98.73,-135.48 -215.59,-135.48zm0 342.39c-160.9,0 -286.94,-90.89 -286.94,-206.91 0,-116.02 126.04,-206.74 286.94,-206.74 160.92,0 286.96,90.72 286.96,206.74 0,116.02 -126.04,206.91 -286.96,206.91z"/>
19:   <rect class="fil1" x="-0" y="-0" width="677.33" height="677.33"/>
20:  </g>
21: </svg>
</file>

<file path="MusicBlocks/Assets.xcassets/Contents.json">
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
</file>

<file path="MusicBlocks/Audio/AudioController.swift">
  1: import AudioKit
  2: import AudioKitEX
  3: import AVFoundation
  4: import SoundpipeAudioKit
  5: protocol AudioControllerDelegate: AnyObject {
  6:     func audioController(_ controller: AudioController, didDetectNote note: String, frequency: Float, amplitude: Float, deviation: Double)
  7:     func audioControllerDidDetectSilence(_ controller: AudioController)
  8:     func audioControllerRequiredHoldTime(_ controller: AudioController) -> TimeInterval
  9: }
 10: class AudioController: ObservableObject {
 11:     static let sharedInstance = AudioController()
 12:     weak var delegate: AudioControllerDelegate?
 13:     @Published var tunerData: TunerEngine.TunerData = .inactive
 14:     @Published var stabilityDuration: TimeInterval = 0
 15:     private let tunerEngine = TunerEngine.shared
 16:     let engine = AudioEngine()
 17:     var pitchTap: PitchTap!
 18:     var mic: AudioEngine.InputNode!
 19:     var silence: Fader!
 20:     private let minimumAmplitude: Float = 0.02
 21:     private let minimumFrequency: Float = 20.0
 22:     private let maximumFrequency: Float = 2000.0
 23:     private let stabilityThreshold: Float = 3.0
 24:     private let amplitudeSmoothing: Float = 0.9
 25:     private var lastStableFrequency: Float = 0
 26:     private var stabilityStartTime: Date?
 27:     private var smoothedAmplitude: Float = 0
 28:     private var lastProcessedTime: Date = Date()
 29:     private let minimumProcessingInterval: TimeInterval = 0.05
 30:     private var backgroundMusicPlayer: AVAudioPlayer?
 31:     func startBackgroundMusic() {
 32:         if let player = backgroundMusicPlayer, player.isPlaying {
 33:             print("La música de fondo ya se está reproduciendo")
 34:             return
 35:         }
 36:         guard let url = Bundle.main.url(forResource: "backgroundMusic", withExtension: "mp3")
 37:         else {
 38:             print("No se encontró el archivo de música de fondo")
 39:             return
 40:         }
 41:         do {
 42:             backgroundMusicPlayer = try AVAudioPlayer(contentsOf: url)
 43:             backgroundMusicPlayer?.numberOfLoops = -1
 44:             let targetVolume: Float = 0.5
 45:             backgroundMusicPlayer?.volume = 0.3
 46:             backgroundMusicPlayer?.prepareToPlay()
 47:             backgroundMusicPlayer?.play()
 48:             fadeInBackgroundMusic(to: targetVolume, duration: 1.0)
 49:             print("Música de fondo iniciada con fade in")
 50:         }   catch {
 51:             print("Error al reproducir la música de fondo: (error)")
 52:         }
 53:     }
 54:     private func fadeInBackgroundMusic(to targetVolume: Float, duration: TimeInterval) {
 55:         guard let player = backgroundMusicPlayer else { return }
 56:         let fadeSteps = 40
 57:         let fadeStepDuration = duration / Double(fadeSteps)
 58:         for step in 0...fadeSteps {
 59:             DispatchQueue.main.asyncAfter(deadline: .now() + fadeStepDuration * Double(step)) {
 60:                 let fraction = Float(step) / Float(fadeSteps)
 61:                 player.volume = targetVolume * fraction
 62:             }
 63:         }
 64:     }
 65:     func stopBackgroundMusic (duration: TimeInterval = 0.5) {
 66:         guard let player = backgroundMusicPlayer, player.isPlaying else {
 67:             return
 68:         }
 69:         let fadeSteps = 5
 70:         let fadeStepDuration = duration / Double(fadeSteps)
 71:         let originalVolume = player.volume
 72:         for step in 0...fadeSteps {
 73:             DispatchQueue.main.asyncAfter(deadline: .now() + fadeStepDuration * Double(step)) {
 74:                 let fraction = Float(step) / Float(fadeSteps)
 75:                 player.volume = originalVolume * (1 - fraction)
 76:                 if step == fadeSteps {
 77:                     player.stop()
 78:                 }
 79:             }
 80:         }
 81:         print("AudioController: Iniciando fade out de la música de fondo")
 82:     }
 83:     func playButtonSound() {
 84:         guard let url = Bundle.main.url(forResource: "buttonClick", withExtension: "mp3") else {
 85:             print("AudioController: No se encontró el efecto de sonido para botón")
 86:             return
 87:         }
 88:         do {
 89:             let buttonSoundPlayer = try AVAudioPlayer(contentsOf: url)
 90:             buttonSoundPlayer.volume = 0.8
 91:             buttonSoundPlayer.prepareToPlay()
 92:             buttonSoundPlayer.play()
 93:             print("AudioController: Efecto de sonido del botón reproducido")
 94:         } catch {
 95:             print("AudioController: Error al reproducir el efecto de sonido: \(error)")
 96:         }
 97:     }
 98:     private func updateStability(frequency: Float) {
 99:         if abs(frequency - lastStableFrequency) <= stabilityThreshold {
100:             if stabilityStartTime == nil {
101:                 stabilityStartTime = Date()
102:             }
103:             stabilityDuration = Date().timeIntervalSince(stabilityStartTime ?? Date())
104:         } else {
105:             lastStableFrequency = frequency
106:             stabilityStartTime = nil
107:             stabilityDuration = 0
108:         }
109:     }
110:     private func processPitchData(frequency: Float, amplitude: Float) {
111:         self.smoothedAmplitude = (self.amplitudeSmoothing * self.smoothedAmplitude) + ((1 - self.amplitudeSmoothing) * amplitude)
112:         let currentTime = Date()
113:         guard currentTime.timeIntervalSince(lastProcessedTime) >= minimumProcessingInterval else {
114:             return
115:         }
116:         lastProcessedTime = currentTime
117:         if self.smoothedAmplitude > minimumAmplitude,
118:            frequency >= minimumFrequency && frequency <= maximumFrequency {
119:             let tunerData = tunerEngine.processPitch(frequency: frequency, amplitude: self.smoothedAmplitude)
120:             DispatchQueue.main.async {
121:                 self.tunerData = tunerData
122:             }
123:             let requiredHoldTime = delegate?.audioControllerRequiredHoldTime(self) ?? 1.0
124:             if tunerEngine.updateHoldDetection(note: tunerData.note,
125:                                                currentTime: currentTime.timeIntervalSinceReferenceDate,
126:                                                requiredHoldTime: requiredHoldTime) {
127:                 DispatchQueue.main.async {
128:                     print("🎵 Nota validada tras hold: \(tunerData.note) (requiredHoldTime: \(requiredHoldTime) s)")
129:                     self.delegate?.audioController(self, didDetectNote: tunerData.note, frequency: frequency, amplitude: self.smoothedAmplitude, deviation: tunerData.deviation)
130:                 }
131:             }
132:             updateStability(frequency: frequency)
133:         } else {
134:             DispatchQueue.main.async {
135:                 self.tunerData = .inactive
136:                 self.stabilityDuration = 0
137:                 self.delegate?.audioControllerDidDetectSilence(self)
138:             }
139:         }
140:     }
141:     private init() {
142:         do {
143:             try AVAudioSession.sharedInstance().setCategory(.playAndRecord,
144:                                                             options: [.defaultToSpeaker, .mixWithOthers])
145:             try AVAudioSession.sharedInstance().setActive(true)
146:             guard let input = engine.input else {
147:                 print("Error: No se detectó entrada de audio")
148:                 return
149:             }
150:             mic = input
151:             silence = Fader(mic, gain: 0)
152:             engine.output = silence
153:             pitchTap = PitchTap(mic) { [weak self] frequency, amplitude in
154:                 guard let self = self else { return }
155:                 self.processPitchData(frequency: frequency[0], amplitude: amplitude[0])
156:             }
157:             try engine.start()
158:             print("Motor de audio iniciado correctamente")
159:         } catch {
160:             print("Error en la inicialización del audio: \(error)")
161:         }
162:     }
163:     var microphonePermissionStatus: Bool {
164:         AVCaptureDevice.authorizationStatus(for: .audio) == .authorized
165:     }
166:     func start() {
167:         guard mic != nil else {
168:             print("Error: Input de audio no disponible")
169:             return
170:         }
171:         smoothedAmplitude = 0
172:         stabilityDuration = 0
173:         lastProcessedTime = Date()
174:         stabilityStartTime = nil
175:         lastStableFrequency = 0
176:         tunerData = .inactive
177:         pitchTap.start()
178:     }
179:     func stop() {
180:         pitchTap.stop()
181:         DispatchQueue.main.async {
182:             self.tunerData = .inactive
183:             self.stabilityDuration = 0
184:         }
185:     }
186: }
</file>

<file path="MusicBlocks/Audio/TunerEngine.swift">
 1: import Foundation
 2: class TunerEngine {
 3:     static let shared = TunerEngine()
 4:     struct TunerData {
 5:         let note: String
 6:         let frequency: Float
 7:         let deviation: Double
 8:         let isActive: Bool
 9:         static let inactive = TunerData(note: "-", frequency: 0, deviation: 0, isActive: false)
10:     }
11:     private let concertPitch: Double = 442.0
12:     private var noteHoldAccumulator: TimeInterval = 0
13:     private var lastDetectionTime: TimeInterval? = nil
14:     private var currentStableNote: String = "-"
15:     func processPitch(frequency: Float, amplitude: Float) -> TunerData {
16:         let minAmplitude: Float = 0.05
17:         guard amplitude > minAmplitude else {
18:             return .inactive
19:         }
20:         let (note, deviation) = processFrequency(frequency)
21:         return TunerData(
22:             note: note,
23:             frequency: frequency,
24:             deviation: deviation,
25:             isActive: true
26:         )
27:     }
28:     func parseNote(_ noteString: String) -> MusicalNote? {
29:         return MusicalNote.parse(noteString)
30:     }
31:     func updateHoldDetection(note: String, currentTime: TimeInterval, requiredHoldTime: TimeInterval) -> Bool {
32:         if note == currentStableNote {
33:             if let lastTime = lastDetectionTime {
34:                 noteHoldAccumulator += (currentTime - lastTime)
35:             }
36:         } else {
37:             currentStableNote = note
38:             noteHoldAccumulator = 0
39:         }
40:         lastDetectionTime = currentTime
41:         print("TunerEngine - Nota detectada: \(note), acumulador de hold: \(noteHoldAccumulator) segundos")
42:         if note != "-" && noteHoldAccumulator >= requiredHoldTime {
43:             print("TunerEngine - Éxito: la nota \(note) se mantuvo estable por \(noteHoldAccumulator) segundos (requerido: \(requiredHoldTime) segundos)")
44:             noteHoldAccumulator = 0
45:             return true
46:         }
47:         return false
48:     }
49:     private func processFrequency(_ frequency: Float) -> (String, Double) {
50:         guard frequency > 0 else { return ("-", 0) }
51:         let actualFrequency = Double(frequency)
52:         let halfStepsFromA4 = 12 * log2(actualFrequency / concertPitch)
53:         let roundedHalfSteps = round(halfStepsFromA4)
54:         let deviation = 100 * (halfStepsFromA4 - roundedHalfSteps)
55:         let midiNoteNumber = Int(roundedHalfSteps) + 69
56:         let octave = (midiNoteNumber / 12) - 1
57:         let noteIndex = ((midiNoteNumber % 12) + 12) % 12
58:         let (noteName, alteration) = getNoteNameAndAlteration(forMIDINote: noteIndex)
59:         return ("\(noteName)\(alteration.rawValue)\(octave)", deviation)
60:     }
61:     private func getNoteNameAndAlteration(forMIDINote index: Int) -> (String, MusicalNote.Alteration) {
62:         switch index {
63:         case 0: return ("DO", .natural)
64:         case 1: return Bool.random() ? ("DO", .sharp) : ("RE", .flat)
65:         case 2: return ("RE", .natural)
66:         case 3: return Bool.random() ? ("RE", .sharp) : ("MI", .flat)
67:         case 4: return ("MI", .natural)
68:         case 5: return ("FA", .natural)
69:         case 6: return Bool.random() ? ("FA", .sharp) : ("SOL", .flat)
70:         case 7: return ("SOL", .natural)
71:         case 8: return Bool.random() ? ("SOL", .sharp) : ("LA", .flat)
72:         case 9: return ("LA", .natural)
73:         case 10: return Bool.random() ? ("LA", .sharp) : ("SI", .flat)
74:         case 11: return ("SI", .natural)
75:         default: return ("", .natural)
76:         }
77:     }
78: }
</file>

<file path="MusicBlocks/Bloques/BlockContentGenerator.swift">
  1: import SpriteKit
  2: struct BlockContentGenerator {
  3:     static func generateBlockContent(
  4:         with style: BlockStyle,
  5:         blockSize: CGSize,
  6:         desiredNote: MusicalNote,
  7:         baseNoteX: CGFloat,
  8:         baseNoteY: CGFloat,
  9:         leftMargin: CGFloat = 30,
 10:         rightMargin: CGFloat = 30
 11:     ) -> SKNode {
 12:         let contentNode = SKNode()
 13:         let staffPath = CGMutablePath()
 14:         let lineSpacing: CGFloat = 12
 15:         for i in 0..<5 {
 16:             let y = 24 - CGFloat(i) * lineSpacing
 17:             staffPath.move(to: CGPoint(x: -blockSize.width/2 + leftMargin, y: y))
 18:             staffPath.addLine(to: CGPoint(x: blockSize.width/2 - rightMargin, y: y))
 19:         }
 20:         let staffLines = SKShapeNode(path: staffPath)
 21:         staffLines.strokeColor = .black
 22:         staffLines.lineWidth = 2
 23:         staffLines.zPosition = 1
 24:         contentNode.addChild(staffLines)
 25:         let trebleClef = SKSpriteNode(imageNamed: "trebleClef")
 26:         trebleClef.size = CGSize(width: 50, height: 95)
 27:         trebleClef.position = CGPoint(x: -blockSize.width/2 + leftMargin + 25, y: -2)
 28:         trebleClef.zPosition = 2
 29:         contentNode.addChild(trebleClef)
 30:         let noteOffset = getNoteOffset(for: desiredNote)
 31:         let notePosition = CGPoint(
 32:             x: baseNoteX,
 33:             y: baseNoteY + noteOffset.y
 34:         )
 35:         let noteImage = SKSpriteNode(imageNamed: "wholeNote")
 36:         noteImage.size = CGSize(width: 23, height: 23)
 37:         noteImage.position = notePosition
 38:         noteImage.zPosition = 3
 39:         contentNode.addChild(noteImage)
 40:         if desiredNote.alteration != .natural {
 41:             let accidentalImage = SKSpriteNode(imageNamed: getAccidentalImageName(for: desiredNote.alteration))
 42:             accidentalImage.size = CGSize(width: 45, height: 80)
 43:             accidentalImage.position = CGPoint(x: notePosition.x - 23, y: notePosition.y)
 44:             accidentalImage.zPosition = 3
 45:             contentNode.addChild(accidentalImage)
 46:         }
 47:         addLedgerLines(for: notePosition.y, in: contentNode, for: desiredNote)
 48:         print("Contenido del bloque generado para nota: \(desiredNote.fullName)")
 49:         return contentNode
 50:     }
 51:     private static func getNoteOffset(for note: MusicalNote) -> CGPoint {
 52:            let baseOffsets: [String: CGFloat] = [
 53:                "DO": -36,
 54:                "RE": -30,
 55:                "MI": -24,
 56:                "FA": -18,
 57:                "SOL": -12,
 58:                "LA": -6,
 59:                "SI": 0
 60:            ]
 61:            guard let baseOffset = baseOffsets[note.name] else {
 62:                return .zero
 63:            }
 64:            let octaveOffset = CGFloat(note.octave - 4) * 42
 65:            return CGPoint(x: 0, y: baseOffset + octaveOffset)
 66:        }
 67:     private static func getAccidentalImageName(for alteration: MusicalNote.Alteration) -> String {
 68:         switch alteration {
 69:         case .sharp:
 70:             return "sharp"
 71:         case .flat:
 72:             return "flat"
 73:         case .natural:
 74:             return ""  // No debería llegar aquí, pero por completitud
 75:         }
 76:     }
 77:     /// Dibuja ledger lines (líneas adicionales) si la nota se sale del pentagrama.
 78:     ///
 79:     /// - Parameters:
 80:     ///   - noteY: La posición Y de la nota.
 81:     ///   - node: El nodo al que se añadirán las ledger lines.
 82:     ///   - note: La nota (MusicalNote) para la cual se determinarán las líneas adicionales.
 83:     private static func addLedgerLines(for noteY: CGFloat, in node: SKNode, for note: MusicalNote) {
 84:         let staffTop: CGFloat = 30
 85:         let staffBottom: CGFloat = -30
 86:         let ledgerLineWidth: CGFloat = 30
 87:         let ledgerLineThickness: CGFloat = 2.0
 88:         func createLedgerLine(at ledgerY: CGFloat) {
 89:             let path = CGMutablePath()
 90:             path.move(to: CGPoint(x: -ledgerLineWidth / 2, y: ledgerY))
 91:             path.addLine(to: CGPoint(x: ledgerLineWidth / 2, y: ledgerY))
 92:             let ledgerLine = SKShapeNode(path: path)
 93:             ledgerLine.strokeColor = .black
 94:             ledgerLine.lineWidth = ledgerLineThickness
 95:             ledgerLine.zPosition = 3.5
 96:             node.addChild(ledgerLine)
 97:         }
 98:         // Para "Do6" y "La3", dibujamos dos ledger lines.
 99:         let isHigh = note.name == "DO" && note.octave == 6
100:                 let isLow = note.name == "LA" && note.octave == 3
101:                 if isHigh {
102:                     createLedgerLine(at: staffTop + 6)
103:                     createLedgerLine(at: staffTop + 18)
104:                 } else if isLow {
105:                     createLedgerLine(at: staffBottom - 6)
106:                     createLedgerLine(at: staffBottom - 18)
107:                 } else {
108:                     if noteY > staffTop {
109:                         createLedgerLine(at: staffTop + 6)
110:                     } else if noteY < staffBottom {
111:                         createLedgerLine(at: staffBottom - 6)
112:                     }
113:                 }
114:             }
115:         }
116: #if DEBUG
117: import SwiftUI
118: struct BlockPreview: PreviewProvider {
119:     static var previews: some View {
120:         BlockPreviewView()
121:             .frame(width: 300, height: 200)
122:             .previewLayout(.fixed(width: 300, height: 200))
123:             .preferredColorScheme(.light)
124:     }
125: }
126: struct BlockPreviewView: View {
127:     var body: some View {
128:         SpriteView(scene: createPreviewScene())
129:     }
130:     private func createPreviewScene() -> SKScene {
131:         let scene = SKScene(size: CGSize(width: 300, height: 200))
132:         scene.backgroundColor = .white
133:         let blockSize = CGSize(width: 270, height: 110)
134:         let exampleNote = MusicalNote(name: "LA", alteration: .sharp, octave: 4)
135:         let blockNode = SKNode()
136:         blockNode.position = CGPoint(x: scene.size.width/2, y: scene.size.height/2)
137:         let background = SKShapeNode(rectOf: blockSize, cornerRadius: 15)
138:         background.fillColor = .white
139:         background.strokeColor = .black
140:         background.lineWidth = 2
141:         blockNode.addChild(background)
142:         let content = BlockContentGenerator.generateBlockContent(
143:             with: .defaultBlock,
144:             blockSize: blockSize,
145:             desiredNote: exampleNote,
146:             baseNoteX: 0,
147:             baseNoteY: 0
148:         )
149:         blockNode.addChild(content)
150:         scene.addChild(blockNode)
151:         return scene
152:     }
153: }
154: struct BlockNotesPreview: PreviewProvider {
155:     static var previews: some View {
156:         VStack(spacing: 20) {
157:             Text("Ejemplos de Bloques Musicales")
158:                 .font(.headline)
159:             VStack(spacing: 20) {
160:                 BlockNoteView(note: MusicalNote(name: "DO", alteration: .natural, octave: 6))
161:                     .frame(width: 270, height: 110)
162:                 BlockNoteView(note: MusicalNote(name: "FA", alteration: .sharp, octave: 4))
163:                     .frame(width: 270, height: 110)
164:             }
165:             VStack(spacing: 20) {
166:                 BlockNoteView(note: MusicalNote(name: "LA", alteration: .flat, octave: 4))
167:                     .frame(width: 270, height: 110)
168:                 BlockNoteView(note: MusicalNote(name: "LA", alteration: .natural, octave: 3))
169:                     .frame(width: 270, height: 110)
170:             }
171:         }
172:         .padding()
173:         .background(Color.white.opacity(0.1))
174:         .previewLayout(.fixed(width: 600, height: 400))
175:     }
176: }
177: struct BlockNoteView: View {
178:     let note: MusicalNote
179:     var body: some View {
180:         SpriteView(scene: createNoteScene())
181:             .border(Color.gray, width: 1)
182:     }
183:     private func createNoteScene() -> SKScene {
184:         let scene = SKScene(size: CGSize(width: 270, height: 110))
185:         scene.backgroundColor = .white
186:         let blockNode = SKNode()
187:         blockNode.position = CGPoint(x: scene.size.width/2, y: scene.size.height/2)
188:         let background = SKShapeNode(rectOf: scene.size, cornerRadius: 15)
189:         background.fillColor = .white
190:         background.strokeColor = .black
191:         background.lineWidth = 2
192:         blockNode.addChild(background)
193:         let content = BlockContentGenerator.generateBlockContent(
194:             with: .iceBlock,
195:             blockSize: scene.size,
196:             desiredNote: note,
197:             baseNoteX: 0,
198:             baseNoteY: 0
199:         )
200:         blockNode.addChild(content)
201:         scene.addChild(blockNode)
202:         return scene
203:     }
204: }
205: #endif
</file>

<file path="MusicBlocks/Bloques/BlocksManager.swift">
  1: import SpriteKit
  2: class BlocksManager {
  3:     private var blockInfos: [BlockInfo] = []
  4:     private var blocks: [SKNode] = []
  5:     private let blockSize: CGSize
  6:     private let blockSpacing: CGFloat
  7:     private weak var mainAreaNode: SKNode?
  8:     private var mainAreaHeight: CGFloat = 0
  9:     private let gameManager = GameManager.shared
 10:         private var spawnAction: SKAction?
 11:         private var isGeneratingBlocks: Bool = false
 12:         private var spawnInterval: TimeInterval
 13:         private var spawnIntervalDecrement: TimeInterval
 14:         private struct Constants {
 15:             static let initialDelay: TimeInterval = 1.0
 16:             static let minSpawnInterval: TimeInterval = 1.5
 17:         }
 18:         init(blockSize: CGSize = CGSize(width: 280, height: 120),
 19:              blockSpacing: CGFloat = 1.0,
 20:              mainAreaNode: SKNode?,
 21:              mainAreaHeight: CGFloat) {
 22:             self.blockSize = blockSize
 23:             self.blockSpacing = blockSpacing
 24:             self.mainAreaNode = mainAreaNode
 25:             self.mainAreaHeight = mainAreaHeight
 26:             if let fallingSpeed = GameManager.shared.currentLevel?.fallingSpeed {
 27:                 self.spawnInterval = fallingSpeed.initial
 28:                 self.spawnIntervalDecrement = fallingSpeed.increment
 29:             } else {
 30:                 self.spawnInterval = 4.0
 31:                 self.spawnIntervalDecrement = 0.0
 32:             }
 33:             print("🔧 BlocksManager inicializado. blockSize: \(blockSize), " +
 34:                   "mainAreaHeight: \(mainAreaHeight), " +
 35:                   "spawnInterval inicial: \(spawnInterval) s, " +
 36:                   "decremento: \(spawnIntervalDecrement) s")
 37:         }
 38:     func startBlockGeneration() {
 39:         print("▶️ startBlockGeneration llamado.")
 40:         guard !isGeneratingBlocks else {
 41:             print("ℹ️ La generación de bloques ya está en curso.")
 42:             return
 43:         }
 44:         isGeneratingBlocks = true
 45:         let initialDelay = SKAction.wait(forDuration: 1.0)
 46:         let beginAction = SKAction.run { [weak self] in
 47:             self?.spawnLoop()
 48:         }
 49:         let sequence = SKAction.sequence([initialDelay, beginAction])
 50:         mainAreaNode?.run(sequence)
 51:         print("✅ Generación de bloques iniciada - spawnInterval: \(spawnInterval) s")
 52:     }
 53:     private func spawnLoop() {
 54:         guard isGeneratingBlocks else {
 55:             print("🛑 Generación detenida, no se continúa el loop.")
 56:             return
 57:         }
 58:         spawnBlock()
 59:         let newInterval = max(spawnInterval - spawnIntervalDecrement, Constants.minSpawnInterval)
 60:         spawnInterval = newInterval
 61:         print("🚀 Nuevo spawnInterval = \(spawnInterval) s (restado \(spawnIntervalDecrement))")
 62:         let wait = SKAction.wait(forDuration: spawnInterval)
 63:         let nextCall = SKAction.run { [weak self] in
 64:             self?.spawnLoop()
 65:         }
 66:         let sequence = SKAction.sequence([wait, nextCall])
 67:         mainAreaNode?.run(sequence)
 68:     }
 69:     func stopBlockGeneration() {
 70:         print("⏹️ stopBlockGeneration llamado.")
 71:         guard isGeneratingBlocks else {
 72:             print("ℹ️ La generación de bloques ya está detenida.")
 73:             return
 74:         }
 75:         isGeneratingBlocks = false
 76:         mainAreaNode?.removeAllActions()
 77:         print("✅ Generación de bloques detenida.")
 78:     }
 79:     private func generateNote(for blockConfig: Block) -> MusicalNote? {
 80:         guard let randomNoteString = blockConfig.notes.randomElement() else {
 81:             print("❌ Error: No hay notas disponibles en la configuración del bloque")
 82:             return nil
 83:         }
 84:         print("📢 Intentando parsear nota: \(randomNoteString)")
 85:         if let note = MusicalNote.parseSpanishFormat(randomNoteString) {
 86:             print("✅ Nota generada correctamente: \(note.fullName)")
 87:             return note
 88:         } else {
 89:             print("❌ Error al parsear la nota: \(randomNoteString)")
 90:             return nil
 91:         }
 92:     }
 93:     private func createBlock() -> SKNode {
 94:         print("➡️ Creando nuevo bloque...")
 95:         guard let currentLevel = gameManager.currentLevel else {
 96:             print("❌ Error: No hay nivel actual")
 97:             return createDefaultBlock()
 98:         }
 99:         let blockNode = SKNode()
100:         blockNode.zPosition = 2
101:         let allowedStyles = currentLevel.allowedStyles
102:         print("📝 Estilos permitidos: \(allowedStyles)")
103:         guard let randomStyle = allowedStyles.randomElement() else {
104:             print("❌ Error: No hay estilos permitidos")
105:             return createDefaultBlock()
106:         }
107:         guard let config = currentLevel.blocks[randomStyle] else {
108:             print("❌ Error: No se encontró configuración para el bloque \(randomStyle)")
109:             return createDefaultBlock()
110:         }
111:         guard let randomNoteString = config.notes.randomElement(),
112:               let note = MusicalNote.parseSpanishFormat(randomNoteString),
113:               let blockStyle = getBlockStyle(for: randomStyle) else {
114:             print("❌ Error: Falló la generación del bloque, usando bloque por defecto.")
115:             return createDefaultBlock()
116:         }
117:         let container = createBlockContainer(with: blockStyle)
118:         blockNode.addChild(container)
119:         let contentNode = BlockContentGenerator.generateBlockContent(
120:             with: blockStyle,
121:             blockSize: blockSize,
122:             desiredNote: note,
123:             baseNoteX: 5,
124:             baseNoteY: 0,
125:             leftMargin: 30,
126:             rightMargin: 30
127:         )
128:         contentNode.position = .zero
129:         contentNode.zPosition = 3
130:         blockNode.addChild(contentNode)
131:         let userData = NSMutableDictionary()
132:         userData.setValue(note.fullName, forKey: "noteName")
133:         userData.setValue(randomStyle, forKey: "blockStyle")
134:         userData.setValue(config.requiredHits, forKey: "requiredHits")
135:         userData.setValue(config.requiredTime, forKey: "requiredTime")
136:         blockNode.userData = userData
137:         print("✅ Bloque creado con nota: \(note.fullName) y estilo: \(randomStyle)")
138:         return blockNode
139:     }
140:     func spawnBlock() {
141:             print("➡️ spawnBlock llamado.")
142:             guard let mainAreaNode = mainAreaNode,
143:                   isGeneratingBlocks else {
144:                 print("❌ No se pueden generar bloques: generación detenida o mainAreaNode es nil")
145:                 return
146:             }
147:             if let firstBlock = blocks.first {
148:                 let topLimit = mainAreaHeight/2 - blockSize.height/2
149:                 let firstBlockTopEdge = firstBlock.position.y + blockSize.height/2
150:                 if abs(firstBlockTopEdge - topLimit) < blockSpacing {
151:                     print("⏸️ Esperando espacio para nuevo bloque.")
152:                     return
153:                 }
154:             }
155:             let newBlock = createBlock()
156:             if let blockInfo = createBlockInfo(for: newBlock) {
157:                 let startY = mainAreaHeight/2 - blockSize.height/2
158:                 newBlock.position = CGPoint(x: 0, y: startY)
159:                 mainAreaNode.addChild(newBlock)
160:                 blocks.insert(newBlock, at: 0)
161:                 blockInfos.insert(blockInfo, at: 0)
162:                 print("✅ Bloque añadido en posición Y: \(startY)")
163:                 updateBlockPositions()
164:             } else {
165:                 print("❌ Error al crear la metadata del bloque.")
166:             }
167:         }
168:     private func createBlockInfo(for block: SKNode) -> BlockInfo? {
169:         guard let userData = block.userData,
170:               let noteData = userData.value(forKey: "noteName") as? String,
171:               let styleData = userData.value(forKey: "blockStyle") as? String,
172:               let config = gameManager.getBlockConfig(for: styleData),
173:               let requiredHits = userData.value(forKey: "requiredHits") as? Int,
174:               let requiredTime = userData.value(forKey: "requiredTime") as? TimeInterval else {
175:             print("❌ Error: Bloque creado sin datos válidos")
176:             return nil
177:         }
178:         let info = BlockInfo(
179:             node: block,
180:             note: noteData,
181:             style: styleData,
182:             config: config,
183:             requiredHits: requiredHits,
184:             requiredTime: requiredTime
185:         )
186:         print("✅ BlockInfo creado: nota \(noteData), estilo \(styleData), requiredHits: \(requiredHits), requiredTime: \(requiredTime)")
187:         return info
188:     }
189:     private func createBlockContainer(with style: BlockStyle) -> SKNode {
190:         let container = SKNode()
191:         container.zPosition = 0
192:         if let shadowColor = style.shadowColor,
193:            let shadowOffset = style.shadowOffset,
194:            let shadowBlur = style.shadowBlur {
195:             let shadowNode = createShadowNode(
196:                 color: shadowColor,
197:                 offset: shadowOffset,
198:                 blur: shadowBlur,
199:                 cornerRadius: style.cornerRadius
200:             )
201:             container.addChild(shadowNode)
202:         }
203:         let background = createBackground(with: style)
204:         container.addChild(background)
205:         return container
206:     }
207:     private func createShadowNode(color: SKColor, offset: CGSize, blur: CGFloat, cornerRadius: CGFloat) -> SKNode {
208:         let shadowNode = SKEffectNode()
209:         shadowNode.shouldRasterize = true
210:         shadowNode.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": blur])
211:         shadowNode.zPosition = 1
212:         let shadowShape = SKShapeNode(rectOf: blockSize, cornerRadius: cornerRadius)
213:         shadowShape.fillColor = color
214:         shadowShape.strokeColor = .clear
215:         shadowShape.alpha = 0.5
216:         shadowNode.addChild(shadowShape)
217:         shadowNode.position = CGPoint(x: offset.width, y: offset.height)
218:         return shadowNode
219:     }
220:     private func createBackground(with style: BlockStyle) -> SKNode {
221:         let background = SKShapeNode(rectOf: blockSize, cornerRadius: style.cornerRadius)
222:         background.fillColor = style.backgroundColor
223:         background.strokeColor = style.borderColor
224:         background.lineWidth = style.borderWidth
225:         background.zPosition = 2
226:         if let texture = style.fillTexture {
227:             background.fillTexture = texture
228:             background.alpha = style.textureOpacity
229:         }
230:         return background
231:     }
232:     private func updateBlockPositions() {
233:         print("↕️ Actualizando posiciones de \(blocks.count) bloques.")
234:         let moveDistance = blockSize.height + blockSpacing
235:         let moveDuration = 0.5
236:         for (index, block) in blocks.enumerated() {
237:             let targetY = (mainAreaHeight/2) - (blockSize.height/2) - (moveDistance * CGFloat(index))
238:             print("   Bloque \(index): moviéndose a Y = \(targetY)")
239:             let moveToPosition = SKAction.moveTo(y: targetY, duration: moveDuration)
240:             moveToPosition.timingMode = .easeInEaseOut
241:             block.removeAllActions()
242:             block.run(moveToPosition)
243:         }
244:     }
245:     func hasBlocksBelowLimit() -> Bool {
246:         let bottomLimit = -mainAreaHeight/2
247:         let result = blocks.contains { block in
248:             let blockBottom = block.position.y - blockSize.height/2
249:             let hasReachedLimit = blockBottom <= bottomLimit
250:             if hasReachedLimit {
251:                 print("⚠️ Bloque ha alcanzado la zona de peligro. blockBottom: \(blockBottom), bottomLimit: \(bottomLimit)")
252:             }
253:             return hasReachedLimit
254:         }
255:         return result
256:     }
257:     var currentBlocks: [SKNode] { blocks }
258:     var blockCount: Int { blocks.count }
259:     func clearBlocks() {
260:         print("🧹 Limpiando bloques...")
261:         stopBlockGeneration()
262:         for block in blocks {
263:             block.removeFromParent()
264:         }
265:         blocks.removeAll()
266:         blockInfos.removeAll()
267:         print("🧹 Bloques eliminados.")
268:     }
269:     func getCurrentBlock() -> BlockInfo? {
270:         print("🔍 Consultando bloque actual...")
271:         if let current = blockInfos.last {
272:             print("🔍 Bloque actual: nota \(current.note), estilo \(current.style)")
273:         } else {
274:             print("🔍 No hay bloque actual.")
275:         }
276:         return blockInfos.last
277:     }
278:     private func selectBlockStyleBasedOnWeights(from blocks: [String: Block]) -> BlockStyle {
279:         print("🔀 Seleccionando estilo basado en pesos...")
280:         var weightedStyles: [(BlockStyle, Double)] = []
281:         for (styleName, blockConfig) in blocks {
282:             if let style = getBlockStyle(for: styleName) {
283:                 weightedStyles.append((style, blockConfig.weight))
284:                 print("   Estilo \(styleName) con peso \(blockConfig.weight) añadido.")
285:             }
286:         }
287:         guard !weightedStyles.isEmpty else {
288:             print("⚠️ No se encontraron estilos con peso. Se retorna defaultBlock.")
289:             return .defaultBlock
290:         }
291:         let totalWeight = weightedStyles.reduce(0) { $0 + $1.1 }
292:         let randomValue = Double.random(in: 0..<totalWeight)
293:         print("   Total de peso: \(totalWeight), valor aleatorio: \(randomValue)")
294:         var accumulatedWeight = 0.0
295:         for (style, weight) in weightedStyles {
296:             accumulatedWeight += weight
297:             if randomValue < accumulatedWeight {
298:                 print("   Estilo seleccionado: \(style)")
299:                 return style
300:             }
301:         }
302:         print("   Estilo seleccionado por defecto: \(weightedStyles[0].0)")
303:         return weightedStyles[0].0
304:     }
305:     private func getBlockStyle(for styleName: String) -> BlockStyle? {
306:         print("🔍 Buscando estilo: \(styleName)")
307:         switch styleName {
308:         case "defaultBlock": return .defaultBlock
309:         case "iceBlock": return .iceBlock
310:         case "hardIceBlock": return .hardiceBlock
311:         case "ghostBlock": return .ghostBlock
312:         case "changingBlock": return .changingBlock
313:         default:
314:             print("⚠️ Estilo no reconocido: \(styleName)")
315:             return nil
316:         }
317:     }
318:     private func createDefaultBlock() -> SKNode {
319:         print("❓ Creando bloque por defecto.")
320:         let blockNode = SKNode()
321:         let style = BlockStyle.defaultBlock
322:         let container = createBlockContainer(with: style)
323:         blockNode.addChild(container)
324:         return blockNode
325:     }
326:     func getCurrentNote() -> String? {
327:         let note = blocks.first?.userData?.value(forKey: "noteName") as? String
328:         print("🔍 Nota actual: \(note ?? "ninguna")")
329:         return note
330:     }
331:     func removeLastBlock() {
332:         print("🗑️ Eliminando último bloque...")
333:         guard let lastBlock = blocks.last,
334:               !blockInfos.isEmpty else {
335:             print("⚠️ No hay bloque para eliminar.")
336:             return
337:         }
338:         let fadeOut = SKAction.fadeOut(withDuration: 0.3)
339:         let scaleDown = SKAction.scale(to: 0.1, duration: 0.3)
340:         let group = SKAction.group([fadeOut, scaleDown])
341:         let remove = SKAction.removeFromParent()
342:         let sequence = SKAction.sequence([group, remove])
343:         lastBlock.run(sequence) { [weak self] in
344:             guard let self = self else { return }
345:             print("🗑️ Bloque eliminado. Actualizando lista de bloques...")
346:             self.blocks.removeLast()
347:             self.blockInfos.removeLast()
348:             self.updateBlockPositions()
349:         }
350:     }
351:     // MARK: - Block Progress Management
352:     func updateCurrentBlockProgress(hitTime: Date) -> Bool {
353:         print("⏱️ updateCurrentBlockProgress llamado a las \(hitTime)")
354:         guard let index = blockInfos.indices.last else {
355:             print("⚠️ No hay bloque actual para actualizar.")
356:             return false
357:         }
358:         var currentInfo = blockInfos[index]
359:         print("   Bloque actual: nota \(currentInfo.note), currentHits: \(currentInfo.currentHits)")
360:         if currentInfo.holdStartTime == nil {
361:             currentInfo.holdStartTime = hitTime
362:             blockInfos[index] = currentInfo
363:             print("   Se inicia el hold del bloque a \(hitTime)")
364:         }
365:         let holdDuration = Date().timeIntervalSince(currentInfo.holdStartTime ?? Date())
366:         print("   Duración del hold: \(holdDuration) (requerida: \(currentInfo.requiredTime))")
367:         if holdDuration >= currentInfo.requiredTime {
368:             currentInfo.currentHits += 1
369:             print("   Hit registrado. currentHits ahora: \(currentInfo.currentHits)")
370:             currentInfo.holdStartTime = nil
371:             blockInfos[index] = currentInfo
372:             if currentInfo.currentHits >= currentInfo.requiredHits {
373:                 print("   Requisitos completos (hits: \(currentInfo.currentHits), requeridos: \(currentInfo.requiredHits)). Se eliminará el bloque.")
374:                 removeLastBlock()
375:                 return true
376:             }
377:         }
378:         return false
379:     }
380:     func resetCurrentBlockProgress() {
381:         print("🔄 Reset current block progress")
382:         guard let index = blockInfos.indices.last else {
383:             print("⚠️ No hay bloque actual para resetear.")
384:             return
385:         }
386:         var currentInfo = blockInfos[index]
387:         currentInfo.currentHits = 0
388:         currentInfo.holdStartTime = nil
389:         blockInfos[index] = currentInfo
390:         print("   Progreso del bloque reseteado.")
391:     }
392: }
</file>

<file path="MusicBlocks/Bloques/BlockStyle.swift">
  1: import SpriteKit
  2: struct BlockStyle {
  3:     let name: String
  4:     let backgroundColor: SKColor
  5:     let borderColor: SKColor
  6:     let borderWidth: CGFloat
  7:     let cornerRadius: CGFloat
  8:     let shadowColor: SKColor?
  9:     let shadowOffset: CGSize?
 10:     let shadowBlur: CGFloat?
 11:     let fillTexture: SKTexture?
 12:     let textureOpacity: CGFloat
 13:     let textureScale: CGFloat
 14:     let specialBehavior: SpecialBehavior?
 15:     enum SpecialBehavior {
 16:         case ghost(fadeOutAlpha: CGFloat, fadeInAlpha: CGFloat, duration: TimeInterval)
 17:         case changing(changeInterval: TimeInterval)
 18:         case explosive(holdTime: TimeInterval)
 19:     }
 20: }
 21: extension BlockStyle {
 22:     static let defaultBlock = BlockStyle(
 23:         name: "defaultBlock",
 24:         backgroundColor: .white,
 25:         borderColor: .black,
 26:         borderWidth: 3.0,
 27:         cornerRadius: 20.0,
 28:         shadowColor: .gray,
 29:         shadowOffset: CGSize(width: 3, height: -3),
 30:         shadowBlur: 4.0,
 31:         fillTexture: nil,
 32:         textureOpacity: 1.0,
 33:         textureScale: 1.0,
 34:         specialBehavior: nil
 35:     )
 36:     static let iceBlock = BlockStyle(
 37:         name: "iceBlock",
 38:         backgroundColor: SKColor(red: 0.8, green: 0.9, blue: 1.0, alpha: 0.5),
 39:         borderColor: SKColor(red: 0.5, green: 0.7, blue: 0.9, alpha: 1.0),
 40:         borderWidth: 3.0,
 41:         cornerRadius: 20.0,
 42:         shadowColor: SKColor.blue,
 43:         shadowOffset: CGSize(width: 2, height: -2),
 44:         shadowBlur: 4.0,
 45:         fillTexture: SKTexture(imageNamed: "iceTexture4"),
 46:         textureOpacity: 0.5,
 47:         textureScale: 1.0,
 48:         specialBehavior: nil
 49:     )
 50:     static let hardiceBlock = BlockStyle(
 51:         name: "hardiceBlock",
 52:         backgroundColor: SKColor(red: 0.6, green: 0.8, blue: 1.0, alpha: 1.0),
 53:         borderColor: SKColor.blue,
 54:         borderWidth: 3.0,
 55:         cornerRadius: 20.0,
 56:         shadowColor: SKColor.darkGray,
 57:         shadowOffset: CGSize(width: 3, height: -3),
 58:         shadowBlur: 3.0,
 59:         fillTexture: SKTexture(imageNamed: "iceTexture3"),
 60:         textureOpacity: 0.2,
 61:         textureScale: 1.0,
 62:         specialBehavior: nil
 63:     )
 64:     static let ghostBlock = BlockStyle(
 65:         name: "ghostBlock",
 66:         backgroundColor: SKColor(white: 0.9, alpha: 0.5),
 67:         borderColor: SKColor(white: 0.8, alpha: 0.7),
 68:         borderWidth: 3.0,
 69:         cornerRadius: 20.0,
 70:         shadowColor: nil,
 71:         shadowOffset: nil,
 72:         shadowBlur: nil,
 73:         fillTexture: SKTexture(imageNamed: "ghostTexture"),
 74:         textureOpacity: 1.0,
 75:         textureScale: 1.0,
 76:         specialBehavior: .ghost(fadeOutAlpha: 0.2, fadeInAlpha: 0.7, duration: 0.5)
 77:     )
 78:     static let changingBlock = BlockStyle(
 79:         name: "changingBlock",
 80:         backgroundColor: SKColor(red: 0.8, green: 0.6, blue: 1.0, alpha: 1.0),
 81:         borderColor: SKColor.magenta,
 82:         borderWidth: 3.0,
 83:         cornerRadius: 20.0,
 84:         shadowColor: SKColor.purple,
 85:         shadowOffset: CGSize(width: 2, height: -2),
 86:         shadowBlur: 4.0,
 87:         fillTexture: SKTexture(imageNamed: "wavesTexture"),
 88:         textureOpacity: 1.0,
 89:         textureScale: 1.0,
 90:         specialBehavior: .changing(changeInterval: 1.0)
 91:     )
 92:     static let explosiveBlock = BlockStyle(
 93:         name: "explosiveBlock",
 94:         backgroundColor: SKColor(red: 1.0, green: 0.5, blue: 0.0, alpha: 1.0),
 95:         borderColor: SKColor.red,
 96:         borderWidth: 3.0,
 97:         cornerRadius: 20.0,
 98:         shadowColor: SKColor.red,
 99:         shadowOffset: CGSize(width: 4, height: -4),
100:         shadowBlur: 6.0,
101:         fillTexture: SKTexture(imageNamed: "explosionTexture"),
102:         textureOpacity: 1.0,
103:         textureScale: 1.0,
104:         specialBehavior: .explosive(holdTime: 4.0)
105:     )
106: }
</file>

<file path="MusicBlocks/Bloques/MusicalNote.swift">
  1: import CoreGraphics
  2: import Foundation
  3: struct MusicalNote: Equatable, Identifiable {
  4:     enum Alteration: String {
  5:         case sharp = "#"
  6:         case flat = "♭"
  7:         case natural = ""   /// Natural
  8:     }
  9:     // MARK: - Properties
 10:     let id = UUID()
 11:     let name: String         // Nombre de la nota (DO, RE, MI, etc.)
 12:     let alteration: Alteration
 13:     let octave: Int
 14:     // MARK: - Computed Properties
 15:     var fullName: String {
 16:         "\(name)\(alteration.rawValue)\(octave)"
 17:     }
 18:     var displayName: String {
 19:         let baseName = name.capitalized
 20:         return alteration == .natural ? baseName : "\(baseName)\(alteration.rawValue)"
 21:     }
 22:     /// Posición vertical de la nota en el pentagrama
 23:     var staffOffset: CGPoint {
 24:         let baseOffset: [String: CGFloat] = [
 25:             "DO": -36,
 26:             "RE": -30,
 27:             "MI": -24,
 28:             "FA": -18,
 29:             "SOL": -12,
 30:             "LA": -6,
 31:             "SI": 0
 32:         ]
 33:         guard let offset = baseOffset[name] else { return .zero }
 34:         return CGPoint(x: 0, y: offset + (CGFloat(octave - 4) * 42))
 35:     }
 36:     private static let enharmonicEquivalents: [String: String] = [
 37:         "DO#": "RE♭", "RE♭": "DO#",
 38:         "RE#": "MI♭", "MI♭": "RE#",
 39:         "FA#": "SOL♭", "SOL♭": "FA#",
 40:         "SOL#": "LA♭", "LA♭": "SOL#",
 41:         "LA#": "SI♭", "SI♭": "LA#"
 42:     ]
 43:     static func generateAvailableNotes() -> [MusicalNote] {
 44:         var notes: [MusicalNote] = []
 45:         func addNote(_ name: String, octave: Int) {
 46:             notes.append(MusicalNote(name: name, alteration: .natural, octave: octave))
 47:             switch name {
 48:             case "DO":
 49:                 notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
 50:             case "RE":
 51:                 notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
 52:                 notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
 53:             case "MI":
 54:                 notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
 55:             case "FA":
 56:                 notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
 57:             case "SOL":
 58:                 notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
 59:                 notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
 60:             case "LA":
 61:                 notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
 62:                 notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
 63:             case "SI":
 64:                 notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
 65:             default: break
 66:             }
 67:         }
 68:         ["LA", "SI"].forEach { name in
 69:             addNote(name, octave: 3)
 70:         }
 71:         for octave in 4...5 {
 72:             ["DO", "RE", "MI", "FA", "SOL", "LA", "SI"].forEach { name in
 73:                 addNote(name, octave: octave)
 74:             }
 75:         }
 76:         addNote("DO", octave: 6)
 77:         return notes
 78:     }
 79:     static func parse(_ noteString: String) -> MusicalNote? {
 80:         let pattern = "([A-Z]+)([#♭]?)([0-9])"
 81:         let regex = try? NSRegularExpression(pattern: pattern, options: [])
 82:         if let match = regex?.firstMatch(in: noteString, options: [], range: NSRange(noteString.startIndex..., in: noteString)) {
 83:             let name = String(noteString[Range(match.range(at: 1), in: noteString)!])
 84:             let alterationString = String(noteString[Range(match.range(at: 2), in: noteString)!])
 85:             let octave = Int(String(noteString[Range(match.range(at: 3), in: noteString)!]))!
 86:             let alteration: Alteration = alterationString == "#" ? .sharp :
 87:                                        alterationString == "♭" ? .flat : .natural
 88:             return MusicalNote(name: name, alteration: alteration, octave: octave)
 89:         }
 90:         return nil
 91:     }
 92:     func isEnharmonicWith(_ other: MusicalNote) -> Bool {
 93:         let thisNote = "\(name)\(alteration.rawValue)"
 94:         let otherNote = "\(other.name)\(other.alteration.rawValue)"
 95:         return MusicalNote.enharmonicEquivalents[thisNote] == otherNote && octave == other.octave
 96:     }
 97:     static func == (lhs: MusicalNote, rhs: MusicalNote) -> Bool {
 98:         return lhs.fullName == rhs.fullName || lhs.isEnharmonicWith(rhs)
 99:     }
100: }
101: extension MusicalNote {
102:     private static let noteNameMap: [String: String] = [
103:         "do": "DO", "DO": "DO",
104:         "re": "RE", "RE": "RE",
105:         "mi": "MI", "MI": "MI",
106:         "fa": "FA", "FA": "FA",
107:         "sol": "SOL", "SOL": "SOL",
108:         "la": "LA", "LA": "LA",
109:         "si": "SI", "SI": "SI"
110:     ]
111:     static func parseSpanishFormat(_ noteString: String) -> MusicalNote? {
112:         let pattern = "([a-zA-Z]+)([#b♭]?)([0-9])"
113:         let regex = try? NSRegularExpression(pattern: pattern, options: [])
114:         if let match = regex?.firstMatch(in: noteString, options: [], range: NSRange(noteString.startIndex..., in: noteString)) {
115:             let noteName = String(noteString[Range(match.range(at: 1), in: noteString)!])
116:             let alterationString = String(noteString[Range(match.range(at: 2), in: noteString)!])
117:             let octave = Int(String(noteString[Range(match.range(at: 3), in: noteString)!]))!
118:             guard let standardName = noteNameMap[noteName.lowercased()] else {
119:                 print("❌ Nombre de nota no reconocido: \(noteName)")
120:                 return nil
121:             }
122:             let alteration: Alteration
123:             switch alterationString {
124:             case "#":
125:                 alteration = .sharp
126:             case "b", "♭":
127:                 alteration = .flat
128:             default:
129:                 alteration = .natural
130:             }
131:             print("✅ Nota parseada: \(standardName)\(alteration.rawValue)\(octave)")
132:             return MusicalNote(name: standardName, alteration: alteration, octave: octave)
133:         }
134:         print("❌ No se pudo parsear la nota: \(noteString)")
135:         return nil
136:     }
137: }
</file>

<file path="MusicBlocks/Inicio y Profile/AchievementBadge.swift">
  1: import UIKit
  2: struct MedalCategory {
  3:     let type: MedalType
  4:     let medals: [MedalInfo]
  5:     var title: String {
  6:         switch type {
  7:         case .notesHit:
  8:             return "Precisión Musical"
  9:         case .playTime:
 10:             return "Dedicación"
 11:         case .streaks:
 12:             return "Racha"
 13:         case .perfectTuning:
 14:             return "Afinación"
 15:         }
 16:     }
 17: }
 18: enum MedalType: String {
 19:     case notesHit = "notes_hit"
 20:     case playTime = "play_time"
 21:     case streaks = "streaks"
 22:     case perfectTuning = "perfect_tuning"
 23: }
 24: extension MedalType: CaseIterable {
 25:     var icon: String {
 26:         switch self {
 27:         case .notesHit:
 28:             return "🎵"
 29:         case .playTime:
 30:             return "⏱"
 31:         case .streaks:
 32:             return "🔥"
 33:         case .perfectTuning:
 34:             return "⭐️"
 35:         }
 36:     }
 37:     var title: String {
 38:         switch self {
 39:         case .notesHit:
 40:             return "Precisión Musical"
 41:         case .playTime:
 42:             return "Dedicación"
 43:         case .streaks:
 44:             return "Racha"
 45:         case .perfectTuning:
 46:             return "Afinación"
 47:         }
 48:     }
 49:     var shortTitle: String {
 50:         switch self {
 51:         case .notesHit:
 52:             return "Precisión"
 53:         case .playTime:
 54:             return "Tiempo"
 55:         case .streaks:
 56:             return "Rachas"
 57:         case .perfectTuning:
 58:             return "Afinación"
 59:         }
 60:     }
 61: }
 62: struct MedalInfo {
 63:     let name: String
 64:     let requirement: String
 65:     let image: String
 66:     let objective: MedalObjective?
 67:     var isUnlocked: Bool
 68:     init(from medal: Medal, isUnlocked: Bool = false) {
 69:         self.name = medal.name
 70:         self.requirement = medal.requirement
 71:         self.image = medal.image
 72:         self.objective = medal.objective
 73:         self.isUnlocked = isUnlocked
 74:     }
 75: }
 76: final class MedalManager {
 77:     static let shared = MedalManager()
 78:     private(set) var medals: [MedalCategory] = []
 79:     private var gameConfig: GameConfig?
 80:     private init() {
 81:         loadMedals()
 82:     }
 83:     func loadMedals() {
 84:         gameConfig = GameLevelProcessor.loadGameLevelsFromFile()
 85:         if let config = gameConfig {
 86:             let medalsData = GameLevelProcessor.getMedals(from: config)
 87:             medals = [
 88:                 MedalCategory(type: .notesHit, medals: medalsData.notesHit.map { MedalInfo(from: $0) }),
 89:                 MedalCategory(type: .playTime, medals: medalsData.playTime.map { MedalInfo(from: $0) }),
 90:                 MedalCategory(type: .streaks, medals: medalsData.streaks.map { MedalInfo(from: $0) }),
 91:                 MedalCategory(type: .perfectTuning, medals: medalsData.perfectTuning.map { MedalInfo(from: $0) })
 92:             ]
 93:             loadMedalsProgress()
 94:         }
 95:     }
 96:     func getMedals() -> [MedalCategory] {
 97:         return medals
 98:     }
 99:     func updateMedals(notesHit: Int, playTime: TimeInterval, currentStreak: Int, perfectTuningCount: Int) {
100:         medals = medals.map { category in
101:             var updatedMedals = category.medals
102:             switch category.type {
103:             case .notesHit:
104:                 updatedMedals = category.medals.map { medal in
105:                     var updatedMedal = medal
106:                     if let requirement = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
107:                         updatedMedal.isUnlocked = notesHit >= requirement
108:                     }
109:                     return updatedMedal
110:                 }
111:             case .playTime:
112:                 updatedMedals = category.medals.map { medal in
113:                     var updatedMedal = medal
114:                     let playTimeHours = playTime / 3600
115:                     if medal.requirement.contains("minutos") {
116:                         if let minutes = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
117:                             updatedMedal.isUnlocked = playTimeHours * 60 >= Double(minutes)
118:                         }
119:                     } else if medal.requirement.contains("horas") {
120:                         if let hours = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
121:                             updatedMedal.isUnlocked = playTimeHours >= Double(hours)
122:                         }
123:                     }
124:                     return updatedMedal
125:                 }
126:             case .streaks:
127:                 updatedMedals = category.medals.map { medal in
128:                     var updatedMedal = medal
129:                     if let requirement = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
130:                         updatedMedal.isUnlocked = currentStreak >= requirement
131:                     }
132:                     return updatedMedal
133:                 }
134:             case .perfectTuning:
135:                 updatedMedals = category.medals.map { medal in
136:                     var updatedMedal = medal
137:                     if let requirement = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
138:                         updatedMedal.isUnlocked = perfectTuningCount >= requirement
139:                     }
140:                     return updatedMedal
141:                 }
142:             }
143:             return MedalCategory(type: category.type, medals: updatedMedals)
144:         }
145:         saveMedalsProgress()
146:     }
147:     private func saveMedalsProgress() {
148:         let progress = medals.map { category in
149:             return (category.type.rawValue, category.medals.map { $0.isUnlocked })
150:         }
151:         let progressDict = Dictionary(uniqueKeysWithValues: progress)
152:         UserDefaults.standard.set(progressDict, forKey: "medalsProgress")
153:     }
154:     private func loadMedalsProgress() {
155:         if let progressDict = UserDefaults.standard.dictionary(forKey: "medalsProgress") as? [String: [Bool]] {
156:             medals = medals.map { category in
157:                 let unlockedStates = progressDict[category.type.rawValue] ?? Array(repeating: false, count: category.medals.count)
158:                 let updatedMedals = zip(category.medals, unlockedStates).map { medal, isUnlocked in
159:                     MedalInfo(
160:                         from: Medal(
161:                             name: medal.name,
162:                             requirement: medal.requirement,
163:                             image: medal.image,
164:                             objective: medal.objective ?? createDefaultObjective(for: category.type, requirement: medal.requirement)
165:                         ),
166:                         isUnlocked: isUnlocked
167:                     )
168:                 }
169:                 return MedalCategory(type: category.type, medals: updatedMedals)
170:             }
171:         }
172:     }
173:     private func createDefaultObjective(for type: MedalType, requirement: String) -> MedalObjective {
174:         let target = extractTarget(from: requirement)
175:         switch type {
176:         case .notesHit:
177:             return MedalObjective(
178:                 type: type.rawValue,
179:                 target: target,
180:                 lifetime: true,
181:                 resetOnFail: false,
182:                 accuracy: nil
183:             )
184:         case .playTime:
185:             return MedalObjective(
186:                 type: type.rawValue,
187:                 target: target,
188:                 lifetime: true,
189:                 resetOnFail: false,
190:                 accuracy: nil
191:             )
192:         case .streaks:
193:             return MedalObjective(
194:                 type: type.rawValue,
195:                 target: target,
196:                 lifetime: false,
197:                 resetOnFail: true,
198:                 accuracy: nil
199:             )
200:         case .perfectTuning:
201:             return MedalObjective(
202:                 type: type.rawValue,
203:                 target: target,
204:                 lifetime: true,
205:                 resetOnFail: false,
206:                 accuracy: 1.0
207:             )
208:         }
209:     }
210:     private func extractTarget(from requirement: String) -> Int {
211:         if let target = Int(requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
212:             if requirement.contains("minutos") {
213:                 return target * 60
214:             } else if requirement.contains("horas") {
215:                 return target * 3600
216:             }
217:             return target
218:         }
219:         return 0
220:     }
221: }
</file>

<file path="MusicBlocks/Inicio y Profile/AchievementsView.swift">
  1: import UIKit
  2: class AchievementsView: UIView {
  3:     private let stackView: UIStackView = {
  4:         let stack = UIStackView()
  5:         stack.axis = .vertical
  6:         stack.spacing = 16
  7:         return stack
  8:     }()
  9:     private let medalStatsView = MedalStatsView()
 10:     private let medalsGridView = MedalsGridView()
 11:     init(medals: [MedalCategory]) {
 12:         super.init(frame: .zero)
 13:         setupViews()
 14:         configure(with: medals)
 15:     }
 16:     required init?(coder: NSCoder) {
 17:         fatalError("init(coder:) has not been implemented")
 18:     }
 19:     private func setupViews() {
 20:         stackView.translatesAutoresizingMaskIntoConstraints = false
 21:         addSubview(stackView)
 22:         stackView.addArrangedSubview(medalStatsView)
 23:         stackView.addArrangedSubview(medalsGridView)
 24:         NSLayoutConstraint.activate([
 25:             stackView.topAnchor.constraint(equalTo: topAnchor, constant: 4),
 26:             stackView.leadingAnchor.constraint(equalTo: leadingAnchor),
 27:             stackView.trailingAnchor.constraint(equalTo: trailingAnchor),
 28:             stackView.bottomAnchor.constraint(equalTo: bottomAnchor)
 29:         ])
 30:     }
 31:     func configure(with medals: [MedalCategory]) {
 32:         medalStatsView.configure(with: medals)
 33:         medalsGridView.configure(with: medals)
 34:     }
 35: }
 36: class MedalStatsView: UIView {
 37:     private let titleLabel: UILabel = {
 38:         let label = UILabel()
 39:         label.text = "Progreso de Medallas"
 40:         label.font = .systemFont(ofSize: 17, weight: .semibold)
 41:         return label
 42:     }()
 43:     private let subtitleLabel: UILabel = {
 44:         let label = UILabel()
 45:         label.font = .systemFont(ofSize: 14)
 46:         label.textColor = .secondaryLabel
 47:         return label
 48:     }()
 49:     private let typeStackView: UIStackView = {
 50:         let stack = UIStackView()
 51:         stack.axis = .horizontal
 52:         stack.distribution = .fillEqually
 53:         stack.spacing = 16
 54:         return stack
 55:     }()
 56:     override init(frame: CGRect) {
 57:         super.init(frame: frame)
 58:         setupViews()
 59:     }
 60:     required init?(coder: NSCoder) {
 61:         fatalError("init(coder:) has not been implemented")
 62:     }
 63:     private func setupViews() {
 64:         [titleLabel, subtitleLabel, typeStackView].forEach {
 65:             $0.translatesAutoresizingMaskIntoConstraints = false
 66:             addSubview($0)
 67:         }
 68:         NSLayoutConstraint.activate([
 69:             titleLabel.topAnchor.constraint(equalTo: topAnchor, constant: 16),
 70:             titleLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
 71:             subtitleLabel.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 4),
 72:             subtitleLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
 73:             typeStackView.topAnchor.constraint(equalTo: subtitleLabel.bottomAnchor, constant: 16),
 74:             typeStackView.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
 75:             typeStackView.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
 76:             typeStackView.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -16)
 77:         ])
 78:         layer.cornerRadius = 12
 79:         backgroundColor = .systemGray6
 80:     }
 81:     func configure(with medals: [MedalCategory]) {
 82:         typeStackView.arrangedSubviews.forEach { $0.removeFromSuperview() }
 83:         let totalStats = getTotalStats(from: medals)
 84:         subtitleLabel.text = "\(totalStats.unlocked) de \(totalStats.total) medallas desbloqueadas"
 85:         MedalType.allCases.forEach { type in
 86:             if let category = medals.first(where: { $0.type == type }) {
 87:                 let stats = getCategoryStats(for: category)
 88:                 let typeView = MedalTypeView(
 89:                     type: type,
 90:                     unlockedCount: stats.unlocked,
 91:                     totalCount: stats.total
 92:                 )
 93:                 typeStackView.addArrangedSubview(typeView)
 94:             }
 95:         }
 96:     }
 97:     private func getTotalStats(from medals: [MedalCategory]) -> (unlocked: Int, total: Int) {
 98:         let unlocked = medals.reduce(0) { $0 + $1.medals.filter { $0.isUnlocked }.count }
 99:         let total = medals.reduce(0) { $0 + $1.medals.count }
100:         return (unlocked, total)
101:     }
102:     private func getCategoryStats(for category: MedalCategory) -> (unlocked: Int, total: Int) {
103:         let unlocked = category.medals.filter { $0.isUnlocked }.count
104:         return (unlocked, category.medals.count)
105:     }
106: }
107: class MedalTypeView: UIView {
108:     private let iconLabel: UILabel = {
109:         let label = UILabel()
110:         label.font = .systemFont(ofSize: 24)
111:         label.textAlignment = .center
112:         return label
113:     }()
114:     private let statsLabel: UILabel = {
115:         let label = UILabel()
116:         label.font = .systemFont(ofSize: 12, weight: .medium)
117:         label.textAlignment = .center
118:         return label
119:     }()
120:     private let titleLabel: UILabel = {
121:         let label = UILabel()
122:         label.font = .systemFont(ofSize: 10)
123:         label.textColor = .secondaryLabel
124:         label.textAlignment = .center
125:         return label
126:     }()
127:     init(type: MedalType, unlockedCount: Int, totalCount: Int) {
128:         super.init(frame: .zero)
129:         setupViews()
130:         configure(with: type, unlockedCount: unlockedCount, totalCount: totalCount)
131:     }
132:     required init?(coder: NSCoder) {
133:         fatalError("init(coder:) has not been implemented")
134:     }
135:     private func setupViews() {
136:         [iconLabel, statsLabel, titleLabel].forEach {
137:             $0.translatesAutoresizingMaskIntoConstraints = false
138:             addSubview($0)
139:         }
140:         NSLayoutConstraint.activate([
141:             iconLabel.topAnchor.constraint(equalTo: topAnchor, constant: 8),
142:             iconLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
143:             statsLabel.topAnchor.constraint(equalTo: iconLabel.bottomAnchor, constant: 4),
144:             statsLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
145:             titleLabel.topAnchor.constraint(equalTo: statsLabel.bottomAnchor, constant: 2),
146:             titleLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
147:             titleLabel.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -8)
148:         ])
149:         layer.cornerRadius = 8
150:     }
151:     private func configure(with type: MedalType, unlockedCount: Int, totalCount: Int) {
152:         iconLabel.text = type.icon
153:         statsLabel.text = "\(unlockedCount)/\(totalCount)"
154:         titleLabel.text = type.shortTitle
155:         backgroundColor = typeColor(for: type).withAlphaComponent(0.1)
156:     }
157:     private func typeColor(for type: MedalType) -> UIColor {
158:         switch type {
159:         case .notesHit:
160:             return .systemBlue
161:         case .playTime:
162:             return .systemRed
163:         case .streaks:
164:             return .systemYellow
165:         case .perfectTuning:
166:             return .systemPurple
167:         }
168:     }
169: }
170: class MedalsGridView: UIView {
171:     private let stackView: UIStackView = {
172:         let stack = UIStackView()
173:         stack.axis = .vertical
174:         stack.spacing = 16
175:         return stack
176:     }()
177:     override init(frame: CGRect) {
178:         super.init(frame: frame)
179:         setupViews()
180:     }
181:     required init?(coder: NSCoder) {
182:         fatalError("init(coder:) has not been implemented")
183:     }
184:     private func setupViews() {
185:         stackView.translatesAutoresizingMaskIntoConstraints = false
186:         addSubview(stackView)
187:         NSLayoutConstraint.activate([
188:             stackView.topAnchor.constraint(equalTo: topAnchor),
189:             stackView.leadingAnchor.constraint(equalTo: leadingAnchor),
190:             stackView.trailingAnchor.constraint(equalTo: trailingAnchor),
191:             stackView.bottomAnchor.constraint(equalTo: bottomAnchor)
192:         ])
193:     }
194:     func configure(with medals: [MedalCategory]) {
195:         stackView.arrangedSubviews.forEach { $0.removeFromSuperview() }
196:         medals.forEach { category in
197:             let categoryView = MedalCategoryView(category: category)
198:             stackView.addArrangedSubview(categoryView)
199:         }
200:     }
201: }
202: class MedalCategoryView: UIView {
203:     private let titleLabel: UILabel = {
204:         let label = UILabel()
205:         label.font = .systemFont(ofSize: 17, weight: .semibold)
206:         return label
207:     }()
208:     private let statsLabel: UILabel = {
209:         let label = UILabel()
210:         label.font = .systemFont(ofSize: 12)
211:         label.textColor = .secondaryLabel
212:         return label
213:     }()
214:     private let scrollView: UIScrollView = {
215:         let scroll = UIScrollView()
216:         scroll.showsHorizontalScrollIndicator = false
217:         return scroll
218:     }()
219:     private let medalsStack: UIStackView = {
220:         let stack = UIStackView()
221:         stack.axis = .horizontal
222:         stack.spacing = 12
223:         return stack
224:     }()
225:     init(category: MedalCategory) {
226:         super.init(frame: .zero)
227:         setupViews()
228:         configure(with: category)
229:     }
230:     required init?(coder: NSCoder) {
231:         fatalError("init(coder:) has not been implemented")
232:     }
233:     private func setupViews() {
234:         [titleLabel, statsLabel, scrollView].forEach {
235:             $0.translatesAutoresizingMaskIntoConstraints = false
236:             addSubview($0)
237:         }
238:         scrollView.addSubview(medalsStack)
239:         medalsStack.translatesAutoresizingMaskIntoConstraints = false
240:         NSLayoutConstraint.activate([
241:             titleLabel.topAnchor.constraint(equalTo: topAnchor),
242:             titleLabel.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
243:             statsLabel.centerYAnchor.constraint(equalTo: titleLabel.centerYAnchor),
244:             statsLabel.leadingAnchor.constraint(equalTo: titleLabel.trailingAnchor, constant: 8),
245:             scrollView.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 12),
246:             scrollView.leadingAnchor.constraint(equalTo: leadingAnchor),
247:             scrollView.trailingAnchor.constraint(equalTo: trailingAnchor),
248:             scrollView.bottomAnchor.constraint(equalTo: bottomAnchor),
249:             medalsStack.topAnchor.constraint(equalTo: scrollView.topAnchor),
250:             medalsStack.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor, constant: 16),
251:             medalsStack.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor, constant: -16),
252:             medalsStack.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
253:             medalsStack.heightAnchor.constraint(equalTo: scrollView.heightAnchor)
254:         ])
255:     }
256:     private func configure(with category: MedalCategory) {
257:         titleLabel.text = category.title
258:         let stats = getCategoryStats(for: category)
259:         statsLabel.text = "\(stats.unlocked)/\(stats.total)"
260:         category.medals.forEach { medal in
261:             let medalView = MedalView(
262:                 medalInfo: medal,
263:                 color: typeColor(for: category.type)
264:             )
265:             medalsStack.addArrangedSubview(medalView)
266:         }
267:     }
268:     private func getCategoryStats(for category: MedalCategory) -> (unlocked: Int, total: Int) {
269:         let unlocked = category.medals.filter { $0.isUnlocked }.count
270:         return (unlocked, category.medals.count)
271:     }
272:     private func typeColor(for type: MedalType) -> UIColor {
273:         switch type {
274:         case .notesHit:
275:             return .systemBlue
276:         case .playTime:
277:             return .systemRed
278:         case .streaks:
279:             return .systemYellow
280:         case .perfectTuning:
281:             return .systemPurple
282:         }
283:     }
284: }
285: class MedalView: UIView {
286:     private let imageView: UIImageView = {
287:         let imageView = UIImageView()
288:         imageView.contentMode = .scaleAspectFit
289:         return imageView
290:     }()
291:     private let lockImageView: UIImageView = {
292:         let imageView = UIImageView()
293:         imageView.image = UIImage(systemName: "lock.fill")
294:         imageView.tintColor = .white
295:         return imageView
296:     }()
297:     private let nameLabel: UILabel = {
298:         let label = UILabel()
299:         label.font = .systemFont(ofSize: 12, weight: .medium)
300:         label.textAlignment = .center
301:         label.numberOfLines = 0
302:         return label
303:     }()
304:     private let requirementLabel: UILabel = {
305:         let label = UILabel()
306:         label.font = .systemFont(ofSize: 10)
307:         label.textColor = .secondaryLabel
308:         label.textAlignment = .center
309:         label.numberOfLines = 0
310:         return label
311:     }()
312:     init(medalInfo: MedalInfo, color: UIColor) {
313:         super.init(frame: .zero)
314:         setupViews()
315:         configure(with: medalInfo, color: color)
316:     }
317:     required init?(coder: NSCoder) {
318:         fatalError("init(coder:) has not been implemented")
319:     }
320:     private func setupViews() {
321:         [imageView, lockImageView, nameLabel, requirementLabel].forEach {
322:             $0.translatesAutoresizingMaskIntoConstraints = false
323:             addSubview($0)
324:         }
325:         NSLayoutConstraint.activate([
326:             imageView.topAnchor.constraint(equalTo: topAnchor, constant: 8),
327:             imageView.centerXAnchor.constraint(equalTo: centerXAnchor),
328:             imageView.widthAnchor.constraint(equalToConstant: 60),
329:             imageView.heightAnchor.constraint(equalToConstant: 60),
330:             lockImageView.centerXAnchor.constraint(equalTo: imageView.centerXAnchor),
331:             lockImageView.centerYAnchor.constraint(equalTo: imageView.centerYAnchor),
332:             lockImageView.widthAnchor.constraint(equalToConstant: 20),
333:             lockImageView.heightAnchor.constraint(equalToConstant: 20),
334:             nameLabel.topAnchor.constraint(equalTo: imageView.bottomAnchor, constant: 8),
335:             nameLabel.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 8),
336:             nameLabel.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -8),
337:             requirementLabel.topAnchor.constraint(equalTo: nameLabel.bottomAnchor, constant: 4),
338:             requirementLabel.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 8),
339:             requirementLabel.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -8),
340:             requirementLabel.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -8)
341:         ])
342:         layer.cornerRadius = 12
343:         backgroundColor = .systemGray6
344:         widthAnchor.constraint(equalToConstant: 120).isActive = true
345:     }
346:     private func configure(with medalInfo: MedalInfo, color: UIColor) {
347:         imageView.image = UIImage(named: medalInfo.image)
348:         imageView.alpha = medalInfo.isUnlocked ? 1.0 : 0.3
349:         lockImageView.isHidden = medalInfo.isUnlocked
350:         nameLabel.text = medalInfo.name
351:         nameLabel.textColor = medalInfo.isUnlocked ? .label : .secondaryLabel
352:         requirementLabel.text = medalInfo.requirement
353:         layer.borderWidth = 2
354:         layer.borderColor = medalInfo.isUnlocked ? color.cgColor : UIColor.systemGray.cgColor
355:         alpha = medalInfo.isUnlocked ? 1.0 : 0.8
356:         if !medalInfo.isUnlocked {
357:             let overlayView = UIView()
358:             overlayView.backgroundColor = .black
359:             overlayView.alpha = 0.3
360:             overlayView.translatesAutoresizingMaskIntoConstraints = false
361:             insertSubview(overlayView, aboveSubview: imageView)
362:             NSLayoutConstraint.activate([
363:                 overlayView.topAnchor.constraint(equalTo: imageView.topAnchor),
364:                 overlayView.leadingAnchor.constraint(equalTo: imageView.leadingAnchor),
365:                 overlayView.trailingAnchor.constraint(equalTo: imageView.trailingAnchor),
366:                 overlayView.bottomAnchor.constraint(equalTo: imageView.bottomAnchor)
367:             ])
368:             overlayView.layer.cornerRadius = 30
369:             overlayView.clipsToBounds = true
370:         }
371:     }
372: }
373: #if DEBUG
374: import SwiftUI
375: private func getMockMedals() -> [MedalCategory] {
376:     guard let gameConfig = GameLevelProcessor.loadGameLevelsFromFile(),
377:           let medals = try? JSONDecoder().decode(Medals.self, from: JSONEncoder().encode(gameConfig.medals)) else {
378:         return []
379:     }
380:     return [
381:         MedalCategory(
382:             type: .notesHit,
383:             medals: medals.notesHit.map { medal in
384:                 MedalInfo(
385:                     from: medal,
386:                     isUnlocked: Bool.random()
387:                 )
388:             }
389:         ),
390:         MedalCategory(
391:             type: .playTime,
392:             medals: medals.playTime.map { medal in
393:                 MedalInfo(
394:                     from: medal,
395:                     isUnlocked: Bool.random()
396:                 )
397:             }
398:         ),
399:         MedalCategory(
400:             type: .streaks,
401:             medals: medals.streaks.map { medal in
402:                 MedalInfo(
403:                     from: medal,
404:                     isUnlocked: Bool.random()
405:                 )
406:             }
407:         ),
408:         MedalCategory(
409:             type: .perfectTuning,
410:             medals: medals.perfectTuning.map { medal in
411:                 MedalInfo(
412:                     from: medal,
413:                     isUnlocked: Bool.random()
414:                 )
415:             }
416:         )
417:     ]
418: }
419: @available(iOS 17.0, *)
420: struct AchievementsView_Previews: PreviewProvider {
421:     static var previews: some View {
422:         AchievementsViewRepresentable()
423:             .frame(height: 600)
424:             .padding()
425:             .previewDisplayName("Light Mode")
426:         AchievementsViewRepresentable()
427:             .frame(height: 600)
428:             .padding()
429:             .preferredColorScheme(.dark)
430:             .previewDisplayName("Dark Mode")
431:     }
432:     private struct AchievementsViewRepresentable: UIViewRepresentable {
433:         func makeUIView(context: Context) -> AchievementsView {
434:             let mockMedals = getMockMedals()
435:             return AchievementsView(medals: mockMedals)
436:         }
437:         func updateUIView(_ uiView: AchievementsView, context: Context) {}
438:     }
439: }
440: @available(iOS 17.0, *)
441: struct MedalStatsView_Previews: PreviewProvider {
442:     static var previews: some View {
443:         UIViewPreview {
444:             let view = MedalStatsView()
445:             view.configure(with: getMockMedals())
446:             return view
447:         }
448:         .frame(height: 200)
449:         .padding()
450:         .previewLayout(.sizeThatFits)
451:         .previewDisplayName("Medal Stats View")
452:     }
453: }
454: @available(iOS 17.0, *)
455: struct MedalsGridView_Previews: PreviewProvider {
456:     static var previews: some View {
457:         UIViewPreview {
458:             let view = MedalsGridView()
459:             view.configure(with: getMockMedals())
460:             return view
461:         }
462:         .frame(height: 400)
463:         .padding()
464:         .previewLayout(.sizeThatFits)
465:         .previewDisplayName("Medals Grid View")
466:     }
467: }
468: struct UIViewPreview<View: UIView>: UIViewRepresentable {
469:     let view: View
470:     init(_ builder: @escaping () -> View) {
471:         view = builder()
472:     }
473:     func makeUIView(context: Context) -> View {
474:         return view
475:     }
476:     func updateUIView(_ view: View, context: Context) {
477:         view.setContentHuggingPriority(.defaultHigh, for: .horizontal)
478:         view.setContentHuggingPriority(.defaultHigh, for: .vertical)
479:     }
480: }
481: #endif
</file>

<file path="MusicBlocks/Inicio y Profile/AvatarPickerViewController.swift">
  1: import UIKit
  2: protocol AvatarPickerViewControllerDelegate: AnyObject {
  3:     func avatarPicker(_ picker: AvatarPickerViewController, didSelect avatar: String)
  4: }
  5: class AvatarPickerViewController: UIViewController, UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {
  6:     private let collectionView: UICollectionView
  7:     private let availableAvatars: [String]
  8:     private var selectedAvatar: String
  9:     weak var delegate: AvatarPickerViewControllerDelegate?
 10:     init(selectedAvatar: String, availableAvatars: [String]) {
 11:         self.selectedAvatar = selectedAvatar
 12:         self.availableAvatars = availableAvatars
 13:         let layout = UICollectionViewFlowLayout()
 14:         layout.scrollDirection = .vertical
 15:         layout.minimumLineSpacing = 16
 16:         layout.minimumInteritemSpacing = 16
 17:         self.collectionView = UICollectionView(frame: .zero, collectionViewLayout: layout)
 18:         super.init(nibName: nil, bundle: nil)
 19:     }
 20:     required init?(coder: NSCoder) {
 21:         fatalError("init(coder:) has not been implemented")
 22:     }
 23:     override func viewDidLoad() {
 24:         super.viewDidLoad()
 25:         setupViews()
 26:     }
 27:     private func setupViews() {
 28:         title = "Elegir Avatar"
 29:         view.backgroundColor = .systemBackground
 30:         navigationItem.leftBarButtonItem = UIBarButtonItem(
 31:             title: "Cancelar",
 32:             style: .plain,
 33:             target: self,
 34:             action: #selector(handleCancel)
 35:         )
 36:         navigationItem.rightBarButtonItem = UIBarButtonItem(
 37:             title: "Guardar",
 38:             style: .done,
 39:             target: self,
 40:             action: #selector(handleSave)
 41:         )
 42:         collectionView.translatesAutoresizingMaskIntoConstraints = false
 43:         collectionView.backgroundColor = .systemBackground
 44:         collectionView.delegate = self
 45:         collectionView.dataSource = self
 46:         collectionView.register(AvatarCell.self, forCellWithReuseIdentifier: "AvatarCell")
 47:         collectionView.contentInset = UIEdgeInsets(top: 16, left: 16, bottom: 16, right: 16)
 48:         view.addSubview(collectionView)
 49:         NSLayoutConstraint.activate([
 50:             collectionView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
 51:             collectionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
 52:             collectionView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
 53:             collectionView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
 54:         ])
 55:     }
 56:     @objc private func handleCancel() {
 57:         dismiss(animated: true)
 58:     }
 59:     @objc private func handleSave() {
 60:         delegate?.avatarPicker(self, didSelect: selectedAvatar)
 61:     }
 62:     func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
 63:         return availableAvatars.count
 64:     }
 65:     func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
 66:         let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "AvatarCell", for: indexPath) as! AvatarCell
 67:         let avatar = availableAvatars[indexPath.item]
 68:         cell.configure(with: avatar, isSelected: avatar == selectedAvatar)
 69:         return cell
 70:     }
 71:     func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
 72:         selectedAvatar = availableAvatars[indexPath.item]
 73:         collectionView.reloadData()
 74:     }
 75:     func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
 76:         let availableWidth = collectionView.bounds.width - 48
 77:         let width = availableWidth / 3
 78:         let height = width * 1.4
 79:         return CGSize(width: width, height: height)
 80:     }
 81: }
 82: class AvatarCell: UICollectionViewCell {
 83:     private let containerView: UIView = {
 84:         let view = UIView()
 85:         view.backgroundColor = .systemBackground
 86:         view.layer.cornerRadius = 12
 87:         view.clipsToBounds = true
 88:         return view
 89:     }()
 90:     private let imageView: UIImageView = {
 91:         let imageView = UIImageView()
 92:         imageView.contentMode = .scaleAspectFit
 93:         imageView.clipsToBounds = true
 94:         return imageView
 95:     }()
 96:     private let nameLabel: UILabel = {
 97:         let label = UILabel()
 98:         label.font = .systemFont(ofSize: 12)
 99:         label.textColor = .secondaryLabel
100:         label.textAlignment = .center
101:         return label
102:     }()
103:     override init(frame: CGRect) {
104:         super.init(frame: frame)
105:         setupViews()
106:     }
107:     required init?(coder: NSCoder) {
108:         fatalError("init(coder:) has not been implemented")
109:     }
110:     private func setupViews() {
111:         contentView.addSubview(containerView)
112:         containerView.addSubview(imageView)
113:         containerView.addSubview(nameLabel)
114:         containerView.translatesAutoresizingMaskIntoConstraints = false
115:         imageView.translatesAutoresizingMaskIntoConstraints = false
116:         nameLabel.translatesAutoresizingMaskIntoConstraints = false
117:         NSLayoutConstraint.activate([
118:             containerView.topAnchor.constraint(equalTo: contentView.topAnchor),
119:             containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
120:             containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
121:             containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
122:             imageView.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 8),
123:             imageView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 8),
124:             imageView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -8),
125:             imageView.heightAnchor.constraint(equalTo: imageView.widthAnchor),
126:             nameLabel.topAnchor.constraint(equalTo: imageView.bottomAnchor, constant: 4),
127:             nameLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 4),
128:             nameLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -4),
129:             nameLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -8)
130:         ])
131:     }
132:     func configure(with avatar: String, isSelected: Bool) {
133:         imageView.image = UIImage(named: avatar)
134:         nameLabel.text = avatar
135:         containerView.layer.borderWidth = isSelected ? 3 : 0
136:         containerView.layer.borderColor = isSelected ? UIColor.systemRed.cgColor : nil
137:         containerView.backgroundColor = isSelected ? .systemRed.withAlphaComponent(0.1) : .systemBackground
138:     }
139:     override func prepareForReuse() {
140:         super.prepareForReuse()
141:         imageView.image = nil
142:         nameLabel.text = nil
143:         containerView.layer.borderWidth = 0
144:         containerView.layer.borderColor = nil
145:         containerView.backgroundColor = .systemBackground
146:     }
147: }
</file>

<file path="MusicBlocks/Inicio y Profile/ContentView.swift">
  1: import SwiftUI
  2: import AVFoundation
  3: import SpriteKit
  4: struct ContentView: View {
  5:     @StateObject private var audioController = AudioController.sharedInstance
  6:     @State private var gameVersion: String = "--"
  7:     @State private var navigateToGame = false
  8:     var body: some View {
  9:         NavigationStack {
 10:             VStack(spacing: 30) {
 11:                 Spacer()
 12:                 VStack(spacing: 15) {
 13:                     Image("logoMusicBlocks")
 14:                         .resizable()
 15:                         .scaledToFit()
 16:                         .frame(width: 320, height: 320)
 17:                 }
 18:                 .padding(.bottom, 20)
 19:                 VStack(spacing: 20) {
 20:                     Button(action: {
 21:                         startGameSequence()
 22:                     }) {
 23:                         HStack {
 24:                             Image(systemName: "gamecontroller")
 25:                             Text("Jugar")
 26:                                 .font(.headline)
 27:                         }
 28:                         .frame(maxWidth: .infinity)
 29:                         .padding()
 30:                         .background(
 31:                             RoundedRectangle(cornerRadius: 15)
 32:                                 .fill(Color.red)
 33:                         )
 34:                         .foregroundColor(.white)
 35:                     }
 36:                     Button(action: {
 37:                         audioController.playButtonSound()
 38:                         if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
 39:                            let window = windowScene.windows.first,
 40:                            let rootViewController = window.rootViewController {
 41:                             let profileVC = ProfileViewController()
 42:                             let navController = UINavigationController(rootViewController: profileVC)
 43:                             navController.modalPresentationStyle = .fullScreen
 44:                             rootViewController.present(navController, animated: true)
 45:                         }
 46:                     }) {
 47:                         HStack {
 48:                             Image(systemName: "person.fill")
 49:                             Text("Mi Perfil")
 50:                                 .font(.headline)
 51:                         }
 52:                         .frame(maxWidth: .infinity)
 53:                         .padding()
 54:                         .background(
 55:                             RoundedRectangle(cornerRadius: 15)
 56:                                 .fill(Color.red.opacity(0.8))
 57:                         )
 58:                         .foregroundColor(.white)
 59:                     }
 60:                 }
 61:                 .padding(.horizontal, 40)
 62:                 Spacer()
 63:                 Text(gameVersion)
 64:                     .font(.caption)
 65:                     .foregroundColor(.red)
 66:                     .padding(.bottom, 20)
 67:             }
 68:             .background(Color.white.ignoresSafeArea())
 69:             .navigationBarHidden(true)
 70:             .navigationDestination(isPresented: $navigateToGame) {
 71:                 MusicBlocksSceneView()
 72:             }
 73:         }
 74:         .onAppear {
 75:             setupAudio()
 76:             loadGameVersion()
 77:             audioController.startBackgroundMusic()
 78:         }
 79:         .onDisappear {
 80:             audioController.stop()
 81:         }
 82:     }
 83:     private func setupAudio() {
 84:         AVCaptureDevice.requestAccess(for: .audio) { granted in
 85:             if granted {
 86:                 DispatchQueue.main.async {
 87:                 }
 88:             }
 89:         }
 90:     }
 91:     private func loadGameVersion() {
 92:         if let gameConfig = GameLevelProcessor.loadGameLevelsFromFile() {
 93:             DispatchQueue.main.async {
 94:                 self.gameVersion = "v\(gameConfig.gameVersion)"
 95:             }
 96:         }
 97:     }
 98:     private func startGameSequence() {
 99:         audioController.playButtonSound()
100:         DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
101:             audioController.stopBackgroundMusic(duration: 0.3)
102:             DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
103:                 navigateToGame = true
104:             }
105:         }
106:     }
107: }
108: struct ContentView_Previews: PreviewProvider {
109:     static var previews: some View {
110:         ContentView()
111:     }
112: }
</file>

<file path="MusicBlocks/Inicio y Profile/ExpandableSectionView.swift">
  1: import UIKit
  2: protocol ExpandableSectionViewDelegate: AnyObject {
  3:     func expandableSectionDidToggle(_ section: ExpandableSectionView)
  4: }
  5: class ExpandableSectionView: UIView {
  6:     private let headerView: UIView = {
  7:         let view = UIView()
  8:         view.backgroundColor = .systemGray6
  9:         view.layer.cornerRadius = 10
 10:         return view
 11:     }()
 12:     private let iconImageView: UIImageView = {
 13:         let imageView = UIImageView()
 14:         imageView.contentMode = .scaleAspectFit
 15:         return imageView
 16:     }()
 17:     private let titleLabel: UILabel = {
 18:         let label = UILabel()
 19:         label.font = .systemFont(ofSize: 17, weight: .semibold)
 20:         return label
 21:     }()
 22:     private let chevronImageView: UIImageView = {
 23:         let config = UIImage.SymbolConfiguration(pointSize: 14)
 24:         let imageView = UIImageView()
 25:         imageView.image = UIImage(systemName: "chevron.down", withConfiguration: config)
 26:         imageView.tintColor = .secondaryLabel
 27:         imageView.contentMode = .scaleAspectFit
 28:         return imageView
 29:     }()
 30:     private var contentView: UIView?
 31:     private var isExpanded = false
 32:     weak var delegate: ExpandableSectionViewDelegate?
 33:     private var contentConstraints: [NSLayoutConstraint] = []
 34:     private var collapsedConstraint: NSLayoutConstraint?
 35:     init(title: String, icon: UIImage?, iconTintColor: UIColor = .systemBlue) {
 36:         super.init(frame: .zero)
 37:         titleLabel.text = title
 38:         iconImageView.image = icon
 39:         iconImageView.tintColor = iconTintColor
 40:         setupViews()
 41:     }
 42:     required init?(coder: NSCoder) {
 43:         fatalError("init(coder:) has not been implemented")
 44:     }
 45:     private func setupViews() {
 46:         [headerView, iconImageView, titleLabel, chevronImageView].forEach {
 47:             $0.translatesAutoresizingMaskIntoConstraints = false
 48:         }
 49:         addSubview(headerView)
 50:         headerView.addSubview(iconImageView)
 51:         headerView.addSubview(titleLabel)
 52:         headerView.addSubview(chevronImageView)
 53:         setupConstraints()
 54:         setupGesture()
 55:     }
 56:     private func setupConstraints() {
 57:         NSLayoutConstraint.activate([
 58:             headerView.topAnchor.constraint(equalTo: topAnchor),
 59:             headerView.leadingAnchor.constraint(equalTo: leadingAnchor),
 60:             headerView.trailingAnchor.constraint(equalTo: trailingAnchor),
 61:             iconImageView.leadingAnchor.constraint(equalTo: headerView.leadingAnchor, constant: 16),
 62:             iconImageView.centerYAnchor.constraint(equalTo: headerView.centerYAnchor),
 63:             iconImageView.widthAnchor.constraint(equalToConstant: 24),
 64:             iconImageView.heightAnchor.constraint(equalToConstant: 24),
 65:             titleLabel.leadingAnchor.constraint(equalTo: iconImageView.trailingAnchor, constant: 12),
 66:             titleLabel.centerYAnchor.constraint(equalTo: headerView.centerYAnchor),
 67:             chevronImageView.trailingAnchor.constraint(equalTo: headerView.trailingAnchor, constant: -16),
 68:             chevronImageView.centerYAnchor.constraint(equalTo: headerView.centerYAnchor),
 69:             chevronImageView.widthAnchor.constraint(equalToConstant: 12),
 70:             chevronImageView.heightAnchor.constraint(equalToConstant: 12),
 71:             headerView.heightAnchor.constraint(equalToConstant: 50)
 72:         ])
 73:         collapsedConstraint = bottomAnchor.constraint(equalTo: headerView.bottomAnchor)
 74:         collapsedConstraint?.isActive = true
 75:     }
 76:     private func setupGesture() {
 77:         let tapGesture = UITapGestureRecognizer(target: self, action: #selector(handleHeaderTap))
 78:         headerView.addGestureRecognizer(tapGesture)
 79:         headerView.isUserInteractionEnabled = true
 80:     }
 81:     func setContentView(_ view: UIView) {
 82:         contentView?.removeFromSuperview()
 83:         NSLayoutConstraint.deactivate(contentConstraints)
 84:         contentConstraints.removeAll()
 85:         contentView = view
 86:         if let contentView = contentView {
 87:             contentView.translatesAutoresizingMaskIntoConstraints = false
 88:             addSubview(contentView)
 89:             let topConstraint = contentView.topAnchor.constraint(equalTo: headerView.bottomAnchor, constant: 8)
 90:             let leadingConstraint = contentView.leadingAnchor.constraint(equalTo: leadingAnchor)
 91:             let trailingConstraint = contentView.trailingAnchor.constraint(equalTo: trailingAnchor)
 92:             let bottomConstraint = contentView.bottomAnchor.constraint(equalTo: bottomAnchor)
 93:             contentConstraints = [topConstraint, leadingConstraint, trailingConstraint, bottomConstraint]
 94:             if isExpanded {
 95:                 NSLayoutConstraint.activate(contentConstraints)
 96:                 collapsedConstraint?.isActive = false
 97:                 contentView.isHidden = false
 98:                 contentView.alpha = 1
 99:             } else {
100:                 contentView.isHidden = true
101:                 contentView.alpha = 0
102:             }
103:         }
104:     }
105:     @objc private func handleHeaderTap() {
106:         toggleSection()
107:     }
108:     private func toggleSection() {
109:         isExpanded.toggle()
110:         UIView.animate(withDuration: 0.3) {
111:             self.chevronImageView.transform = self.isExpanded ?
112:                 CGAffineTransform(rotationAngle: .pi) :
113:                 .identity
114:             if self.isExpanded {
115:                 self.collapsedConstraint?.isActive = false
116:                 NSLayoutConstraint.activate(self.contentConstraints)
117:                 self.contentView?.isHidden = false
118:                 self.contentView?.alpha = 1
119:             } else {
120:                 NSLayoutConstraint.deactivate(self.contentConstraints)
121:                 self.collapsedConstraint?.isActive = true
122:                 self.contentView?.isHidden = true
123:                 self.contentView?.alpha = 0
124:             }
125:             self.superview?.layoutIfNeeded()
126:         }
127:         delegate?.expandableSectionDidToggle(self)
128:     }
129:     override func layoutSubviews() {
130:         super.layoutSubviews()
131:         headerView.layer.shadowColor = UIColor.black.cgColor
132:         headerView.layer.shadowOffset = CGSize(width: 0, height: 2)
133:         headerView.layer.shadowRadius = 4
134:         headerView.layer.shadowOpacity = 0.1
135:         headerView.layer.masksToBounds = false
136:     }
137: }
</file>

<file path="MusicBlocks/Inicio y Profile/MusicBlocksApp.swift">
1: import SwiftUI
2: @main
3: struct MusicBlocksApp: App {
4:     var body: some Scene {
5:         WindowGroup {
6:             ContentView()
7:         }
8:     }
9: }
</file>

<file path="MusicBlocks/Inicio y Profile/ProfileHeaderView.swift">
  1: import UIKit
  2: protocol ProfileHeaderViewDelegate: AnyObject {
  3:     func profileHeaderView(_ view: ProfileHeaderView, didUpdateUsername username: String)
  4:     func profileHeaderViewDidTapAvatar(_ view: ProfileHeaderView)
  5: }
  6: class ProfileHeaderView: UIView {
  7:     private let avatarImageView: UIImageView = {
  8:         let imageView = UIImageView()
  9:         imageView.contentMode = .scaleAspectFit
 10:         imageView.layer.cornerRadius = 12
 11:         imageView.clipsToBounds = true
 12:         imageView.layer.borderWidth = 2
 13:         imageView.layer.borderColor = UIColor.systemRed.cgColor
 14:         return imageView
 15:     }()
 16:     private let editAvatarButton: UIButton = {
 17:         let button = UIButton()
 18:         let config = UIImage.SymbolConfiguration(pointSize: 30)
 19:         button.setImage(UIImage(systemName: "pencil.circle.fill", withConfiguration: config), for: .normal)
 20:         button.tintColor = .systemRed
 21:         button.backgroundColor = .white
 22:         button.layer.cornerRadius = 15
 23:         return button
 24:     }()
 25:     private let usernameLabel: UILabel = {
 26:             let label = UILabel()
 27:             label.font = .systemFont(ofSize: 20, weight: .medium)
 28:             label.textAlignment = .center
 29:             label.isUserInteractionEnabled = true
 30:             return label
 31:         }()
 32:     private func setupGestures() {
 33:         let tapGesture = UITapGestureRecognizer(target: self, action: #selector(usernameTapped))
 34:         usernameLabel.addGestureRecognizer(tapGesture)
 35:     }
 36:     @objc private func usernameTapped() {
 37:         handleUsernameTap()
 38:     }
 39:     private let editUsernameButton: UIButton = {
 40:         let button = UIButton()
 41:         let config = UIImage.SymbolConfiguration(pointSize: 14)
 42:         button.setImage(UIImage(systemName: "pencil", withConfiguration: config), for: .normal)
 43:         button.tintColor = .systemRed
 44:         return button
 45:     }()
 46:     weak var delegate: ProfileHeaderViewDelegate?
 47:     override init(frame: CGRect) {
 48:         super.init(frame: frame)
 49:         setupViews()
 50:         setupGestures()
 51:     }
 52:     required init?(coder: NSCoder) {
 53:         fatalError("init(coder:) has not been implemented")
 54:     }
 55:     private func setupViews() {
 56:         [avatarImageView, editAvatarButton, usernameLabel, editUsernameButton].forEach {
 57:             $0.translatesAutoresizingMaskIntoConstraints = false
 58:             addSubview($0)
 59:         }
 60:         setupConstraints()
 61:         setupActions()
 62:     }
 63:     private func setupConstraints() {
 64:         NSLayoutConstraint.activate([
 65:             avatarImageView.topAnchor.constraint(equalTo: topAnchor, constant: 20),
 66:             avatarImageView.centerXAnchor.constraint(equalTo: centerXAnchor),
 67:             avatarImageView.widthAnchor.constraint(equalToConstant: 120),
 68:             avatarImageView.heightAnchor.constraint(equalToConstant: 160),
 69:             editAvatarButton.trailingAnchor.constraint(equalTo: avatarImageView.trailingAnchor, constant: 5),
 70:             editAvatarButton.bottomAnchor.constraint(equalTo: avatarImageView.bottomAnchor, constant: 5),
 71:             editAvatarButton.widthAnchor.constraint(equalToConstant: 30),
 72:             editAvatarButton.heightAnchor.constraint(equalToConstant: 30),
 73:             usernameLabel.topAnchor.constraint(equalTo: avatarImageView.bottomAnchor, constant: 15),
 74:             usernameLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
 75:             usernameLabel.bottomAnchor.constraint(equalTo: bottomAnchor),
 76:             editUsernameButton.leadingAnchor.constraint(equalTo: usernameLabel.trailingAnchor, constant: 5),
 77:             editUsernameButton.centerYAnchor.constraint(equalTo: usernameLabel.centerYAnchor)
 78:         ])
 79:     }
 80:     private func setupActions() {
 81:         editAvatarButton.addTarget(self, action: #selector(handleAvatarTap), for: .touchUpInside)
 82:         editUsernameButton.addTarget(self, action: #selector(handleUsernameTap), for: .touchUpInside)
 83:     }
 84:     func configure(with profile: UserProfile) {
 85:         usernameLabel.text = profile.username
 86:         if profile.avatarName.isEmpty {
 87:             avatarImageView.image = UIImage(systemName: "person.circle.fill")
 88:             avatarImageView.tintColor = .systemRed
 89:         } else {
 90:             avatarImageView.image = UIImage(named: profile.avatarName)
 91:         }
 92:     }
 93:     @objc private func handleAvatarTap() {
 94:         delegate?.profileHeaderViewDidTapAvatar(self)
 95:     }
 96:     @objc private func handleUsernameTap() {
 97:         showEditUsernameAlert()
 98:     }
 99:     private func showEditUsernameAlert() {
100:         let alert = UIAlertController(
101:             title: "Editar nombre",
102:             message: "Introduce tu nuevo nombre de usuario",
103:             preferredStyle: .alert
104:         )
105:         alert.addTextField { textField in
106:             textField.text = self.usernameLabel.text
107:             textField.clearButtonMode = .whileEditing
108:         }
109:         alert.addAction(UIAlertAction(title: "Cancelar", style: .cancel))
110:         alert.addAction(UIAlertAction(title: "Guardar", style: .default) { [weak self] _ in
111:             guard let self = self,
112:                   let textField = alert.textFields?.first,
113:                   let newUsername = textField.text?.trimmingCharacters(in: .whitespacesAndNewlines),
114:                   !newUsername.isEmpty else { return }
115:             self.usernameLabel.text = newUsername
116:             self.delegate?.profileHeaderView(self, didUpdateUsername: newUsername)
117:         })
118:         if let viewController = self.findViewController() {
119:             viewController.present(alert, animated: true)
120:         } else {
121:             if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
122:                let window = windowScene.windows.first,
123:                let rootViewController = window.rootViewController {
124:                 var topViewController = rootViewController
125:                 while let presentedViewController = topViewController.presentedViewController {
126:                     topViewController = presentedViewController
127:                 }
128:                 topViewController.present(alert, animated: true)
129:             }
130:         }
131:     }
132:     private func findViewController() -> UIViewController? {
133:         var responder: UIResponder? = self
134:         while let nextResponder = responder?.next {
135:             responder = nextResponder
136:             if let viewController = responder as? UIViewController {
137:                 return viewController
138:             }
139:         }
140:         return nil
141:     }
142: }
143: #if DEBUG
144: import SwiftUI
145: @available(iOS 17.0, *)
146: struct ProfileHeaderView_Previews: PreviewProvider {
147:     static var previews: some View {
148:         ProfileHeaderViewRepresentable()
149:             .frame(height: 250)
150:             .padding()
151:             .previewDisplayName("Light Mode")
152:         ProfileHeaderViewRepresentable()
153:             .frame(height: 250)
154:             .padding()
155:             .preferredColorScheme(.dark)
156:             .previewDisplayName("Dark Mode")
157:     }
158:     private struct ProfileHeaderViewRepresentable: UIViewRepresentable {
159:         func makeUIView(context: Context) -> ProfileHeaderView {
160:             let view = ProfileHeaderView()
161:             view.configure(with: UserProfile.mock)
162:             return view
163:         }
164:         func updateUIView(_ uiView: ProfileHeaderView, context: Context) {}
165:     }
166: }
167: extension UserProfile {
168:     static var mock: UserProfile {
169:         UserProfile(
170:             username: "Usuario de Prueba",
171:             avatarName: "avatar1",
172:             statistics: Statistics(
173:                 totalScore: 1000,
174:                 currentLevel: 5,
175:                 playTime: 3600,
176:                 notesHit: 100,
177:                 currentStreak: 5,
178:                 bestStreak: 10,
179:                 perfectLevelsCount: 2,
180:                 totalGamesPlayed: 15,
181:                 averageAccuracy: 0.85
182:             ),
183:             achievements: Achievements(
184:                 unlockedMedals: [:],
185:                 lastUpdateDate: Date()
186:             )
187:         )
188:     }
189: }
190: #endif
</file>

<file path="MusicBlocks/Inicio y Profile/ProfileViewController.swift">
  1: import UIKit
  2: import SpriteKit
  3: class ProfileViewController: UIViewController {
  4:     private var profile = UserProfile.load()
  5:     private let medalManager = MedalManager.shared
  6:     private var scrollView: UIScrollView!
  7:     private var contentView: UIView!
  8:     private var profileHeaderView: ProfileHeaderView!
  9:     private var statsSection: ExpandableSectionView!
 10:     private var achievementsSection: ExpandableSectionView!
 11:     override func viewDidLoad() {
 12:         super.viewDidLoad()
 13:         setupNavigationBar()
 14:         setupViews()
 15:         loadProfile()
 16:     }
 17:     private func setupNavigationBar() {
 18:         title = "Perfil"
 19:         navigationController?.navigationBar.prefersLargeTitles = false
 20:         view.backgroundColor = .systemBackground
 21:         let menuButton = UIBarButtonItem(
 22:             image: UIImage(systemName: "house.fill"),
 23:             style: .plain,
 24:             target: self,
 25:             action: #selector(returnToMainMenu)
 26:         )
 27:         menuButton.tintColor = .systemRed
 28:         navigationItem.leftBarButtonItem = menuButton
 29:     }
 30:     @objc private func returnToMainMenu() {
 31:         dismiss(animated: true)
 32:     }
 33:     private func setupViews() {
 34:         scrollView = UIScrollView()
 35:         scrollView.translatesAutoresizingMaskIntoConstraints = false
 36:         scrollView.backgroundColor = .systemBackground
 37:         view.addSubview(scrollView)
 38:         contentView = UIView()
 39:         contentView.translatesAutoresizingMaskIntoConstraints = false
 40:         contentView.backgroundColor = .systemBackground
 41:         scrollView.addSubview(contentView)
 42:         profileHeaderView = ProfileHeaderView()
 43:         profileHeaderView.translatesAutoresizingMaskIntoConstraints = false
 44:         profileHeaderView.delegate = self
 45:         contentView.addSubview(profileHeaderView)
 46:         statsSection = ExpandableSectionView(
 47:             title: "Estadísticas",
 48:             icon: UIImage(systemName: "chart.bar.fill"),
 49:             iconTintColor: .systemRed
 50:         )
 51:         statsSection.translatesAutoresizingMaskIntoConstraints = false
 52:         statsSection.delegate = self
 53:         contentView.addSubview(statsSection)
 54:         achievementsSection = ExpandableSectionView(
 55:             title: "Logros",
 56:             icon: UIImage(systemName: "trophy.fill"),
 57:             iconTintColor: .systemYellow
 58:         )
 59:         achievementsSection.translatesAutoresizingMaskIntoConstraints = false
 60:         achievementsSection.delegate = self
 61:         contentView.addSubview(achievementsSection)
 62:         setupConstraints()
 63:     }
 64:     private func setupConstraints() {
 65:         NSLayoutConstraint.activate([
 66:             scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
 67:             scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
 68:             scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
 69:             scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
 70:             contentView.topAnchor.constraint(equalTo: scrollView.topAnchor),
 71:             contentView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor),
 72:             contentView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor),
 73:             contentView.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
 74:             contentView.widthAnchor.constraint(equalTo: scrollView.widthAnchor),
 75:             profileHeaderView.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 20),
 76:             profileHeaderView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20),
 77:             profileHeaderView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20),
 78:             statsSection.topAnchor.constraint(equalTo: profileHeaderView.bottomAnchor, constant: 20),
 79:             statsSection.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20),
 80:             statsSection.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20),
 81:             achievementsSection.topAnchor.constraint(equalTo: statsSection.bottomAnchor, constant: 8),
 82:             achievementsSection.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20),
 83:             achievementsSection.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20),
 84:             achievementsSection.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -20)
 85:         ])
 86:     }
 87:     private func loadProfile() {
 88:         profileHeaderView.configure(with: profile)
 89:         updateStats()
 90:         updateAchievements()
 91:     }
 92:     private func updateStats() {
 93:         let statsView = StatsView(statistics: profile.statistics)
 94:         statsView.delegate = self
 95:         statsSection.setContentView(statsView)
 96:     }
 97:     private func updateAchievements() {
 98:         let achievementsView = AchievementsView(medals: medalManager.getMedals())
 99:         achievementsSection.setContentView(achievementsView)
100:     }
101:     private func showEditUsernameAlert(currentUsername: String) {
102:         DispatchQueue.main.async {
103:             let alertController = UIAlertController(
104:                 title: "Editar Nombre",
105:                 message: "Introduce tu nuevo nombre de usuario",
106:                 preferredStyle: .alert
107:             )
108:             alertController.addTextField { textField in
109:                 textField.text = currentUsername
110:                 textField.placeholder = "Nombre de usuario"
111:                 textField.autocapitalizationType = .words
112:             }
113:             let saveAction = UIAlertAction(title: "Guardar", style: .default) { [weak self] _ in
114:                 guard let self = self,
115:                       let textField = alertController.textFields?.first,
116:                       let newUsername = textField.text?.trimmingCharacters(in: .whitespacesAndNewlines),
117:                       !newUsername.isEmpty else {
118:                     return
119:                 }
120:                 self.profile.username = newUsername
121:                 self.profile.save()
122:                 self.profileHeaderView.configure(with: self.profile)
123:             }
124:             let cancelAction = UIAlertAction(title: "Cancelar", style: .cancel)
125:             alertController.addAction(saveAction)
126:             alertController.addAction(cancelAction)
127:             if let presentingController = self.presentingViewController {
128:                 presentingController.present(alertController, animated: true)
129:             } else {
130:                 self.present(alertController, animated: true)
131:             }
132:         }
133:     }
134:     private func getTopViewController() -> UIViewController? {
135:         guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
136:               let keyWindow = windowScene.windows.first(where: { $0.isKeyWindow }) else {
137:             return nil
138:         }
139:         var topController = keyWindow.rootViewController
140:         while let presentedController = topController?.presentedViewController {
141:             topController = presentedController
142:         }
143:         return topController
144:     }
145: }
146: extension ProfileViewController: ProfileHeaderViewDelegate {
147:     func profileHeaderView(_ view: ProfileHeaderView, didUpdateUsername username: String) {
148:         profile.username = username
149:         profile.save()
150:     }
151:     func profileHeaderViewDidTapAvatar(_ view: ProfileHeaderView) {
152:         let avatarPicker = AvatarPickerViewController(
153:             selectedAvatar: profile.avatarName,
154:             availableAvatars: ["avatar1", "avatar2", "avatar3", "avatar4", "avatar5", "avatar6", "avatar7", "avatar8", "avatar9", "avatar10", "avatar11", "avatar12", "avatar13", "avatar14"]
155:         )
156:         avatarPicker.delegate = self
157:         let nav = UINavigationController(rootViewController: avatarPicker)
158:         present(nav, animated: true)
159:     }
160: }
161: extension ProfileViewController: AvatarPickerViewControllerDelegate {
162:     func avatarPicker(_ picker: AvatarPickerViewController, didSelect avatar: String) {
163:         profile.avatarName = avatar
164:         profile.save()
165:         profileHeaderView.configure(with: profile)
166:         dismiss(animated: true)
167:     }
168: }
169: extension ProfileViewController: ExpandableSectionViewDelegate {
170:     func expandableSectionDidToggle(_ section: ExpandableSectionView) {
171:         UIView.animate(withDuration: 0.3) {
172:             self.view.layoutIfNeeded()
173:         }
174:     }
175: }
176: extension ProfileViewController: StatsViewDelegate {
177:     func statsViewDidTapResetButton(_ statsView: StatsView) {
178:         let alert = UIAlertController(
179:             title: "Borrar datos",
180:             message: "¿Estás seguro de que deseas borrar todas tus estadísticas? Esta acción no se puede deshacer.",
181:             preferredStyle: .alert
182:         )
183:         let resetAction = UIAlertAction(title: "Borrar", style: .destructive) { [weak self] _ in
184:             guard let self = self else { return }
185:             self.profile.statistics = Statistics()
186:             self.profile.save()
187:             self.updateStats()
188:             self.showToast(message: "Estadísticas restablecidas")
189:         }
190:         let cancelAction = UIAlertAction(title: "Cancelar", style: .cancel)
191:         alert.addAction(resetAction)
192:         alert.addAction(cancelAction)
193:         present(alert, animated: true)
194:     }
195:     private func showToast(message: String) {
196:         let toastLabel = UILabel()
197:         toastLabel.backgroundColor = UIColor.black.withAlphaComponent(0.7)
198:         toastLabel.textColor = .white
199:         toastLabel.textAlignment = .center
200:         toastLabel.font = UIFont.systemFont(ofSize: 14)
201:         toastLabel.text = message
202:         toastLabel.alpha = 0
203:         toastLabel.layer.cornerRadius = 10
204:         toastLabel.clipsToBounds = true
205:         view.addSubview(toastLabel)
206:         toastLabel.translatesAutoresizingMaskIntoConstraints = false
207:         NSLayoutConstraint.activate([
208:             toastLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),
209:             toastLabel.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -20),
210:             toastLabel.widthAnchor.constraint(lessThanOrEqualTo: view.widthAnchor, multiplier: 0.7),
211:             toastLabel.heightAnchor.constraint(equalToConstant: 40)
212:         ])
213:         UIView.animate(withDuration: 0.5, animations: {
214:             toastLabel.alpha = 1
215:         }, completion: { _ in
216:             UIView.animate(withDuration: 0.5, delay: 1.5, options: .curveEaseOut, animations: {
217:                 toastLabel.alpha = 0
218:             }, completion: { _ in
219:                 toastLabel.removeFromSuperview()
220:             })
221:         })
222:     }
223: }
224: #if DEBUG
225: import SwiftUI
226: struct ProfileViewControllerPreview: UIViewControllerRepresentable {
227:     func makeUIViewController(context: Context) -> ProfileViewController {
228:         let profile = UserProfile(
229:             username: "Jugador de Prueba",
230:             avatarName: "avatar1",
231:             statistics: Statistics(
232:                 totalScore: 2500,
233:                 currentLevel: 7,
234:                 playTime: 7200,
235:                 notesHit: 450,
236:                 currentStreak: 15,
237:                 bestStreak: 25,
238:                 perfectLevelsCount: 5,
239:                 totalGamesPlayed: 35,
240:                 averageAccuracy: 0.88
241:             ),
242:             achievements: Achievements(
243:                 unlockedMedals: [
244:                     MedalType.notesHit.rawValue: [true, true, false],
245:                     MedalType.playTime.rawValue: [true, true, false],
246:                     MedalType.streaks.rawValue: [true, true, true],
247:                     MedalType.perfectTuning.rawValue: [true, true, false]
248:                 ],
249:                 lastUpdateDate: Date()
250:             )
251:         )
252:         profile.save()
253:         let profileVC = ProfileViewController()
254:         return profileVC
255:     }
256:     func updateUIViewController(_ uiViewController: ProfileViewController, context: Context) {
257:     }
258: }
259: struct ProfileViewController_Preview: PreviewProvider {
260:     static var previews: some View {
261:         Group {
262:             ProfileViewControllerPreview()
263:                 .edgesIgnoringSafeArea(.all)
264:                 .preferredColorScheme(.light)
265:                 .previewDisplayName("Perfil - Modo Claro")
266:             ProfileViewControllerPreview()
267:                 .edgesIgnoringSafeArea(.all)
268:                 .preferredColorScheme(.dark)
269:                 .previewDisplayName("Perfil - Modo Oscuro")
270:         }
271:     }
272: }
273: #endif
</file>

<file path="MusicBlocks/Inicio y Profile/StatsView.swift">
  1: import UIKit
  2: protocol StatsViewDelegate: AnyObject {
  3:     func statsViewDidTapResetButton(_ statsView: StatsView)
  4: }
  5: class StatsView: UIView {
  6:     weak var delegate: StatsViewDelegate?
  7:     private let stackView: UIStackView = {
  8:         let stack = UIStackView()
  9:         stack.axis = .vertical
 10:         stack.spacing = 12
 11:         stack.distribution = .fill
 12:         return stack
 13:     }()
 14:     private let resetButton: UIButton = {
 15:         var configuration = UIButton.Configuration.plain()
 16:         configuration.image = UIImage(systemName: "trash")
 17:         configuration.title = "Borrar datos"
 18:         configuration.imagePadding = 5
 19:         configuration.baseForegroundColor = .systemRed
 20:         configuration.contentInsets = NSDirectionalEdgeInsets(top: 5, leading: 10, bottom: 5, trailing: 10)
 21:         let button = UIButton(configuration: configuration)
 22:         button.layer.borderColor = UIColor.systemRed.cgColor
 23:         button.layer.borderWidth = 1
 24:         button.layer.cornerRadius = 8
 25:         return button
 26:     }()
 27:     init(statistics: Statistics) {
 28:         super.init(frame: .zero)
 29:         setupViews()
 30:         configure(with: statistics)
 31:         setupActions()
 32:     }
 33:     required init?(coder: NSCoder) {
 34:         fatalError("init(coder:) has not been implemented")
 35:     }
 36:     private func setupViews() {
 37:         stackView.translatesAutoresizingMaskIntoConstraints = false
 38:         resetButton.translatesAutoresizingMaskIntoConstraints = false
 39:         addSubview(stackView)
 40:         addSubview(resetButton)
 41:         NSLayoutConstraint.activate([
 42:             stackView.topAnchor.constraint(equalTo: topAnchor, constant: 8),
 43:             stackView.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
 44:             stackView.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
 45:             resetButton.topAnchor.constraint(equalTo: stackView.bottomAnchor, constant: 16),
 46:             resetButton.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
 47:             resetButton.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -8)
 48:         ])
 49:     }
 50:     private func setupActions() {
 51:             resetButton.addTarget(self, action: #selector(resetButtonTapped), for: .touchUpInside)
 52:         }
 53:     @objc private func resetButtonTapped() {
 54:         print("Botón de reset tocado")
 55:         delegate?.statsViewDidTapResetButton(self)
 56:     }
 57:     private func configure(with statistics: Statistics) {
 58:             stackView.arrangedSubviews.forEach { $0.removeFromSuperview() }
 59:             addSectionHeader("Puntuación")
 60:             addStatRow(title: "Puntuación Total", value: statistics.formattedTotalScore)
 61:             addStatRow(title: "Nivel Actual", value: "\(statistics.currentLevel)")
 62:             addSectionHeader("Partidas")
 63:             addStatRow(title: "Total Jugadas", value: "\(statistics.totalGamesPlayed)")
 64:             addStatRow(title: "Ganadas", value: "\(statistics.gamesWon)")
 65:             addStatRow(title: "Perdidas", value: "\(statistics.gamesLost)")
 66:             let winRate = statistics.totalGamesPlayed > 0 ?
 67:                 Double(statistics.gamesWon) / Double(statistics.totalGamesPlayed) * 100 : 0
 68:             addStatRow(title: "Ratio Victoria", value: String(format: "%.1f%%", winRate))
 69:             addSectionHeader("Rendimiento")
 70:             addStatRow(title: "Notas Acertadas", value: "\(statistics.notesHit)")
 71:             addStatRow(title: "Mejor Racha", value: "\(statistics.bestStreak)")
 72:             addStatRow(title: "Precisión Media", value: statistics.formattedAccuracy)
 73:             addStatRow(title: "Niveles Perfectos", value: "\(statistics.perfectLevelsCount)")
 74:             addSectionHeader("Tiempo")
 75:             addStatRow(title: "Tiempo Total", value: statistics.formattedPlayTime)
 76:         }
 77:     private func addSectionHeader(_ title: String) {
 78:             let headerView = SectionHeaderView(title: title)
 79:             stackView.addArrangedSubview(headerView)
 80:             let spacer = UIView()
 81:             spacer.heightAnchor.constraint(equalToConstant: 8).isActive = true
 82:             stackView.addArrangedSubview(spacer)
 83:         }
 84:     private func addStatRow(title: String, value: String) {
 85:         let row = StatRowView(title: title, value: value)
 86:         stackView.addArrangedSubview(row)
 87:     }
 88: }
 89: class StatRowView: UIView {
 90:     private let titleLabel: UILabel = {
 91:         let label = UILabel()
 92:         label.font = .systemFont(ofSize: 15)
 93:         label.textColor = .secondaryLabel
 94:         return label
 95:     }()
 96:     private let valueLabel: UILabel = {
 97:         let label = UILabel()
 98:         label.font = .systemFont(ofSize: 15, weight: .medium)
 99:         label.textColor = .label
100:         return label
101:     }()
102:     init(title: String, value: String) {
103:         super.init(frame: .zero)
104:         titleLabel.text = title
105:         valueLabel.text = value
106:         setupViews()
107:     }
108:     required init?(coder: NSCoder) {
109:         fatalError("init(coder:) has not been implemented")
110:     }
111:     private func setupViews() {
112:         [titleLabel, valueLabel].forEach {
113:             $0.translatesAutoresizingMaskIntoConstraints = false
114:             addSubview($0)
115:         }
116:         NSLayoutConstraint.activate([
117:             titleLabel.leadingAnchor.constraint(equalTo: leadingAnchor),
118:             titleLabel.centerYAnchor.constraint(equalTo: centerYAnchor),
119:             valueLabel.trailingAnchor.constraint(equalTo: trailingAnchor),
120:             valueLabel.centerYAnchor.constraint(equalTo: centerYAnchor),
121:             heightAnchor.constraint(equalToConstant: 30)
122:         ])
123:     }
124: }
125: class SectionHeaderView: UIView {
126:     private let titleLabel: UILabel = {
127:         let label = UILabel()
128:         label.font = .systemFont(ofSize: 17, weight: .bold)
129:         label.textColor = .systemPurple
130:         return label
131:     }()
132:     private let separatorLine: UIView = {
133:         let view = UIView()
134:         view.backgroundColor = .systemPurple.withAlphaComponent(0.3)
135:         return view
136:     }()
137:     init(title: String) {
138:         super.init(frame: .zero)
139:         titleLabel.text = title
140:         setupViews()
141:     }
142:     required init?(coder: NSCoder) {
143:         fatalError("init(coder:) has not been implemented")
144:     }
145:     private func setupViews() {
146:         [titleLabel, separatorLine].forEach {
147:             $0.translatesAutoresizingMaskIntoConstraints = false
148:             addSubview($0)
149:         }
150:         NSLayoutConstraint.activate([
151:             titleLabel.topAnchor.constraint(equalTo: topAnchor),
152:             titleLabel.leadingAnchor.constraint(equalTo: leadingAnchor),
153:             separatorLine.leadingAnchor.constraint(equalTo: leadingAnchor),
154:             separatorLine.trailingAnchor.constraint(equalTo: trailingAnchor),
155:             separatorLine.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 4),
156:             separatorLine.bottomAnchor.constraint(equalTo: bottomAnchor),
157:             separatorLine.heightAnchor.constraint(equalToConstant: 1)
158:         ])
159:     }
160: }
161: #if DEBUG
162: import SwiftUI
163: @available(iOS 17.0, *)
164: struct StatsView_Previews: PreviewProvider {
165:     static var previews: some View {
166:         StatsViewRepresentable()
167:             .padding()
168:             .previewDisplayName("Light Mode")
169:         StatsViewRepresentable()
170:             .padding()
171:             .preferredColorScheme(.dark)
172:             .previewDisplayName("Dark Mode")
173:     }
174:     private struct StatsViewRepresentable: UIViewRepresentable {
175:         func makeUIView(context: Context) -> StatsView {
176:             let mockStats = Statistics(
177:                 totalScore: 1500,
178:                 currentLevel: 5,
179:                 playTime: 3600,
180:                 notesHit: 250,
181:                 currentStreak: 10,
182:                 bestStreak: 15,
183:                 perfectLevelsCount: 3,
184:                 totalGamesPlayed: 20,
185:                 averageAccuracy: 0.83,
186:                 gamesWon: 12,
187:                 gamesLost: 8
188:             )
189:             return StatsView(statistics: mockStats)
190:         }
191:         func updateUIView(_ uiView: StatsView, context: Context) {}
192:     }
193: }
194: #endif
</file>

<file path="MusicBlocks/Inicio y Profile/UserProfile.swift">
  1: import Foundation
  2: struct UserProfile: Codable {
  3:     var username: String
  4:     var avatarName: String
  5:     var statistics: Statistics
  6:     var achievements: Achievements
  7:     static let defaultUsername = "Pequeño músico"
  8:     static let defaultAvatarName = "avatar1"
  9:     init(username: String = defaultUsername,
 10:          avatarName: String = defaultAvatarName,
 11:          statistics: Statistics = Statistics(),
 12:          achievements: Achievements = Achievements()) {
 13:         self.username = username
 14:         self.avatarName = avatarName
 15:         self.statistics = statistics
 16:         self.achievements = achievements
 17:     }
 18:     static func load() -> UserProfile {
 19:         if let data = UserDefaults.standard.data(forKey: "userProfile"),
 20:            let profile = try? JSONDecoder().decode(UserProfile.self, from: data) {
 21:             return profile
 22:         }
 23:         return UserProfile()
 24:     }
 25:     func save() {
 26:         if let encoded = try? JSONEncoder().encode(self) {
 27:             UserDefaults.standard.set(encoded, forKey: "userProfile")
 28:         }
 29:     }
 30: }
 31: struct Statistics: Codable {
 32:     var totalScore: Int
 33:     var currentLevel: Int
 34:     var playTime: TimeInterval
 35:     var notesHit: Int
 36:     var currentStreak: Int
 37:     var bestStreak: Int
 38:     var perfectLevelsCount: Int
 39:     var totalGamesPlayed: Int
 40:     var averageAccuracy: Double
 41:     var gamesWon: Int
 42:     var gamesLost: Int
 43:     init(totalScore: Int = 0,
 44:          currentLevel: Int = 0,
 45:          playTime: TimeInterval = 0,
 46:          notesHit: Int = 0,
 47:          currentStreak: Int = 0,
 48:          bestStreak: Int = 0,
 49:          perfectLevelsCount: Int = 0,
 50:          totalGamesPlayed: Int = 0,
 51:          averageAccuracy: Double = 0.0,
 52:          gamesWon: Int = 0,
 53:          gamesLost: Int = 0) {
 54:         self.totalScore = totalScore
 55:         self.currentLevel = currentLevel
 56:         self.playTime = playTime
 57:         self.notesHit = notesHit
 58:         self.currentStreak = currentStreak
 59:         self.bestStreak = bestStreak
 60:         self.perfectLevelsCount = perfectLevelsCount
 61:         self.totalGamesPlayed = totalGamesPlayed
 62:         self.averageAccuracy = averageAccuracy
 63:         self.gamesWon = gamesWon
 64:         self.gamesLost = gamesLost
 65:     }
 66:     mutating func updateAccuracy(with newAccuracy: Double) {
 67:         if totalGamesPlayed == 0 {
 68:             averageAccuracy = newAccuracy
 69:         } else {
 70:             let totalAccuracy = averageAccuracy * Double(totalGamesPlayed)
 71:             averageAccuracy = (totalAccuracy + newAccuracy) / Double(totalGamesPlayed + 1)
 72:         }
 73:         totalGamesPlayed += 1
 74:     }
 75:     mutating func updateStreak(hitNote: Bool) {
 76:         if hitNote {
 77:             currentStreak += 1
 78:             if currentStreak > bestStreak {
 79:                 bestStreak = currentStreak
 80:             }
 81:         } else {
 82:             currentStreak = 0
 83:         }
 84:     }
 85:     mutating func addPlayTime(_ time: TimeInterval) {
 86:         playTime += time
 87:     }
 88: }
 89: struct Achievements: Codable {
 90:     var unlockedMedals: [String: [Bool]]
 91:     var lastUpdateDate: Date
 92:     init(unlockedMedals: [String: [Bool]] = [:], lastUpdateDate: Date = Date()) {
 93:         self.unlockedMedals = unlockedMedals
 94:         self.lastUpdateDate = lastUpdateDate
 95:     }
 96:     mutating func updateMedal(type: MedalType, index: Int, isUnlocked: Bool) {
 97:         if unlockedMedals[type.rawValue] == nil {
 98:             unlockedMedals[type.rawValue] = Array(repeating: false, count: 5)
 99:         }
100:         unlockedMedals[type.rawValue]?[index] = isUnlocked
101:         lastUpdateDate = Date()
102:     }
103:     func isMedalUnlocked(type: MedalType, index: Int) -> Bool {
104:         return unlockedMedals[type.rawValue]?[index] ?? false
105:     }
106: }
107: extension Statistics {
108:     var formattedPlayTime: String {
109:         let hours = Int(playTime) / 3600
110:         let minutes = Int(playTime) / 60 % 60
111:         if hours > 0 {
112:             return String(format: "%d:%02d h", hours, minutes)
113:         } else {
114:             return String(format: "%d min", minutes)
115:         }
116:     }
117:     var formattedTotalScore: String {
118:         return NumberFormatter.localizedString(from: NSNumber(value: totalScore), number: .decimal)
119:     }
120:     var formattedAccuracy: String {
121:         return String(format: "%.1f%%", averageAccuracy * 100)
122:     }
123: }
124: extension UserProfile {
125:     mutating func updateStatistics(score: Int = 0,
126:                                  noteHit: Bool = false,
127:                                  accuracy: Double? = nil,
128:                                  levelCompleted: Bool = false,
129:                                  isPerfect: Bool = false,
130:                                  playTime: TimeInterval = 0,
131:                                  gamesWon: Int = 0,
132:                                  gamesLost: Int = 0) {
133:         statistics.totalScore += score
134:         if noteHit {
135:             statistics.notesHit += 1
136:             statistics.updateStreak(hitNote: true)
137:         } else {
138:             statistics.updateStreak(hitNote: false)
139:         }
140:         if let accuracy = accuracy {
141:             statistics.updateAccuracy(with: accuracy)
142:         }
143:         if levelCompleted {
144:             statistics.currentLevel += 1
145:             if isPerfect {
146:                 statistics.perfectLevelsCount += 1
147:             }
148:         }
149:         if playTime > 0 {
150:             statistics.addPlayTime(playTime)
151:         }
152:             statistics.gamesWon += gamesWon
153:             statistics.gamesLost += gamesLost
154:             statistics.totalGamesPlayed = statistics.gamesWon + statistics.gamesLost
155:             MedalManager.shared.updateMedals(
156:                 notesHit: statistics.notesHit,
157:                 playTime: statistics.playTime,
158:                 currentStreak: statistics.currentStreak,
159:                 perfectTuningCount: statistics.perfectLevelsCount
160:             )
161:             save()
162:         }
163:     func resetStatistics() {
164:         var resetProfile = self
165:         resetProfile.statistics = Statistics()
166:         resetProfile.achievements = Achievements()
167:         resetProfile.save()
168:     }
169: }
</file>

<file path="MusicBlocks/Paneles/DetectedNoteCounterNode.swift">
  1: import SpriteKit
  2: class DetectedNoteCounterNode: SKNode {
  3:     struct Layout {
  4:         static let defaultSize = CGSize(width: 100, height: 40)
  5:         static let cornerRadius: CGFloat = 8
  6:         static let backgroundAlpha: CGFloat = 0.95
  7:         static let inactiveAlpha: CGFloat = 0.6
  8:         static let animationDuration: TimeInterval = 0.2
  9:         static let fontSize: CGFloat = 18
 10:         static let padding: CGFloat = 10
 11:         static let shadowRadius: CGFloat = 4.0
 12:         static let shadowOpacity: Float = 0.2
 13:         static let shadowOffset = CGPoint(x: 0, y: -1)
 14:     }
 15:     private let containerSize: CGSize
 16:     private let container: SKShapeNode
 17:     private let shadowNode: SKEffectNode
 18:     private let noteLabel: SKLabelNode
 19:     var currentNote: String = "-" {
 20:         didSet {
 21:             updateDisplay()
 22:         }
 23:     }
 24:     var isActive: Bool = false {
 25:         didSet {
 26:             updateDisplay()
 27:         }
 28:     }
 29:     init(size: CGSize = Layout.defaultSize) {
 30:         self.containerSize = size
 31:         shadowNode = SKEffectNode()
 32:         let shadowShape = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
 33:         shadowShape.fillColor = .black
 34:         shadowShape.strokeColor = .clear
 35:         shadowShape.alpha = CGFloat(Layout.shadowOpacity)
 36:         shadowNode.addChild(shadowShape)
 37:         shadowNode.shouldRasterize = true
 38:         shadowNode.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": Layout.shadowRadius])
 39:         shadowNode.position = Layout.shadowOffset
 40:         container = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
 41:         noteLabel = SKLabelNode(fontNamed: "Helvetica-Bold")
 42:         noteLabel.fontSize = min(size.height * 0.5, Layout.fontSize)
 43:         noteLabel.verticalAlignmentMode = .center
 44:         noteLabel.horizontalAlignmentMode = .center
 45:         super.init()
 46:         setupNodes()
 47:         updateDisplay()
 48:     }
 49:     required init?(coder aDecoder: NSCoder) {
 50:         fatalError("init(coder:) has not been implemented")
 51:     }
 52:     private func setupNodes() {
 53:         applyContainerStyle(size: containerSize)
 54:         noteLabel.position = CGPoint(x: 0, y: 0)
 55:         addChild(noteLabel)
 56:     }
 57:     private func updateDisplay() {
 58:         noteLabel.text = currentNote
 59:         if isActive {
 60:             noteLabel.fontColor = .black
 61:             container.alpha = Layout.backgroundAlpha
 62:         } else {
 63:             noteLabel.fontColor = .gray
 64:             container.alpha = Layout.inactiveAlpha
 65:         }
 66:         animateUpdate()
 67:     }
 68:     private func animateUpdate() {
 69:         let scaleUp = SKAction.scale(to: 1.1, duration: Layout.animationDuration / 2)
 70:         let scaleDown = SKAction.scale(to: 1.0, duration: Layout.animationDuration / 2)
 71:         let sequence = SKAction.sequence([scaleUp, scaleDown])
 72:         noteLabel.run(sequence)
 73:     }
 74:     static func createForRightSideBar(at position: CGPoint, size: CGSize = Layout.defaultSize, zPosition: CGFloat = 10) -> DetectedNoteCounterNode {
 75:         let node = DetectedNoteCounterNode(size: size)
 76:         node.position = position
 77:         node.zPosition = zPosition
 78:         return node
 79:     }
 80: }
 81: #if DEBUG
 82: import SwiftUI
 83: extension DetectedNoteCounterNode {
 84:     static func createPreviewScene() -> SKScene {
 85:         let scene = SKScene(size: CGSize(width: 300, height: 150))
 86:         scene.backgroundColor = .clear
 87:         let activeNode = DetectedNoteCounterNode()
 88:         activeNode.currentNote = "La4"
 89:         activeNode.isActive = true
 90:         activeNode.position = CGPoint(x: 150, y: 100)
 91:         scene.addChild(activeNode)
 92:         let inactiveNode = DetectedNoteCounterNode()
 93:         inactiveNode.currentNote = "-"
 94:         inactiveNode.isActive = false
 95:         inactiveNode.position = CGPoint(x: 150, y: 50)
 96:         scene.addChild(inactiveNode)
 97:         return scene
 98:     }
 99: }
100: struct DetectedNoteCounterPreview: PreviewProvider {
101:     static var previews: some View {
102:         ZStack {
103:             Color.gray.opacity(0.3)
104:             SpriteView(scene: DetectedNoteCounterNode.createPreviewScene())
105:         }
106:         .frame(width: 300, height: 150)
107:     }
108: }
109: #endif
</file>

<file path="MusicBlocks/Paneles/GameOverlayNode.swift">
  1: import SpriteKit
  2: import UIKit
  3: class GameOverlayNode: SKNode {
  4:     struct Layout {
  5:         static let cornerRadius: CGFloat = 20
  6:         static let padding: CGFloat = 30
  7:         static let iconSize: CGFloat = 40
  8:         static let spacing: CGFloat = 15
  9:         static let backgroundAlpha: CGFloat = 0.7
 10:     }
 11:     enum OverlayPosition {
 12:         case bottom
 13:         case center
 14:         func getPosition(in scene: SKScene) -> CGPoint {
 15:             switch self {
 16:             case .bottom:
 17:                 return CGPoint(x: scene.size.width/2, y: scene.size.height * 0.1)
 18:             case .center:
 19:                 return CGPoint(x: scene.size.width/2, y: scene.size.height/2)
 20:             }
 21:         }
 22:     }
 23:     private let backgroundNode: SKShapeNode
 24:     let contentNode: SKNode
 25:     init(size: CGSize) {
 26:         backgroundNode = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
 27:         contentNode = SKNode()
 28:         super.init()
 29:         setupBackground()
 30:         addChild(contentNode)
 31:     }
 32:     required init?(coder aDecoder: NSCoder) {
 33:         fatalError("init(coder:) has not been implemented")
 34:     }
 35:     private func setupBackground() {
 36:         backgroundNode.fillColor = .white
 37:         backgroundNode.strokeColor = .clear
 38:         backgroundNode.alpha = 0.95
 39:         addChild(backgroundNode)
 40:     }
 41:     func show(in scene: SKScene, overlayPosition: OverlayPosition = .center, duration: TimeInterval = 0.3) {
 42:         alpha = 0
 43:         setScale(0.5)
 44:         self.position = overlayPosition.getPosition(in: scene)
 45:         zPosition = 100
 46:         let appearAction = SKAction.group([
 47:             SKAction.fadeIn(withDuration: duration),
 48:             SKAction.scale(to: 1.0, duration: duration)
 49:         ])
 50:         run(appearAction)
 51:     }
 52:     func hide(duration: TimeInterval = 0.3) {
 53:         let disappearAction = SKAction.group([
 54:             SKAction.fadeOut(withDuration: duration),
 55:             SKAction.scale(to: 0.5, duration: duration)
 56:         ])
 57:         run(SKAction.sequence([
 58:             disappearAction,
 59:             SKAction.removeFromParent()
 60:         ]))
 61:     }
 62: }
 63: class LevelStartOverlayNode: GameOverlayNode {
 64:     private var countdownLabel: SKLabelNode?
 65:     private var countdownTimer: Timer?
 66:     private var secondsRemaining: Int = 5
 67:     private var startAction: (() -> Void)?
 68:     init(size: CGSize, levelId: Int, levelName: String, startAction: @escaping () -> Void) {
 69:         super.init(size: size)
 70:         self.startAction = startAction
 71:         setupBackground()
 72:         let headerContainer = SKNode()
 73:         let titleNode = SKLabelNode(text: "Nivel \(levelId)")
 74:         titleNode.fontSize = min(40, size.width * 0.12)
 75:         titleNode.fontName = "Helvetica-Bold"
 76:         titleNode.fontColor = .purple
 77:         titleNode.position = CGPoint(x: 0, y: size.height * 0.2)
 78:         headerContainer.addChild(titleNode)
 79:         let nameNode = SKLabelNode(text: levelName)
 80:         nameNode.fontSize = min(24, size.width * 0.08)
 81:         nameNode.fontName = "Helvetica"
 82:         nameNode.fontColor = .darkGray
 83:         nameNode.position = CGPoint(x: 0, y: size.height * 0.08)
 84:         headerContainer.addChild(nameNode)
 85:         let separatorLine = SKShapeNode(rectOf: CGSize(width: size.width * 0.8, height: 1))
 86:         separatorLine.fillColor = .lightGray
 87:         separatorLine.strokeColor = .clear
 88:         separatorLine.position = CGPoint(x: 0, y: 0)
 89:         headerContainer.addChild(separatorLine)
 90:         contentNode.addChild(headerContainer)
 91:         let readyNode = SKLabelNode(text: "¡Prepárate!")
 92:         readyNode.fontSize = min(28, size.width * 0.09)
 93:         readyNode.fontName = "Helvetica-Bold"
 94:         readyNode.fontColor = .orange
 95:         readyNode.position = CGPoint(x: 0, y: -size.height * 0.1)
 96:         contentNode.addChild(readyNode)
 97:         let countdownNode = SKLabelNode(text: "\(secondsRemaining)")
 98:         countdownNode.fontSize = min(64, size.width * 0.2)
 99:         countdownNode.fontName = "Helvetica-Bold"
100:         countdownNode.fontColor = .orange
101:         countdownNode.position = CGPoint(x: 0, y: -size.height * 0.30)
102:         contentNode.addChild(countdownNode)
103:         self.countdownLabel = countdownNode
104:     }
105:     private func setupBackground() {
106:         let nodeSize = self.calculateAccumulatedFrame().size
107:         let backgroundNode = SKShapeNode(rectOf: nodeSize, cornerRadius: Layout.cornerRadius)
108:         let gradientImage = generateGradientImage(
109:             from: UIColor.systemIndigo,
110:             to: UIColor.systemBlue.withAlphaComponent(0.7),
111:             size: nodeSize
112:         )
113:         backgroundNode.fillTexture = SKTexture(image: gradientImage)
114:         backgroundNode.strokeColor = UIColor.white
115:         backgroundNode.lineWidth = 2
116:         backgroundNode.alpha = 0.9
117:         contentNode.addChild(backgroundNode)
118:     }
119:     private func generateGradientImage(from startColor: UIColor, to endColor: UIColor, size: CGSize) -> UIImage {
120:         let gradientLayer = CAGradientLayer()
121:         gradientLayer.frame = CGRect(origin: .zero, size: size)
122:         gradientLayer.colors = [startColor.cgColor, endColor.cgColor]
123:         gradientLayer.startPoint = CGPoint(x: 0.5, y: 0.0)
124:         gradientLayer.endPoint = CGPoint(x: 0.5, y: 1.0)
125:         UIGraphicsBeginImageContext(size)
126:         gradientLayer.render(in: UIGraphicsGetCurrentContext()!)
127:         let image = UIGraphicsGetImageFromCurrentImageContext()
128:         UIGraphicsEndImageContext()
129:         return image ?? UIImage()
130:     }
131:     required init?(coder aDecoder: NSCoder) {
132:         fatalError("init(coder:) has not been implemented")
133:     }
134:     override func show(in scene: SKScene, overlayPosition: OverlayPosition = .center, duration: TimeInterval = 0.5) {
135:         super.show(in: scene, overlayPosition: overlayPosition, duration: duration)
136:         startCountdown()
137:     }
138:     private func startCountdown() {
139:         updateCountdownColor()
140:         countdownTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] timer in
141:             guard let self = self else {
142:                 timer.invalidate()
143:                 return
144:             }
145:             self.secondsRemaining -= 1
146:             self.countdownLabel?.text = "\(self.secondsRemaining)"
147:             self.updateCountdownColor()
148:             let scaleUp = SKAction.scale(to: 1.3, duration: 0.15)
149:             let scaleDown = SKAction.scale(to: 1.0, duration: 0.15)
150:             self.countdownLabel?.run(SKAction.sequence([scaleUp, scaleDown]))
151:             if self.secondsRemaining <= 0 {
152:                 timer.invalidate()
153:                 self.hide(duration: 0.3)
154:                 DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) {
155:                     self.startAction?()
156:                 }
157:             }
158:         }
159:     }
160:     private func updateCountdownColor() {
161:         switch secondsRemaining {
162:         case 5, 4:
163:             countdownLabel?.fontColor = UIColor.systemGreen
164:         case 3, 2:
165:             countdownLabel?.fontColor = UIColor.orange
166:         case 1, 0:
167:             countdownLabel?.fontColor = UIColor.red
168:         default:
169:             countdownLabel?.fontColor = UIColor.white
170:         }
171:     }
172:     override func hide(duration: TimeInterval = 0.3) {
173:         countdownTimer?.invalidate()
174:         countdownTimer = nil
175:         super.hide(duration: duration)
176:     }
177: }
178: class SuccessOverlayNode: GameOverlayNode {
179:     init(size: CGSize, multiplier: Int, message: String) {
180:         super.init(size: size)
181:         let checkmarkNode = SKLabelNode(text: "✓")
182:         checkmarkNode.fontSize = 30
183:         checkmarkNode.fontName = "Helvetica-Bold"
184:         checkmarkNode.fontColor = getColor(for: multiplier)
185:         checkmarkNode.position = CGPoint(x: -60, y: 0)
186:         contentNode.addChild(checkmarkNode)
187:         let messageNode = SKLabelNode(text: message)
188:         messageNode.fontSize = 16
189:         messageNode.fontName = "Helvetica-Bold"
190:         messageNode.fontColor = getColor(for: multiplier)
191:         messageNode.position = CGPoint(x: 0, y: 0)
192:         contentNode.addChild(messageNode)
193:         if multiplier > 1 {
194:             let multiplierNode = SKLabelNode(text: "x\(multiplier)")
195:             multiplierNode.fontSize = 18
196:             multiplierNode.fontName = "Helvetica-Bold"
197:             multiplierNode.fontColor = .orange
198:             multiplierNode.position = CGPoint(x: 60, y: 0)
199:             contentNode.addChild(multiplierNode)
200:         }
201:     }
202:     required init?(coder aDecoder: NSCoder) {
203:         fatalError("init(coder:) has not been implemented")
204:     }
205:     private func getColor(for multiplier: Int) -> SKColor {
206:         switch multiplier {
207:         case 3: return .purple
208:         case 2: return .green
209:         case 1: return .blue
210:         default: return .gray
211:         }
212:     }
213: }
214: class FailureOverlayNode: GameOverlayNode {
215:     override init(size: CGSize) {
216:         super.init(size: size)
217:         let xmarkNode = SKLabelNode(text: "✗")
218:         xmarkNode.fontSize = 30
219:         xmarkNode.fontName = "Helvetica-Bold"
220:         xmarkNode.fontColor = .red
221:         xmarkNode.position = CGPoint(x: -90, y: 0)
222:         contentNode.addChild(xmarkNode)
223:         let messageNode = SKLabelNode(text: "¡Intenta de nuevo!")
224:         messageNode.fontSize = 16
225:         messageNode.fontName = "Helvetica-Bold"
226:         messageNode.fontColor = .red
227:         messageNode.position = CGPoint(x: 0, y: 0)
228:         contentNode.addChild(messageNode)
229:     }
230:     required init?(coder aDecoder: NSCoder) {
231:         fatalError("init(coder:) has not been implemented")
232:     }
233: }
234: class GameOverOverlayNode: GameOverlayNode {
235:     private var restartAction: (() -> Void)?
236:     init(size: CGSize, score: Int, message: String, isVictory: Bool = false, restartAction: @escaping () -> Void) {
237:         super.init(size: size)
238:         self.restartAction = restartAction
239:         let titleColor: SKColor = isVictory ? .systemGreen : .purple
240:         let messageColor: SKColor = isVictory ? .systemGreen : .red
241:         let gameoverNode = SKLabelNode(text: isVictory ? "¡Victoria!" : "¡Fin del juego!")
242:         gameoverNode.fontSize = 32
243:         gameoverNode.fontName = "Helvetica-Bold"
244:         gameoverNode.fontColor = titleColor
245:         gameoverNode.position = CGPoint(x: 0, y: size.height/4)
246:         contentNode.addChild(gameoverNode)
247:         let messageNode = SKLabelNode(text: message)
248:         messageNode.fontSize = 16
249:         messageNode.fontName = "Helvetica"
250:         messageNode.fontColor = messageColor
251:         messageNode.position = CGPoint(x: 0, y: size.height/4 - 40)
252:         contentNode.addChild(messageNode)
253:         let scoreNode = SKLabelNode(text: "Puntuación: \(score)")
254:         scoreNode.fontSize = 20
255:         scoreNode.fontName = "Helvetica-Bold"
256:         scoreNode.fontColor = titleColor
257:         scoreNode.position = CGPoint(x: 0, y: 0)
258:         contentNode.addChild(scoreNode)
259:         setupRestartButton(isVictory: isVictory)
260:     }
261:     required init?(coder aDecoder: NSCoder) {
262:         fatalError("init(coder:) has not been implemented")
263:     }
264:     private func setupRestartButton(isVictory: Bool) {
265:         let buttonSize = CGSize(width: 170, height: 50)
266:         let buttonNode = SKShapeNode(rectOf: buttonSize, cornerRadius: 10)
267:         buttonNode.fillColor = isVictory ? .systemGreen : .purple
268:         buttonNode.strokeColor = .clear
269:         buttonNode.position = CGPoint(x: 0, y: -50)
270:         buttonNode.name = "restartButton"
271:         contentNode.addChild(buttonNode)
272:         let buttonText = isVictory ? "Siguiente nivel" : "Intentar de nuevo"
273:         let buttonLabel = SKLabelNode(text: buttonText)
274:         buttonLabel.fontSize = 18
275:         buttonLabel.fontName = "Helvetica-Bold"
276:         buttonLabel.fontColor = .white
277:         buttonLabel.verticalAlignmentMode = .center
278:         buttonNode.addChild(buttonLabel)
279:     }
280:     override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
281:         guard let touch = touches.first else { return }
282:         let location = touch.location(in: self)
283:         let nodes = nodes(at: location)
284:         if nodes.contains(where: { $0.name == "restartButton" }) {
285:             restartAction?()
286:         }
287:     }
288: }
289: #if DEBUG
290: import SwiftUI
291: struct GameOverlayPreview: PreviewProvider {
292:     static var previews: some View {
293:         VStack(spacing: 20) {
294:             SpriteView(scene: {
295:                 let scene = SKScene(size: CGSize(width: 400, height: 300))
296:                 scene.backgroundColor = .white
297:                 let levelStartNode = LevelStartOverlayNode(
298:                     size: CGSize(width: 350, height: 250),
299:                     levelId: 1,
300:                     levelName: "¡Comienza la aventura!",
301:                     startAction: {}
302:                 )
303:                 levelStartNode.position = CGPoint(x: 200, y: 150)
304:                 scene.addChild(levelStartNode)
305:                 return scene
306:             }())
307:             .frame(width: 400, height: 300)
308:             .previewDisplayName("Level Start Overlay")
309:             SpriteView(scene: {
310:                 let scene = SKScene(size: CGSize(width: 400, height: 600))
311:                 scene.backgroundColor = .white
312:                 let successNode = SuccessOverlayNode(
313:                     size: CGSize(width: 300, height: 80),
314:                     multiplier: 2,
315:                     message: "¡Perfecto!"
316:                 )
317:                 successNode.position = CGPoint(x: 200, y: 450)
318:                 scene.addChild(successNode)
319:                 let failureNode = FailureOverlayNode(
320:                     size: CGSize(width: 300, height: 80)
321:                 )
322:                 failureNode.position = CGPoint(x: 200, y: 300)
323:                 scene.addChild(failureNode)
324:                 let gameOverNode = GameOverOverlayNode(
325:                     size: CGSize(width: 300, height: 200),
326:                     score: 1500,
327:                     message: "¡Juego terminado!",
328:                     isVictory: true,
329:                     restartAction: {}
330:                 )
331:                 gameOverNode.position = CGPoint(x: 200, y: 150)
332:                 scene.addChild(gameOverNode)
333:                 return scene
334:             }())
335:             .frame(width: 400, height: 600)
336:             .previewDisplayName("Game State Overlays")
337:         }
338:         .previewLayout(.fixed(width: 400, height: 920))
339:         .background(Color.gray.opacity(0.1))
340:     }
341: }
342: #endif
</file>

<file path="MusicBlocks/Paneles/ScoreProgressNode.swift">
  1: import SpriteKit
  2: class ScoreProgressNode: SKNode {
  3:     private var progressBar: SKShapeNode
  4:     private var progressFill: SKShapeNode
  5:     private var stars: [SKSpriteNode] = []
  6:     private var litStars: [Bool] = []
  7:     private enum Layout {
  8:         static let maxStars: Int = 5
  9:         static let starSize: CGFloat = 20
 10:         static let starVerticalOffset: CGFloat = 1
 11:         static let barHeight: CGFloat = 8
 12:         static let progressBarColor: SKColor = .white.withAlphaComponent(0.6)
 13:         static let progressFillColor: SKColor = .systemPurple
 14:         static let animationDuration: TimeInterval = 0.3
 15:         static let starAnimationScale: CGFloat = 0.5
 16:         static let starAnimationDuration: TimeInterval = 0.15
 17:         static let starAnimationDelay: TimeInterval = 0.1
 18:     }
 19:     private let barWidth: CGFloat
 20:     init(width: CGFloat) {
 21:         self.barWidth = width
 22:         progressBar = SKShapeNode(
 23:             rect: CGRect(x: 0, y: 0, width: width, height: Layout.barHeight),
 24:             cornerRadius: Layout.barHeight / 2
 25:         )
 26:         progressFill = SKShapeNode(
 27:             rect: CGRect(x: 0, y: 0, width: 0, height: Layout.barHeight - 2),
 28:             cornerRadius: (Layout.barHeight - 2) / 2
 29:         )
 30:         litStars = Array(repeating: false, count: Layout.maxStars)
 31:         super.init()
 32:         setupNodes()
 33:     }
 34:     required init?(coder aDecoder: NSCoder) {
 35:         fatalError("init(coder:) has not been implemented")
 36:     }
 37:     private func setupNodes() {
 38:         setupProgressBar()
 39:         setupProgressFill()
 40:         setupStars()
 41:     }
 42:     private func setupProgressBar() {
 43:         progressBar.fillColor = Layout.progressBarColor
 44:         progressBar.strokeColor = .clear
 45:         progressBar.position = .zero
 46:         addChild(progressBar)
 47:     }
 48:     private func setupProgressFill() {
 49:         progressFill.fillColor = Layout.progressFillColor
 50:         progressFill.strokeColor = .clear
 51:         progressFill.position = .zero
 52:         addChild(progressFill)
 53:     }
 54:     private func setupStars() {
 55:         for i in 0..<Layout.maxStars {
 56:             let star = SKSpriteNode(imageNamed: "star_empty")
 57:             star.size = CGSize(width: Layout.starSize, height: Layout.starSize)
 58:             let fraction = CGFloat(i) / CGFloat(Layout.maxStars - 1)
 59:             let xPos = fraction * barWidth
 60:             let yPos = (Layout.barHeight / 2) + Layout.starVerticalOffset
 61:             star.position = CGPoint(x: xPos, y: yPos)
 62:             stars.append(star)
 63:             addChild(star)
 64:         }
 65:     }
 66:     func updateProgress(score: Int, maxScore: Int) {
 67:         animateProgressBar(score: score, maxScore: maxScore)
 68:         updateStars(score: score, maxScore: maxScore)
 69:     }
 70:     private func animateProgressBar(score: Int, maxScore: Int) {
 71:         let fraction = min(CGFloat(score) / CGFloat(maxScore), 1.0)
 72:         let fillWidth = barWidth * fraction
 73:         let resizeAction = SKAction.resize(toWidth: fillWidth, duration: Layout.animationDuration)
 74:         resizeAction.timingMode = .easeOut
 75:         progressFill.run(resizeAction)
 76:     }
 77:     private func updateStars(score: Int, maxScore: Int) {
 78:         let step = maxScore / Layout.maxStars
 79:         let thresholds = (1...Layout.maxStars).map { step * $0 }
 80:         for (index, threshold) in thresholds.enumerated() {
 81:             let delay = Double(index) * Layout.starAnimationDelay
 82:             updateStar(at: index, lit: score >= threshold, delay: delay)
 83:         }
 84:     }
 85:     private func updateStar(at index: Int, lit: Bool, delay: TimeInterval) {
 86:         let star = stars[index]
 87:         let currentlyLit = star.texture?.description.contains("filled") ?? false
 88:         guard lit != currentlyLit else { return }
 89:         DispatchQueue.main.asyncAfter(deadline: .now() + delay) { [weak star] in
 90:             guard let star = star else { return }
 91:             let scaleDown = SKAction.scale(to: Layout.starAnimationScale,
 92:                                            duration: Layout.starAnimationDuration)
 93:             let changeTexture = SKAction.run {
 94:                 star.texture = SKTexture(imageNamed: lit ? "star_filled" : "star_empty")
 95:             }
 96:             let scaleUp = SKAction.scale(to: 1.0,
 97:                                          duration: Layout.starAnimationDuration)
 98:             let sequence = SKAction.sequence([scaleDown, changeTexture, scaleUp])
 99:             star.run(sequence)
100:         }
101:     }
102: }
103: #if DEBUG
104: import SwiftUI
105: struct ScoreProgressNodePreview: PreviewProvider {
106:     static var previews: some View {
107:         ScoreProgressNodeContainer()
108:             .frame(width: 340, height: 120)
109:             .previewDisplayName("Barra con 5 estrellas (x=0..barWidth)")
110:     }
111: }
112: struct ScoreProgressNodeContainer: View {
113:     private func createScene(size: CGSize) -> SKScene {
114:         let scene = SKScene(size: size)
115:         scene.backgroundColor = .black
116:         let barWidth: CGFloat = 300
117:         let progressNode = ScoreProgressNode(width: barWidth)
118:         progressNode.position = CGPoint(x: 20, y: size.height / 2)
119:         scene.addChild(progressNode)
120:         progressNode.updateProgress(score: 200, maxScore: 300)
121:         return scene
122:     }
123:     var body: some View {
124:         GeometryReader { geometry in
125:             SpriteView(scene: createScene(size: geometry.size))
126:         }
127:     }
128: }
129: #endif
</file>

<file path="MusicBlocks/Paneles/StabilityCounterNode.swift">
 1: import SpriteKit
 2: class StabilityCounterNode: SKNode {
 3:     private struct Layout {
 4:         static let primaryFontRatio: CGFloat = 0.4
 5:         static let secondaryFontRatio: CGFloat = 0.3
 6:         static let cornerRadius: CGFloat = 8
 7:         static let backgroundAlpha: CGFloat = 0.95
 8:         static let animationDuration: TimeInterval = 0.2
 9:         static let shadowRadius: CGFloat = 4.0
10:         static let shadowOpacity: Float = 0.2
11:         static let shadowOffset = CGPoint(x: 0, y: -1)
12:     }
13:     private let containerSize: CGSize
14:     private let container: SKShapeNode
15:     private let shadowNode: SKEffectNode
16:     private let timeLabel: SKLabelNode
17:     private let unitLabel: SKLabelNode
18:     var duration: TimeInterval = 0 {
19:         didSet {
20:             updateDisplay()
21:         }
22:     }
23:     init(size: CGSize) {
24:         self.containerSize = size
25:         shadowNode = SKEffectNode()
26:         let shadowShape = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
27:         shadowShape.fillColor = .black
28:         shadowShape.strokeColor = .clear
29:         shadowShape.alpha = CGFloat(Layout.shadowOpacity)
30:         shadowNode.addChild(shadowShape)
31:         shadowNode.shouldRasterize = true
32:         shadowNode.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": Layout.shadowRadius])
33:         shadowNode.position = Layout.shadowOffset
34:         container = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
35:         timeLabel = SKLabelNode(fontNamed: "Helvetica-Bold")
36:         timeLabel.fontSize = size.height * Layout.primaryFontRatio
37:         timeLabel.verticalAlignmentMode = .center
38:         timeLabel.horizontalAlignmentMode = .right
39:         timeLabel.fontColor = .black
40:         unitLabel = SKLabelNode(fontNamed: "Helvetica")
41:         unitLabel.fontSize = size.height * Layout.secondaryFontRatio
42:         unitLabel.verticalAlignmentMode = .center
43:         unitLabel.horizontalAlignmentMode = .left
44:         unitLabel.fontColor = .gray
45:         unitLabel.text = "seg"
46:         super.init()
47:         setupNodes()
48:         updateDisplay()
49:     }
50:     required init?(coder aDecoder: NSCoder) {
51:         fatalError("init(coder:) has not sido implementado")
52:     }
53:     private func setupNodes() {
54:         addChild(shadowNode)
55:         container.fillColor = .white
56:         container.strokeColor = .clear
57:         container.alpha = Layout.backgroundAlpha
58:         addChild(container)
59:         timeLabel.position = CGPoint(x: -containerSize.width * 0.05, y: 0)
60:         unitLabel.position = CGPoint(x: containerSize.width * 0.05, y: 0)
61:         addChild(timeLabel)
62:         addChild(unitLabel)
63:     }
64:     private func updateDisplay() {
65:         timeLabel.text = String(format: "%.1f", duration)
66:         animateUpdate()
67:     }
68:     private func animateUpdate() {
69:         let scaleUp = SKAction.scale(to: 1.05, duration: Layout.animationDuration / 2)
70:         let scaleDown = SKAction.scale(to: 1.0, duration: Layout.animationDuration / 2)
71:         let sequence = SKAction.sequence([scaleUp, scaleDown])
72:         timeLabel.run(sequence)
73:     }
74:     func reset() {
75:         duration = 0
76:     }
77: }
78: #if DEBUG
79: import SwiftUI
80: struct StabilityCounterPreview: PreviewProvider {
81:     static var previews: some View {
82:         SpriteView(scene: {
83:             let scene = SKScene(size: CGSize(width: 300, height: 200))
84:             scene.backgroundColor = .white
85:             let mediumNode = StabilityCounterNode(size: CGSize(width: 120, height: 60))
86:             mediumNode.position = CGPoint(x: 150, y: 120)
87:             mediumNode.duration = 5.5
88:             scene.addChild(mediumNode)
89:             let maxNode = StabilityCounterNode(size: CGSize(width: 120, height: 60))
90:             maxNode.position = CGPoint(x: 150, y: 60)
91:             maxNode.duration = 10.0
92:             scene.addChild(maxNode)
93:             return scene
94:         }())
95:         .frame(width: 300, height: 200)
96:         .previewLayout(.fixed(width: 300, height: 200))
97:     }
98: }
99: #endif
</file>

<file path="MusicBlocks/Paneles/StabilityIndicatorNode.swift">
  1: import SpriteKit
  2: class StabilityIndicatorNode: SKNode {
  3:     private struct Layout {
  4:         static let barWidthRatio: CGFloat = 0.8
  5:         static let markingWidthRatio: CGFloat = 0.6
  6:         static let backgroundAlpha: CGFloat = 0.15
  7:         static let markingsAlpha: CGFloat = 0.3
  8:         static let glowAlpha: CGFloat = 0.8
  9:         static let cornerRadius: CGFloat = 4
 10:         static let animationDuration: TimeInterval = 0.2
 11:     }
 12:     var containerSize: CGSize {
 13:         didSet {
 14:             updateLayout()
 15:         }
 16:     }
 17:     private let backgroundBar: SKShapeNode = SKShapeNode()
 18:     private var markings: [SKShapeNode] = []
 19:     private let glowBar: SKShapeNode = SKShapeNode()
 20:     private var maxDuration: TimeInterval = 10.0
 21:     var duration: TimeInterval = 0 {
 22:         didSet {
 23:             updateProgress()
 24:         }
 25:     }
 26:     init(size: CGSize) {
 27:         self.containerSize = size
 28:         for _ in 0..<3 {
 29:             let mark = SKShapeNode()
 30:             markings.append(mark)
 31:         }
 32:         super.init()
 33:         setupNodes()
 34:         updateLayout()
 35:     }
 36:     required init?(coder aDecoder: NSCoder) {
 37:         fatalError("init(coder:) no ha sido implementado")
 38:     }
 39:     private func setupNodes() {
 40:         backgroundBar.fillColor = .lightGray
 41:         backgroundBar.strokeColor = .clear
 42:         backgroundBar.alpha = Layout.backgroundAlpha
 43:         addChild(backgroundBar)
 44:         for mark in markings {
 45:             mark.fillColor = .darkGray
 46:             mark.strokeColor = .clear
 47:             mark.alpha = Layout.markingsAlpha
 48:             addChild(mark)
 49:         }
 50:         addChild(glowBar)
 51:     }
 52:     private func updateLayout() {
 53:         let barWidth = containerSize.width * Layout.barWidthRatio
 54:         let barHeight = containerSize.height
 55:         let bgRect = CGRect(x: -barWidth/2, y: -barHeight/2, width: barWidth, height: barHeight)
 56:         backgroundBar.path = CGPath(roundedRect: bgRect, cornerWidth: Layout.cornerRadius, cornerHeight: Layout.cornerRadius, transform: nil)
 57:         for (index, mark) in markings.enumerated() {
 58:             let progress = CGFloat(index) / CGFloat(markings.count - 1)
 59:             let yPosition = -containerSize.height * 0.5 + containerSize.height * progress
 60:             mark.position = CGPoint(x: 0, y: yPosition)
 61:             let markWidth = barWidth * Layout.markingWidthRatio
 62:             let markHeight: CGFloat = 2.0
 63:             let markRect = CGRect(x: -markWidth/2, y: -markHeight/2, width: markWidth, height: markHeight)
 64:             mark.path = CGPath(rect: markRect, transform: nil)
 65:         }
 66:         updateProgress()
 67:     }
 68:     private func updateProgress() {
 69:         let normalizedProgress = CGFloat(min(duration, maxDuration) / maxDuration)
 70:         let progressHeight = containerSize.height * normalizedProgress
 71:         let progressWidth = containerSize.width * Layout.barWidthRatio
 72:         let rect = CGRect(x: -progressWidth / 2,
 73:                           y: -containerSize.height / 2,
 74:                           width: progressWidth,
 75:                           height: progressHeight)
 76:         let path = CGMutablePath()
 77:         if progressHeight > Layout.cornerRadius * 2 {
 78:             path.addRoundedRect(in: rect, cornerWidth: Layout.cornerRadius, cornerHeight: Layout.cornerRadius)
 79:         } else {
 80:             path.addRect(rect)
 81:         }
 82:         glowBar.path = path
 83:         glowBar.fillColor = getProgressColor()
 84:         glowBar.alpha = normalizedProgress * Layout.glowAlpha
 85:     }
 86:     private func getProgressColor() -> SKColor {
 87:         return UIColor(red: 0, green: 0.4, blue: 0.9, alpha: 1.0)
 88:     }
 89:     func reset() {
 90:         duration = 0
 91:         updateProgress()
 92:     }
 93:     func setMaxDuration(_ maxDuration: TimeInterval) {
 94:         self.maxDuration = maxDuration
 95:         updateProgress()
 96:     }
 97: }
 98: #if DEBUG
 99: import SwiftUI
100: extension StabilityIndicatorNode {
101:     static func createPreviewScene() -> SKScene {
102:         let scene = SKScene(size: CGSize(width: 300, height: 200))
103:         scene.backgroundColor = .white
104:         let states: [(duration: TimeInterval, position: CGPoint)] = [
105:             (0.0, CGPoint(x: 75, y: 100)),
106:             (5.0, CGPoint(x: 150, y: 100)),
107:             (10.0, CGPoint(x: 225, y: 100))
108:         ]
109:         for state in states {
110:             let node = StabilityIndicatorNode(size: CGSize(width: 40, height: 120))
111:             node.position = state.position
112:             node.duration = state.duration
113:             scene.addChild(node)
114:         }
115:         return scene
116:     }
117: }
118: struct StabilityIndicatorPreview: PreviewProvider {
119:     static var previews: some View {
120:         SpriteView(scene: StabilityIndicatorNode.createPreviewScene())
121:             .frame(width: 300, height: 200)
122:             .previewLayout(.fixed(width: 300, height: 200))
123:     }
124: }
125: #endif
</file>

<file path="MusicBlocks/Paneles/TopBar.swift">
  1: import SpriteKit
  2: import UIKit
  3: class TopBar: SKNode {
  4:     enum TopBarType {
  5:         case main
  6:         case objectives
  7:     }
  8:     private struct Layout {
  9:         static let cornerRadius: CGFloat = 10
 10:         static let horizontalPadding: CGFloat = 10
 11:         static let verticalPadding: CGFloat = 12
 12:             static let bottomRowHorizontalPadding: CGFloat = 18
 13:         static let itemSpacing: CGFloat = 8
 14:         static let fontSize: CGFloat = 14
 15:         static let heartSize: CGFloat = 16
 16:         static let heartSpacing: CGFloat = 6
 17:         static let rowSpacing: CGFloat = 14
 18:     }
 19:     private let barSize: CGSize
 20:     private let type: TopBarType
 21:     private let topRow = SKNode()
 22:     private var levelLabel: SKLabelNode?
 23:     private var heartsContainer = SKNode()
 24:     private let bottomRow = SKNode()
 25:     private var scoreProgressNode: ScoreProgressNode?
 26:     private var objectivePanel: ObjectiveInfoPanel?
 27:     private var heartNodes: [SKSpriteNode] = []
 28:     private var maxLives: Int = 0
 29:     private var maxExtraLives: Int = 0
 30:     private var lives: Int = 0
 31:     private init(width: CGFloat, height: CGFloat, position: CGPoint, type: TopBarType) {
 32:         self.barSize = CGSize(width: width, height: height)
 33:         self.type = type
 34:         super.init()
 35:         self.position = position
 36:         applyContainerStyle(size: barSize)
 37:         addChild(topRow)
 38:         addChild(bottomRow)
 39:         switch type {
 40:         case .main:
 41:             setupMainTopBar()
 42:         case .objectives:
 43:             break
 44:         }
 45:     }
 46:     required init?(coder aDecoder: NSCoder) {
 47:         fatalError("init(coder:) has not been implemented")
 48:     }
 49:     static func create(width: CGFloat, height: CGFloat, position: CGPoint, type: TopBarType) -> TopBar {
 50:         return TopBar(width: width, height: height, position: position, type: type)
 51:     }
 52:     private func setupMainTopBar() {
 53:         levelLabel = SKLabelNode(fontNamed: "Helvetica-Bold")
 54:         levelLabel?.fontSize = Layout.fontSize
 55:         levelLabel?.fontColor = .purple
 56:         levelLabel?.verticalAlignmentMode = .center
 57:         levelLabel?.horizontalAlignmentMode = .left
 58:         levelLabel?.text = "Nivel ?"
 59:         let separator = SKLabelNode(fontNamed: "Helvetica-Bold")
 60:         separator.text = "·"
 61:         separator.fontSize = Layout.fontSize
 62:         separator.fontColor = .darkGray
 63:         separator.verticalAlignmentMode = .center
 64:         separator.horizontalAlignmentMode = .left
 65:         var currentX: CGFloat = -barSize.width/2 + Layout.horizontalPadding
 66:         let rowY: CGFloat = barSize.height/2 - Layout.verticalPadding
 67:         if let label = levelLabel {
 68:             label.position = CGPoint(x: currentX, y: rowY)
 69:             topRow.addChild(label)
 70:             currentX += label.frame.width + Layout.itemSpacing
 71:         }
 72:         separator.position = CGPoint(x: currentX, y: rowY)
 73:         topRow.addChild(separator)
 74:         currentX += separator.frame.width + Layout.itemSpacing + 5
 75:         heartsContainer.position = CGPoint(x: currentX, y: rowY)
 76:         topRow.addChild(heartsContainer)
 77:     }
 78:     private func setupScoreDisplay() {
 79:         let topRowHeight = topRow.calculateAccumulatedFrame().height
 80:         bottomRow.position = CGPoint(
 81:             x: 0,
 82:             y: (barSize.height/2 - Layout.verticalPadding) - topRowHeight - Layout.rowSpacing
 83:         )
 84:         let availableWidth = barSize.width - (Layout.bottomRowHorizontalPadding * 2)
 85:         let progressNode = ScoreProgressNode(width: availableWidth)
 86:         progressNode.position = CGPoint(
 87:             x: -barSize.width/2 + Layout.bottomRowHorizontalPadding,
 88:             y: 0
 89:         )
 90:         bottomRow.addChild(progressNode)
 91:         scoreProgressNode = progressNode
 92:     }
 93:     func configure(withLevel level: GameLevel, objectiveTracker: LevelObjectiveTracker) {
 94:         switch type {
 95:         case .main:
 96:             configureMainBar(withLevel: level)
 97:         case .objectives:
 98:             configureObjectivesBar(withLevel: level, objectiveTracker: objectiveTracker)
 99:         }
100:     }
101:     private func configureMainBar(withLevel level: GameLevel) {
102:         levelLabel?.text = "Nivel \(level.levelId)"
103:         maxLives = level.lives.initial
104:         maxExtraLives = level.lives.extraLives.maxExtra
105:         lives = level.lives.initial
106:         setupHearts(in: heartsContainer)
107:         updateLives(lives)
108:         DispatchQueue.main.async {
109:             self.setupScoreDisplay()
110:         }
111:     }
112:     private func configureObjectivesBar(withLevel level: GameLevel, objectiveTracker: LevelObjectiveTracker) {
113:         topRow.removeFromParent()
114:         objectivePanel?.removeFromParent()
115:         let panelSize = CGSize(width: barSize.width, height: barSize.height)
116:         let panel = ObjectivePanelFactory.createPanel(
117:             for: level.objectives.primary,
118:             size: panelSize,
119:             tracker: objectiveTracker
120:         )
121:         objectivePanel = panel
122:         bottomRow.position = .zero
123:         bottomRow.removeAllChildren()
124:         panel.position = CGPoint(x: -barSize.width/2 + 10, y: 0)
125:         bottomRow.addChild(panel)
126:     }
127:     func updateScore(_ newScore: Int) {
128:         if type == .main,
129:            let currentLevel = GameManager.shared.currentLevel {
130:             scoreProgressNode?.updateProgress(score: newScore, maxScore: currentLevel.maxScore)
131:         }
132:     }
133:     func updateLives(_ newLives: Int) {
134:         if type == .main {
135:             lives = newLives
136:             updateHeartsDisplay()
137:         }
138:     }
139:     private func setupHearts(in container: SKNode) {
140:         heartNodes.forEach { $0.removeFromParent() }
141:         heartNodes.removeAll()
142:         var currentX: CGFloat = 0
143:         for _ in 0..<maxLives {
144:             let heart = SKSpriteNode(imageNamed: "heart_filled")
145:             heart.size = CGSize(width: Layout.heartSize, height: Layout.heartSize)
146:             heart.position = CGPoint(x: currentX, y: 0)
147:             container.addChild(heart)
148:             heartNodes.append(heart)
149:             currentX += Layout.heartSize + Layout.heartSpacing
150:         }
151:         for _ in 0..<maxExtraLives {
152:             let heart = SKSpriteNode(imageNamed: "heart_extra")
153:             heart.size = CGSize(width: Layout.heartSize, height: Layout.heartSize)
154:             heart.alpha = 0
155:             heart.position = CGPoint(x: currentX, y: 0)
156:             container.addChild(heart)
157:             heartNodes.append(heart)
158:             currentX += Layout.heartSize + Layout.heartSpacing
159:         }
160:     }
161:     private func updateHeartsDisplay() {
162:         for (index, heart) in heartNodes.enumerated() {
163:             heart.alpha = 1.0
164:             if index < maxLives {
165:                 if index < lives {
166:                     heart.texture = SKTexture(imageNamed: "heart_filled")
167:                 } else {
168:                     heart.texture = SKTexture(imageNamed: "heart_empty")
169:                 }
170:             } else if index < (maxLives + maxExtraLives) {
171:                 if index < lives {
172:                     heart.texture = SKTexture(imageNamed: "heart_extra_filled")
173:                     heart.alpha = 1.0
174:                 } else {
175:                     heart.alpha = 0
176:                 }
177:             }
178:         }
179:     }
180:     func updateObjectiveInfo(with progress: ObjectiveProgress) {
181:         if type == .objectives {
182:             objectivePanel?.updateInfo(with: progress)
183:         }
184:     }
185: }
186: #if DEBUG
187: import SwiftUI
188: struct TopBarPreview: PreviewProvider {
189:     static var previews: some View {
190:         TopBarPreviewContainer()
191:             .previewDisplayName("TopBar")
192:     }
193: }
194: struct TopBarPreviewContainer: View {
195:     var body: some View {
196:         GeometryReader { geometry in
197:             SpriteView(scene: createScene(size: geometry.size))
198:                 .background(Color.gray.opacity(0.2))
199:         }
200:     }
201:     private func createScene(size: CGSize) -> SKScene {
202:         let scene = SKScene(size: size)
203:         scene.backgroundColor = .darkGray
204:         let level = GameLevel(
205:             levelId: 1,
206:             name: "Nivel de prueba",
207:             maxScore: 600,
208:             allowedStyles: [],
209:             fallingSpeed: FallingSpeed(initial: 8.0, increment: 0.0),
210:             lives: Lives(
211:                 initial: 3,
212:                 extraLives: ExtraLives(scoreThresholds: [500, 1000], maxExtra: 2)
213:             ),
214:             objectives: Objectives(primary: Objective(
215:                 type: "score",
216:                 target: 1000,
217:                 timeLimit: 180,
218:                 minimumAccuracy: nil,
219:                 details: nil
220:             )),
221:             blocks: [:]
222:         )
223:         let topBarWidth = min(size.width * 0.45, 300)
224:         let topBarHeight: CGFloat = 60
225:         let leftBar = TopBar.create(
226:             width: topBarWidth,
227:             height: topBarHeight,
228:             position: CGPoint(x: size.width/2, y: size.height/2 + 50),
229:             type: .main
230:         )
231:         leftBar.configure(withLevel: level, objectiveTracker: LevelObjectiveTracker(level: level))
232:         leftBar.updateScore(300)
233:         leftBar.updateLives(2)
234:         scene.addChild(leftBar)
235:         let rightBar = TopBar.create(
236:             width: topBarWidth,
237:             height: topBarHeight,
238:             position: CGPoint(x: size.width/2, y: size.height/2 - 50),
239:             type: .objectives
240:         )
241:         rightBar.configure(withLevel: level, objectiveTracker: LevelObjectiveTracker(level: level))
242:         let progress = ObjectiveProgress(
243:             score: 300,
244:             notesHit: 15,
245:             accuracySum: 85.0,
246:             accuracyCount: 1,
247:             totalBlocksDestroyed: 15,
248:             timeElapsed: 45
249:         )
250:         rightBar.updateObjectiveInfo(with: progress)
251:         scene.addChild(rightBar)
252:         return scene
253:     }
254: }
255: #endif
</file>

<file path="MusicBlocks/Paneles/TopBarComponents.swift">
  1: import SpriteKit
  2: import UIKit
  3: import Foundation
  4: private enum TopBarLayout {
  5:     static let cornerRadius: CGFloat = 15
  6:     static let padding: CGFloat = 18
  7:     static let iconTextSpacing: CGFloat = 16
  8:     static let fontSize: CGFloat = 14
  9:     static let titleFontSize: CGFloat = 16
 10:     static let smallFontSize: CGFloat = 12
 11:     static let verticalSpacing: CGFloat = 8
 12:     static let horizontalSpacing: CGFloat = 8
 13:     static let panelHeight: CGFloat = 60
 14:     static let iconSize: CGFloat = 18
 15:     static let columnWidth: CGFloat = 80
 16:     static let rowSpacing: CGFloat = 20
 17:     static let maxItemsPerColumn: Int = 2
 18:     static let maxColumns: Int = 4
 19: }
 20: struct ObjectiveProgress {
 21:     var score: Int = 0
 22:     var notesHit: Int = 0
 23:     var accuracySum: Double = 0
 24:     var accuracyCount: Int = 0
 25:     var blocksByType: [String: Int] = [:]
 26:     var totalBlocksDestroyed: Int = 0
 27:     var timeElapsed: TimeInterval = 0
 28:     var averageAccuracy: Double {
 29:         return accuracyCount > 0 ? accuracySum / Double(accuracyCount) : 0
 30:     }
 31: }
 32: enum ObjectiveIcon {
 33:     case score
 34:     case totalNotes
 35:     case accuracy
 36:     case blocks
 37:     case time
 38:     var imageName: String {
 39:         switch self {
 40:         case .score: return "coin_icon"
 41:         case .totalNotes: return "note_icon"
 42:         case .accuracy: return "target_icon"
 43:         case .blocks: return "defaultBlock_icon"
 44:         case .time: return "timer_icon"
 45:         }
 46:     }
 47: }
 48: private let blockStyleIcons: [String: String] = [
 49:     "defaultBlock": "defaultBlock_icon",
 50:     "iceBlock": "iceBlock_icon",
 51:     "hardiceBlock": "hardiceBlock_icon",
 52:     "ghostBlock": "ghostBlock_icon",
 53:     "changingBlock": "changingBlock_icon",
 54:     "explosiveBlock": "explosiveBlock_icon",
 55: ]
 56: class ObjectiveIconNode: SKNode {
 57:     private let icon: SKSpriteNode
 58:     private let value: SKLabelNode
 59:     init(type: ObjectiveIcon) {
 60:         let iconTexture = SKTexture(imageNamed: type.imageName)
 61:         let originalSize = iconTexture.size()
 62:         let w = originalSize.width
 63:         let h = originalSize.height
 64:         let maxDim: CGFloat = TopBarLayout.iconSize
 65:         let scale = max(w, h) > 0 ? (maxDim / max(w, h)) : 1.0
 66:         let finalWidth = w * scale
 67:         let finalHeight = h * scale
 68:         icon = SKSpriteNode(texture: iconTexture)
 69:         icon.size = CGSize(width: finalWidth, height: finalHeight)
 70:         value = SKLabelNode(fontNamed: "Helvetica")
 71:         super.init()
 72:         icon.position = CGPoint(x: -TopBarLayout.iconTextSpacing/2, y: 0)
 73:         value.fontSize = TopBarLayout.smallFontSize
 74:         value.fontColor = .darkGray
 75:         value.verticalAlignmentMode = .center
 76:         value.horizontalAlignmentMode = .left
 77:         value.position = CGPoint(x: icon.position.x + TopBarLayout.iconTextSpacing, y: 0)
 78:         addChild(icon)
 79:         addChild(value)
 80:     }
 81:     required init?(coder aDecoder: NSCoder) {
 82:         fatalError("init(coder:) has not been implemented")
 83:     }
 84:     func updateValueColor(_ color: SKColor) {
 85:         value.fontColor = color
 86:     }
 87:     func updateValue(_ newValue: String) {
 88:         value.text = newValue
 89:     }
 90: }
 91: class TopBarBaseNode: SKNode {
 92:     var size: CGSize
 93:     init(size: CGSize) {
 94:         self.size = size
 95:         super.init()
 96:         setupBackground()
 97:     }
 98:     required init?(coder aDecoder: NSCoder) {
 99:         fatalError("init(coder:) has not been implemented")
100:     }
101:     func setupBackground() {
102:         let background = SKShapeNode(rectOf: size, cornerRadius: TopBarLayout.cornerRadius)
103:         background.fillColor = .white
104:         background.strokeColor = .clear
105:         background.alpha = 0.95
106:         addChild(background)
107:     }
108:     func createLabel(_ text: String, fontSize: CGFloat = TopBarLayout.fontSize) -> SKLabelNode {
109:         let label = SKLabelNode(fontNamed: "Helvetica")
110:         label.text = text
111:         label.fontSize = fontSize
112:         label.fontColor = .darkGray
113:         return label
114:     }
115: }
116: class TimeDisplayNode: SKNode {
117:     private let timeIcon: SKSpriteNode
118:     private let timeLabel: SKLabelNode
119:     private let timeLimit: TimeInterval
120:     private let startTime: Date
121:     init(timeLimit: TimeInterval) {
122:         let iconTexture = SKTexture(imageNamed: "timer_icon")
123:         timeIcon = SKSpriteNode(texture: iconTexture)
124:         let originalSize = iconTexture.size()
125:         let w = originalSize.width
126:         let h = originalSize.height
127:         let maxDim: CGFloat = TopBarLayout.iconSize
128:         let scale = max(w, h) > 0 ? (maxDim / max(w, h)) : 1.0
129:         timeIcon.size = CGSize(width: w * scale, height: h * scale)
130:         self.timeLabel = SKLabelNode(fontNamed: "Helvetica")
131:         self.timeLimit = timeLimit
132:         self.startTime = Date()
133:         super.init()
134:         setupTimeComponents()
135:     }
136:     required init?(coder aDecoder: NSCoder) {
137:         fatalError("init(coder:) has not been implemented")
138:     }
139:     private func setupTimeComponents() {
140:         timeIcon.position = CGPoint(x: -TopBarLayout.iconTextSpacing/2, y: 0)
141:         addChild(timeIcon)
142:         timeLabel.fontSize = TopBarLayout.fontSize
143:         timeLabel.fontColor = .darkGray
144:         timeLabel.verticalAlignmentMode = .center
145:         timeLabel.horizontalAlignmentMode = .left
146:         timeLabel.position = CGPoint(x: timeIcon.position.x + TopBarLayout.iconTextSpacing, y: 0)
147:         addChild(timeLabel)
148:         update()
149:     }
150:     func update() {
151:         if timeLimit == 0 {
152:             timeLabel.text = "∞"
153:             return
154:         }
155:         let elapsedTime = Date().timeIntervalSince(startTime)
156:         let remainingTime = max(timeLimit - elapsedTime, 0)
157:         let minutes = Int(remainingTime) / 60
158:         let seconds = Int(remainingTime) % 60
159:         timeLabel.text = String(format: "%02d:%02d", minutes, seconds)
160:         timeLabel.fontColor = remainingTime < 30 ? .red : .darkGray
161:     }
162: }
163: class ObjectiveInfoPanel: TopBarBaseNode {
164:     weak var objectiveTracker: LevelObjectiveTracker?
165:     private var objectiveIconNode: ObjectiveIconNode?
166:     private var timeIconNode: ObjectiveIconNode?
167:     private var blockIcons: [String: ObjectiveIconNode] = [:]
168:     private var blockDestructionContainer: SKNode?
169:     init(size: CGSize, objectiveTracker: LevelObjectiveTracker) {
170:         self.objectiveTracker = objectiveTracker
171:         super.init(size: size)
172:         setupPanel()
173:     }
174:     required init?(coder aDecoder: NSCoder) {
175:         fatalError("init(coder:) has not been implemented")
176:     }
177:     override func setupBackground() {
178:     }
179:     func setupPanel() {
180:         guard let objective = objectiveTracker?.getPrimaryObjective() else { return }
181:         let contentContainer = SKNode()
182:         contentContainer.position = CGPoint(x: TopBarLayout.padding, y: 0)
183:         addChild(contentContainer)
184:         switch objective.type {
185:         case "block_destruction":
186:             let container = SKNode()
187:             contentContainer.addChild(container)
188:             blockDestructionContainer = container
189:         case "total_blocks":
190:             objectiveIconNode = ObjectiveIconNode(type: .blocks)
191:             if let objIcon = objectiveIconNode {
192:                 objIcon.position = CGPoint(x: 0, y: TopBarLayout.verticalSpacing * 2)
193:                 contentContainer.addChild(objIcon)
194:             }
195:             if objective.timeLimit != nil {
196:                 timeIconNode = ObjectiveIconNode(type: .time)
197:                 if let timeIcon = timeIconNode {
198:                     timeIcon.position = CGPoint(x: 0, y: -TopBarLayout.verticalSpacing * 2)
199:                     contentContainer.addChild(timeIcon)
200:                 }
201:             }
202:         default:
203:             let iconType: ObjectiveIcon = getObjectiveIconType(for: objective.type)
204:             objectiveIconNode = ObjectiveIconNode(type: iconType)
205:             if let objIcon = objectiveIconNode {
206:                 objIcon.position = CGPoint(x: 0, y: TopBarLayout.verticalSpacing * 2)
207:                 contentContainer.addChild(objIcon)
208:             }
209:             timeIconNode = ObjectiveIconNode(type: .time)
210:             if let timeIcon = timeIconNode {
211:                 timeIcon.position = CGPoint(x: 0, y: -TopBarLayout.verticalSpacing * 2)
212:                 contentContainer.addChild(timeIcon)
213:             }
214:         }
215:     }
216:     private func createBlockIconNode(for blockType: String) -> ObjectiveIconNode {
217:         let imageName = blockStyleIcons[blockType] ?? "default_block_icon"
218:         let iconTexture = SKTexture(imageNamed: imageName)
219:         let originalSize = iconTexture.size()
220:         let w = originalSize.width
221:         let h = originalSize.height
222:         let maxDim: CGFloat = TopBarLayout.iconSize
223:         let scale = max(w, h) > 0 ? (maxDim / max(w, h)) : 1.0
224:         let finalWidth = w * scale
225:         let finalHeight = h * scale
226:         let node = ObjectiveIconNode(type: .blocks)
227:         if let existingIcon = node.children.first as? SKSpriteNode {
228:             existingIcon.texture = iconTexture
229:             existingIcon.size = CGSize(width: finalWidth, height: finalHeight)
230:         }
231:         return node
232:     }
233:     private func getObjectiveIconType(for objectiveType: String) -> ObjectiveIcon {
234:         switch objectiveType {
235:         case "score": return .score
236:         case "total_notes": return .totalNotes
237:         case "note_accuracy": return .accuracy
238:         case "block_destruction", "total_blocks": return .blocks
239:         default: return .score
240:         }
241:     }
242:     func updateInfo(with progress: ObjectiveProgress) {
243:         guard let objective = objectiveTracker?.getPrimaryObjective() else { return }
244:         switch objective.type {
245:         case "block_destruction":
246:             if let details = objective.details {
247:                 updateBlockDestructionLayout(with: progress, details: details)
248:             }
249:             if let timeLimit = objective.timeLimit {
250:                 updateTimeIcon(progress: progress, timeLimit: timeLimit)
251:             } else {
252:                 timeIconNode?.updateValue("∞")
253:             }
254:         default:
255:             switch objective.type {
256:             case "score":
257:                 objectiveIconNode?.updateValue("\(progress.score)/\(objective.target ?? 0)")
258:             case "total_notes":
259:                 objectiveIconNode?.updateValue("\(progress.notesHit)/\(objective.target ?? 0)")
260:             case "note_accuracy":
261:                 let accuracy = Int(progress.averageAccuracy * 100)
262:                 objectiveIconNode?.updateValue("\(accuracy)%")
263:             case "total_blocks":
264:                 objectiveIconNode?.updateValue("\(progress.totalBlocksDestroyed)/\(objective.target ?? 0)")
265:             default:
266:                 break
267:             }
268:             if let timeLimit = objective.timeLimit {
269:                 updateTimeIcon(progress: progress, timeLimit: timeLimit)
270:             } else {
271:                 timeIconNode?.updateValue("∞")
272:             }
273:         }
274:     }
275:     private func updateBlockDestructionLayout(with progress: ObjectiveProgress, details: [String: Int]) {
276:          blockDestructionContainer?.removeAllChildren()
277:          guard let container = blockDestructionContainer else { return }
278:          guard let objective = objectiveTracker?.getPrimaryObjective() else { return }
279:          var displayItems: [(type: String, label: String, isTimeIcon: Bool)] = []
280:          for (blockType, required) in details {
281:              let destroyed = progress.blocksByType[blockType, default: 0]
282:              let text = "\(destroyed)/\(required)"
283:              displayItems.append((type: blockType, label: text, isTimeIcon: false))
284:          }
285:          if let timeLimit = objective.timeLimit {
286:              let timeLimitInterval = TimeInterval(timeLimit)
287:              let remainingTime = max(timeLimitInterval - progress.timeElapsed, 0)
288:              let minutes = Int(remainingTime) / 60
289:              let seconds = Int(remainingTime) % 60
290:              let timeText = String(format: "%02d:%02d", minutes, seconds)
291:              displayItems.append((type: "time", label: timeText, isTimeIcon: true))
292:          }
293:          let totalItems = displayItems.count
294:          let columnsNeeded = min((totalItems + 1) / 2, TopBarLayout.maxColumns)
295:          var startX: CGFloat = 0
296:          if columnsNeeded > 1 {
297:              startX = -((CGFloat(columnsNeeded - 1) * TopBarLayout.columnWidth) / 2)
298:          }
299:          var currentX = startX
300:          var currentY: CGFloat = TopBarLayout.rowSpacing
301:          var itemsInCurrentColumn = 0
302:         for (_, item) in displayItems.enumerated() {
303:              if itemsInCurrentColumn >= TopBarLayout.maxItemsPerColumn {
304:                  currentX += TopBarLayout.columnWidth
305:                  currentY = TopBarLayout.rowSpacing
306:                  itemsInCurrentColumn = 0
307:              }
308:              let iconNode: ObjectiveIconNode
309:              if item.isTimeIcon {
310:                  iconNode = ObjectiveIconNode(type: .time)
311:              } else {
312:                  iconNode = createBlockIconNode(for: item.type)
313:              }
314:              let yPos = currentY - (CGFloat(itemsInCurrentColumn) * TopBarLayout.rowSpacing)
315:              iconNode.position = CGPoint(x: currentX, y: yPos)
316:              iconNode.updateValue(item.label)
317:              if item.isTimeIcon {
318:                  if let timeLimit = objective.timeLimit {
319:                      let timeLimitInterval = TimeInterval(timeLimit)
320:                      let remainingTime = max(timeLimitInterval - progress.timeElapsed, 0)
321:                      if remainingTime < 30 {
322:                          iconNode.updateValueColor(.red)
323:                      }
324:                  }
325:              }
326:              container.addChild(iconNode)
327:              itemsInCurrentColumn += 1
328:          }
329:          container.position = CGPoint(x: 0, y: TopBarLayout.verticalSpacing * 2)
330:      }
331:     private func updateTimeIcon(progress: ObjectiveProgress, timeLimit: Int) {
332:         let timeLimitInterval = TimeInterval(timeLimit)
333:         let remainingTime = max(timeLimitInterval - progress.timeElapsed, 0)
334:         let minutes = Int(remainingTime) / 60
335:         let seconds = Int(remainingTime) % 60
336:         let timeText = String(format: "%02d:%02d", minutes, seconds)
337:         timeIconNode?.updateValue(timeText)
338:         if remainingTime < 30 {
339:             timeIconNode?.updateValueColor(.red)
340:         } else {
341:             timeIconNode?.updateValueColor(.darkGray)
342:         }
343:     }
344: }
345:     class ObjectivePanelFactory {
346:         static func createPanel(for objective: Objective, size: CGSize, tracker: LevelObjectiveTracker) -> ObjectiveInfoPanel {
347:             return ObjectiveInfoPanel(size: size, objectiveTracker: tracker)
348:         }
349:     }
350: #if DEBUG
351: import SwiftUI
352: struct ObjectivePanelsPreview: PreviewProvider {
353:     static var previews: some View {
354:         VStack {
355:             ScoreObjectivePreviewContainer()
356:                 .frame(height: 150)
357:                 .padding(.bottom, 10)
358:                 .previewDisplayName("Score Objective")
359:             TotalNotesObjectivePreviewContainer()
360:                 .frame(height: 150)
361:                 .padding(.bottom, 10)
362:                 .previewDisplayName("Total Notes Objective")
363:             NoteAccuracyObjectivePreviewContainer()
364:                 .frame(height: 150)
365:                 .padding(.bottom, 10)
366:                 .previewDisplayName("Note Accuracy Objective")
367:             BlockDestructionObjectivePreviewContainer()
368:                 .frame(height: 150)
369:                 .padding(.bottom, 10)
370:                 .previewDisplayName("Block Destruction Objective (Columnas)")
371:             TotalBlocksObjectivePreviewContainer()
372:                 .frame(height: 150)
373:                 .previewDisplayName("Total Blocks Objective")
374:         }
375:     }
376: }
377: protocol ObjectivePreviewContainer: View {
378:     var objectiveType: String { get }
379:     func createObjectiveDetails() -> [String: Int]?
380:     func createBlocksDestroyed() -> [String: Int]
381:     func createAllowedStyles() -> [String]
382: }
383: extension ObjectivePreviewContainer {
384:     func createPreviewScene(size: CGSize) -> SKScene {
385:         let scene = SKScene(size: size)
386:         scene.scaleMode = .resizeFill
387:         scene.backgroundColor = .lightGray
388:         let objectiveDetails = createObjectiveDetails()
389:         let allowedStyles = createAllowedStyles()
390:         let blocksDestroyed = createBlocksDestroyed()
391:         let objective = Objective(
392:             type: objectiveType,
393:             target: 1000,
394:             timeLimit: 180,
395:             minimumAccuracy: objectiveType == "note_accuracy" ? 0.85 : nil,
396:             details: objectiveDetails
397:         )
398:         let level = GameLevel(
399:             levelId: 1,
400:             name: "Nivel de prueba",
401:             maxScore: 500,
402:             allowedStyles: allowedStyles,
403:             fallingSpeed: FallingSpeed(initial: 8.0, increment: 0.0),
404:             lives: Lives(
405:                 initial: 3,
406:                 extraLives: ExtraLives(scoreThresholds: [], maxExtra: 0)
407:             ),
408:             objectives: Objectives(primary: objective),
409:             blocks: [:]
410:         )
411:         let tracker = LevelObjectiveTracker(level: level)
412:         let progress = ObjectiveProgress(
413:             score: 350,
414:             notesHit: 40,
415:             accuracySum: 85.0,
416:             accuracyCount: 100,
417:             blocksByType: blocksDestroyed,
418:             totalBlocksDestroyed: blocksDestroyed.values.reduce(0, +),
419:             timeElapsed: 60
420:         )
421:         let panelSize = CGSize(width: size.width * 0.8, height: size.height * 0.7)
422:         let panel = ObjectivePanelFactory.createPanel(for: objective, size: panelSize, tracker: tracker)
423:         panel.updateInfo(with: progress)
424:         panel.position = CGPoint(x: size.width/2, y: size.height/2)
425:         scene.addChild(panel)
426:         return scene
427:     }
428: }
429: struct ScoreObjectivePreviewContainer: View, ObjectivePreviewContainer {
430:     var objectiveType: String { "score" }
431:     func createObjectiveDetails() -> [String: Int]? { nil }
432:     func createBlocksDestroyed() -> [String: Int] { [:] }
433:     func createAllowedStyles() -> [String] { [] }
434:     var body: some View {
435:         GeometryReader { geometry in
436:             SpriteView(scene: createPreviewScene(size: geometry.size))
437:                 .background(Color.gray.opacity(0.2))
438:         }
439:     }
440: }
441: struct TotalNotesObjectivePreviewContainer: View, ObjectivePreviewContainer {
442:     var objectiveType: String { "total_notes" }
443:     func createObjectiveDetails() -> [String: Int]? { nil }
444:     func createBlocksDestroyed() -> [String: Int] { [:] }
445:     func createAllowedStyles() -> [String] { [] }
446:     var body: some View {
447:         GeometryReader { geometry in
448:             SpriteView(scene: createPreviewScene(size: geometry.size))
449:                 .background(Color.gray.opacity(0.2))
450:         }
451:     }
452: }
453: struct NoteAccuracyObjectivePreviewContainer: View, ObjectivePreviewContainer {
454:     var objectiveType: String { "note_accuracy" }
455:     func createObjectiveDetails() -> [String: Int]? { nil }
456:     func createBlocksDestroyed() -> [String: Int] { [:] }
457:     func createAllowedStyles() -> [String] { [] }
458:     var body: some View {
459:         GeometryReader { geometry in
460:             SpriteView(scene: createPreviewScene(size: geometry.size))
461:                 .background(Color.gray.opacity(0.2))
462:         }
463:     }
464: }
465: struct BlockDestructionObjectivePreviewContainer: View, ObjectivePreviewContainer {
466:     var objectiveType: String { "block_destruction" }
467:     func createObjectiveDetails() -> [String: Int]? {
468:         return [
469:             "defaultBlock": 5,
470:             "iceBlock": 3,
471:             "hardiceBlock": 7,
472:             "ghostBlock": 4,
473:             "changingBlock": 6,
474:             "explosiveBlock": 2
475:         ]
476:     }
477:     func createBlocksDestroyed() -> [String: Int] {
478:         return [
479:             "defaultBlock": 2,
480:             "iceBlock": 3,
481:             "hardiceBlock": 5,
482:             "ghostBlock": 1,
483:             "changingBlock": 4,
484:             "explosiveBlock": 0
485:         ]
486:     }
487:     func createAllowedStyles() -> [String] {
488:         return ["defaultBlock", "iceBlock", "hardiceBlock", "ghostBlock", "changingBlock", "explosiveBlock"]
489:     }
490:     var body: some View {
491:         GeometryReader { geometry in
492:             SpriteView(scene: createPreviewScene(size: geometry.size))
493:                 .background(Color.gray.opacity(0.2))
494:         }
495:     }
496:     func createPreviewScene(size: CGSize) -> SKScene {
497:         let scene = SKScene(size: size)
498:         scene.scaleMode = .resizeFill
499:         scene.backgroundColor = .lightGray
500:         let objectiveDetails = createObjectiveDetails()
501:         let allowedStyles = createAllowedStyles()
502:         let blocksDestroyed = createBlocksDestroyed()
503:         let objective = Objective(
504:             type: objectiveType,
505:             target: 1000,
506:             timeLimit: 180,
507:             minimumAccuracy: nil,
508:             details: objectiveDetails
509:         )
510:         let level = GameLevel(
511:             levelId: 1,
512:             name: "Nivel de prueba",
513:             maxScore: 500,
514:             allowedStyles: allowedStyles,
515:             fallingSpeed: FallingSpeed(initial: 8.0, increment: 0.0),
516:             lives: Lives(
517:                 initial: 3,
518:                 extraLives: ExtraLives(scoreThresholds: [], maxExtra: 0)
519:             ),
520:             objectives: Objectives(primary: objective),
521:             blocks: [:]
522:         )
523:         let tracker = LevelObjectiveTracker(level: level)
524:         let progress = ObjectiveProgress(
525:             score: 350,
526:             notesHit: 40,
527:             accuracySum: 85.0,
528:             accuracyCount: 100,
529:             blocksByType: blocksDestroyed,
530:             totalBlocksDestroyed: blocksDestroyed.values.reduce(0, +),
531:             timeElapsed: 60
532:         )
533:         let panelSize = CGSize(width: size.width * 0.8, height: size.height * 0.7)
534:         let panel = ObjectivePanelFactory.createPanel(for: objective, size: panelSize, tracker: tracker)
535:         panel.updateInfo(with: progress)
536:         panel.position = CGPoint(x: size.width/2, y: size.height/2)
537:         scene.addChild(panel)
538:         return scene
539:     }
540: }
541: struct TotalBlocksObjectivePreviewContainer: View, ObjectivePreviewContainer {
542:     var objectiveType: String { "total_blocks" }
543:     func createObjectiveDetails() -> [String: Int]? { nil }
544:     func createBlocksDestroyed() -> [String: Int] {
545:         return [
546:             "defaultBlock": 3,
547:             "iceBlock": 5,
548:             "hardiceBlock": 2,
549:         ]
550:     }
551:     func createAllowedStyles() -> [String] {
552:         return ["defaultBlock", "iceBlock", "hardiceBlock"]
553:     }
554:     var body: some View {
555:         GeometryReader { geometry in
556:             SpriteView(scene: createPreviewScene(size: geometry.size))
557:                 .background(Color.gray.opacity(0.2))
558:         }
559:     }
560: }
561: #endif
</file>

<file path="MusicBlocks/Paneles/TuningIndicatorNode.swift">
  1: import SpriteKit
  2: extension Comparable {
  3:     func clamped(to range: ClosedRange<Self>) -> Self {
  4:         return min(max(self, range.lowerBound), range.upperBound)
  5:     }
  6: }
  7: class TuningIndicatorNode: SKNode {
  8:     private struct Layout {
  9:         static let barWidthRatio: CGFloat = 0.8
 10:         static let markingWidthRatio: CGFloat = 0.6
 11:         static let indicatorSizeRatio: CGFloat = 1.0
 12:         static let backgroundAlpha: CGFloat = 0.15
 13:         static let markingsAlpha: CGFloat = 0.3
 14:         static let glowAlpha: CGFloat = 0.8
 15:         static let inactiveAlpha: CGFloat = 0.2
 16:         static let animationDuration: TimeInterval = 0.2
 17:         static let glowRadius: Float = 15.0
 18:         static let glowLineWidth: CGFloat = 8.0
 19:     }
 20:     var containerSize: CGSize {
 21:         didSet {
 22:             updateLayout()
 23:         }
 24:     }
 25:     private let backgroundBar: SKShapeNode = SKShapeNode()
 26:     private var markings: [SKShapeNode] = []
 27:     private let indicatorContainer: SKNode = SKNode()
 28:     private let indicatorCore: SKShapeNode = SKShapeNode()
 29:     private let barGlow: SKEffectNode = SKEffectNode()
 30:     private let barGlowShape: SKShapeNode = SKShapeNode()
 31:     var deviation: Double = 0 {
 32:         didSet {
 33:             updateIndicator()
 34:         }
 35:     }
 36:     var isActive: Bool = false {
 37:         didSet {
 38:             updateIndicator()
 39:         }
 40:     }
 41:     init(size: CGSize) {
 42:         self.containerSize = size
 43:         let markValues = [-25, -10, 0, 10, 25]
 44:         for _ in markValues {
 45:             let mark = SKShapeNode()
 46:             markings.append(mark)
 47:         }
 48:         super.init()
 49:         setupNodes()
 50:         updateLayout()
 51:     }
 52:     required init?(coder aDecoder: NSCoder) {
 53:         fatalError("init(coder:) no ha sido implementado")
 54:     }
 55:     private func setupNodes() {
 56:         applyContainerStyle(size: containerSize)
 57:         barGlow.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": Layout.glowRadius])
 58:         barGlow.shouldRasterize = true
 59:         barGlow.addChild(barGlowShape)
 60:         barGlow.zPosition = -1
 61:         addChild(barGlow)
 62:         for mark in markings {
 63:             mark.fillColor = .darkGray
 64:             mark.strokeColor = .clear
 65:             mark.alpha = Layout.markingsAlpha
 66:             addChild(mark)
 67:         }
 68:         addChild(indicatorContainer)
 69:         let barWidth = containerSize.width * Layout.barWidthRatio
 70:         let indicatorDiameter = barWidth
 71:         let indicatorRadius = indicatorDiameter / 2
 72:         indicatorCore.path = CGPath(ellipseIn: CGRect(x: -indicatorRadius,
 73:                                                      y: -indicatorRadius,
 74:                                                      width: indicatorDiameter,
 75:                                                      height: indicatorDiameter),
 76:                                   transform: nil)
 77:         indicatorCore.strokeColor = .clear
 78:         indicatorContainer.addChild(indicatorCore)
 79:         updateIndicator()
 80:     }
 81:     private func updateLayout() {
 82:         let barWidth = containerSize.width * Layout.barWidthRatio
 83:         let barHeight = containerSize.height
 84:         let bgRect = CGRect(x: -barWidth/2, y: -barHeight/2, width: barWidth, height: barHeight)
 85:         backgroundBar.path = CGPath(rect: bgRect, transform: nil)
 86:         barGlowShape.path = CGPath(rect: bgRect, transform: nil)
 87:         barGlowShape.lineWidth = Layout.glowLineWidth
 88:         for (index, mark) in markings.enumerated() {
 89:             let progress = CGFloat(index) / CGFloat(markings.count - 1)
 90:             let yPosition = -containerSize.height / 2 + containerSize.height * progress
 91:             mark.position = CGPoint(x: 0, y: yPosition)
 92:             let markWidth: CGFloat
 93:             if index == 2 {
 94:                 markWidth = barWidth * 0.8
 95:             } else {
 96:                 markWidth = barWidth * Layout.markingWidthRatio
 97:             }
 98:             let markRect = CGRect(x: -markWidth/2, y: -0.5, width: markWidth, height: 1)
 99:             mark.path = CGPath(rect: markRect, transform: nil)
100:         }
101:         updateIndicator()
102:     }
103:     private func updateIndicator() {
104:         let normalizedDeviation = CGFloat((deviation + 25) / 50).clamped(to: 0...1)
105:         let barWidth = containerSize.width * Layout.barWidthRatio
106:         let indicatorRadius = barWidth * Layout.indicatorSizeRatio
107:         let effectiveHeight = containerSize.height - (indicatorRadius * 2)
108:         let minY = -containerSize.height / 2 + indicatorRadius
109:         let yPosition = minY + (effectiveHeight * normalizedDeviation)
110:         if indicatorCore.path == nil {
111:             indicatorCore.path = CGPath(ellipseIn: CGRect(x: -indicatorRadius, y: -indicatorRadius,
112:                                                        width: indicatorRadius*2, height: indicatorRadius*2), transform: nil)
113:         }
114:         let moveAction = SKAction.move(to: CGPoint(x: 0, y: yPosition), duration: Layout.animationDuration)
115:         moveAction.timingMode = .easeOut
116:         indicatorContainer.run(moveAction)
117:         let color = getDeviationColor()
118:         indicatorCore.fillColor = color
119:         indicatorCore.alpha = isActive ? Layout.glowAlpha : Layout.inactiveAlpha
120:         barGlowShape.strokeColor = color
121:         barGlowShape.fillColor = .clear
122:         barGlowShape.alpha = isActive ? Layout.glowAlpha : Layout.inactiveAlpha
123:     }
124:     private func getDeviationColor() -> SKColor {
125:         guard isActive else {
126:             return .gray
127:         }
128:         let absDeviation = abs(deviation)
129:         if absDeviation < 5 {
130:             return .green
131:         } else if absDeviation < 15 {
132:             return .orange
133:         } else {
134:             return .red
135:         }
136:     }
137: }
138: #if DEBUG
139: import SwiftUI
140: extension TuningIndicatorNode {
141:     static func createPreviewScene() -> SKScene {
142:         let scene = SKScene(size: CGSize(width: 300, height: 200))
143:         scene.backgroundColor = .white
144:         let states: [(deviation: Double, isActive: Bool, position: CGPoint)] = [
145:             (0, true, CGPoint(x: 75, y: 100)),
146:             (12, true, CGPoint(x: 150, y: 100)),
147:             (-20, true, CGPoint(x: 225, y: 100))
148:         ]
149:         for state in states {
150:             let node = TuningIndicatorNode(size: CGSize(width: 20, height: 190))
151:             node.position = state.position
152:             node.deviation = state.deviation
153:             node.isActive = state.isActive
154:             scene.addChild(node)
155:         }
156:         return scene
157:     }
158: }
159: struct TuningIndicatorPreview: PreviewProvider {
160:     static var previews: some View {
161:         SpriteView(scene: TuningIndicatorNode.createPreviewScene())
162:             .frame(width: 300, height: 200)
163:             .previewLayout(.fixed(width: 300, height: 200))
164:     }
165: }
166: #endif
</file>

<file path="MusicBlocks/Paneles/UIContainer.swift">
 1: import SpriteKit
 2: struct CommonStyle {
 3:     static let containerBackgroundColor: SKColor = .white
 4:     static let containerBackgroundAlpha: CGFloat = 0.85
 5:     static let containerCornerRadius: CGFloat = 12
 6:     static let shadowColor: SKColor = .black
 7:     static let shadowRadius: Float = 4.0
 8:     static let shadowOpacity: Float = 0.2
 9:     static let shadowOffset = CGPoint(x: 0, y: -2)
10: }
11: extension SKNode {
12:     func applyContainerStyle(size: CGSize) {
13:         let shadowNode = SKEffectNode()
14:         shadowNode.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": CommonStyle.shadowRadius])
15:         shadowNode.shouldRasterize = true
16:         let shadowShape = SKShapeNode(rectOf: size, cornerRadius: CommonStyle.containerCornerRadius)
17:         shadowShape.fillColor = CommonStyle.shadowColor
18:         shadowShape.strokeColor = .clear
19:         shadowShape.alpha = CGFloat(CommonStyle.shadowOpacity)
20:         shadowShape.position = CommonStyle.shadowOffset
21:         shadowNode.addChild(shadowShape)
22:         let container = SKShapeNode(rectOf: size, cornerRadius: CommonStyle.containerCornerRadius)
23:         container.fillColor = CommonStyle.containerBackgroundColor
24:         container.strokeColor = .clear
25:         container.alpha = CommonStyle.containerBackgroundAlpha
26:         addChild(shadowNode)
27:         addChild(container)
28:     }
29: }
</file>

<file path="MusicBlocks/Pantallazos/repomix-output-MusicBlocks.zip.xml">
   1: This file is a merged representation of the entire codebase, combined into a single document by Repomix. The content has been processed where security check has been disabled.
   2: <file_summary>
   3: This section contains a summary of this file.
   4: <purpose>
   5: This file contains a packed representation of the entire repository's contents.
   6: It is designed to be easily consumable by AI systems for analysis, code review,
   7: or other automated processes.
   8: </purpose>
   9: <file_format>
  10: The content is organized as follows:
  11: 1. This summary section
  12: 2. Repository information
  13: 3. Directory structure
  14: 4. Repository files, each consisting of:
  15:   - File path as an attribute
  16:   - Full contents of the file
  17: </file_format>
  18: <usage_guidelines>
  19: - This file should be treated as read-only. Any changes should be made to the
  20:   original repository files, not this packed version.
  21: - When processing this file, use the file path to distinguish
  22:   between different files in the repository.
  23: - Be aware that this file may contain sensitive information. Handle it with
  24:   the same level of security as you would the original repository.
  25: </usage_guidelines>
  26: <notes>
  27: - Some files may have been excluded based on .gitignore rules and Repomix's configuration
  28: - Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
  29: - Files matching patterns in .gitignore are excluded
  30: - Files matching default ignore patterns are excluded
  31: - Security check has been disabled - content may contain sensitive information
  32: </notes>
  33: <additional_info>
  34: </additional_info>
  35: </file_summary>
  36: <directory_structure>
  37: MusicBlocks/
  38:   Audio/
  39:     AudioController.swift
  40:     TunerEngine.swift
  41:   Bloques/
  42:     BlockContentGenerator.swift
  43:     BlocksManager.swift
  44:     BlockStyle.swift
  45:     MusicalNote.swift
  46:   Inicio y Profile/
  47:     AchievementBadge.swift
  48:     AchievementsView.swift
  49:     AvatarPickerViewController.swift
  50:     ContentView.swift
  51:     ExpandableSectionView.swift
  52:     MusicBlocksApp.swift
  53:     ProfileHeaderView.swift
  54:     ProfileViewController.swift
  55:     StatsView.swift
  56:     UserProfile.swift
  57:   Paneles/
  58:     DetectedNoteCounterNode.swift
  59:     GameOverlayNode.swift
  60:     ScoreProgressNode.swift
  61:     StabilityCounterNode.swift
  62:     StabilityIndicatorNode.swift
  63:     TopBar.swift
  64:     TopBarComponents.swift
  65:     TuningIndicatorNode.swift
  66:     UIContainer.swift
  67:   Preview Content/
  68:     Preview Assets.xcassets/
  69:       Contents.json
  70:   BackgroundPatternNode.swift
  71:   game_levels.json
  72:   GameEngine.swift
  73:   GameLevelProcessor.swift
  74:   GameManager.swift
  75:   GameTypes.swift
  76:   GameUIManager.swift
  77:   LevelObjectiveTracker.swift
  78:   MusicBlocksScene.swift
  79: </directory_structure>
  80: <files>
  81: This section contains the contents of the repository's files.
  82: <file path="MusicBlocks/Audio/AudioController.swift">
  83: //
  84: //  AudioController.swift
  85: //  MusicBlocks
  86: //
  87: //  Created by Jose R. García on 13/3/25.
  88: //  Actualizado para obtener dinámicamente el requiredHoldTime del bloque actual.
  89: //
  90: import AudioKit
  91: import AudioKitEX
  92: import AVFoundation
  93: import SoundpipeAudioKit
  94: protocol AudioControllerDelegate: AnyObject {
  95:     func audioController(_ controller: AudioController, didDetectNote note: String, frequency: Float, amplitude: Float, deviation: Double)
  96:     func audioControllerDidDetectSilence(_ controller: AudioController)
  97:     // Nuevo método para obtener el tiempo requerido para mantener la nota (hold)
  98:     func audioControllerRequiredHoldTime(_ controller: AudioController) -> TimeInterval
  99: }
 100: class AudioController: ObservableObject {
 101:     static let sharedInstance = AudioController()
 102:     weak var delegate: AudioControllerDelegate?
 103:     @Published var tunerData: TunerEngine.TunerData = .inactive
 104:     @Published var stabilityDuration: TimeInterval = 0
 105:     private let tunerEngine = TunerEngine.shared
 106:     let engine = AudioEngine()
 107:     var pitchTap: PitchTap!
 108:     var mic: AudioEngine.InputNode!
 109:     var silence: Fader!
 110:     // Umbrales y configuración
 111:     private let minimumAmplitude: Float = 0.02
 112:     private let minimumFrequency: Float = 20.0
 113:     private let maximumFrequency: Float = 2000.0
 114:     private let stabilityThreshold: Float = 3.0 // Variación máxima permitida en Hz
 115:     private let amplitudeSmoothing: Float = 0.9 // Factor de suavizado para la amplitud
 116:     // Variables de seguimiento
 117:     private var lastStableFrequency: Float = 0
 118:     private var stabilityStartTime: Date?
 119:     private var smoothedAmplitude: Float = 0
 120:     private var lastProcessedTime: Date = Date()
 121:     private let minimumProcessingInterval: TimeInterval = 0.05 // 50ms entre procesamientos
 122:     // MARK: - Nueva funcionalidad: Música de fondo y efectos de sonido
 123:     private var backgroundMusicPlayer: AVAudioPlayer?
 124:     /// Inicia la música de fondo en el menú.
 125:     /// Asegúrate de haber añadido "backgroundMusic.mp3" al bundle de tu proyecto.
 126:     ///
 127:     func startBackgroundMusic() {
 128:         // Si el reproductor ya existe y está reproduciendo, no hacemos nada
 129:         if let player = backgroundMusicPlayer, player.isPlaying {
 130:             print("La música de fondo ya se está reproduciendo")
 131:             return
 132:         }
 133:         guard let url = Bundle.main.url(forResource: "backgroundMusic", withExtension: "mp3")
 134:         else {
 135:             print("No se encontró el archivo de música de fondo")
 136:             return
 137:         }
 138:         do {
 139:             backgroundMusicPlayer = try AVAudioPlayer(contentsOf: url)
 140:             backgroundMusicPlayer?.numberOfLoops = -1
 141:             // Loop infinito
 142:             let targetVolume: Float = 0.5
 143:             backgroundMusicPlayer?.volume = 0.3
 144:             backgroundMusicPlayer?.prepareToPlay()
 145:             backgroundMusicPlayer?.play()
 146:             fadeInBackgroundMusic(to: targetVolume, duration: 1.0)
 147:             print("Música de fondo iniciada con fade in")
 148:         }   catch {
 149:             print("Error al reproducir la música de fondo: (error)")
 150:         }
 151:     }
 152:     /// Función privada para realizar el fade in de la música de fondo.
 153:     private func fadeInBackgroundMusic(to targetVolume: Float, duration: TimeInterval) {
 154:         guard let player = backgroundMusicPlayer else { return }
 155:         let fadeSteps = 40
 156:         let fadeStepDuration = duration / Double(fadeSteps)
 157:         for step in 0...fadeSteps {
 158:             DispatchQueue.main.asyncAfter(deadline: .now() + fadeStepDuration * Double(step)) {
 159:                 let fraction = Float(step) / Float(fadeSteps)
 160:                 player.volume = targetVolume * fraction
 161:             }
 162:         }
 163:     }
 164:     /// Detiene la música de fondo.
 165:     func stopBackgroundMusic (duration: TimeInterval = 0.5) {
 166:         guard let player = backgroundMusicPlayer, player.isPlaying else {
 167:             return
 168:         }
 169:         let fadeSteps = 5
 170:         let fadeStepDuration = duration / Double(fadeSteps)
 171:         let originalVolume = player.volume
 172:         for step in 0...fadeSteps {
 173:             DispatchQueue.main.asyncAfter(deadline: .now() + fadeStepDuration * Double(step)) {
 174:                 let fraction = Float(step) / Float(fadeSteps)
 175:                 player.volume = originalVolume * (1 - fraction)
 176:                 if step == fadeSteps {
 177:                     player.stop()
 178:                 }
 179:             }
 180:         }
 181:         print("AudioController: Iniciando fade out de la música de fondo")
 182:     }
 183:     /// Reproduce un efecto de sonido para la pulsación de un botón.
 184:     /// Asegúrate de haber añadido "buttonClick.mp3" al bundle.
 185:     func playButtonSound() {
 186:         guard let url = Bundle.main.url(forResource: "buttonClick", withExtension: "mp3") else {
 187:             print("AudioController: No se encontró el efecto de sonido para botón")
 188:             return
 189:         }
 190:         do {
 191:             let buttonSoundPlayer = try AVAudioPlayer(contentsOf: url)
 192:             buttonSoundPlayer.volume = 0.8
 193:             buttonSoundPlayer.prepareToPlay()
 194:             buttonSoundPlayer.play()
 195:             print("AudioController: Efecto de sonido del botón reproducido")
 196:             // Nota: Este reproductor se libera al salir del método.
 197:         } catch {
 198:             print("AudioController: Error al reproducir el efecto de sonido: \(error)")
 199:         }
 200:     }
 201:     // MARK: - Funciones para detección de notas
 202:     private func updateStability(frequency: Float) {
 203:         if abs(frequency - lastStableFrequency) <= stabilityThreshold {
 204:             if stabilityStartTime == nil {
 205:                 stabilityStartTime = Date()
 206:             }
 207:             stabilityDuration = Date().timeIntervalSince(stabilityStartTime ?? Date())
 208:         } else {
 209:             lastStableFrequency = frequency
 210:             stabilityStartTime = nil
 211:             stabilityDuration = 0
 212:         }
 213:     }
 214:     private func processPitchData(frequency: Float, amplitude: Float) {
 215:         self.smoothedAmplitude = (self.amplitudeSmoothing * self.smoothedAmplitude) + ((1 - self.amplitudeSmoothing) * amplitude)
 216:         let currentTime = Date()
 217:         guard currentTime.timeIntervalSince(lastProcessedTime) >= minimumProcessingInterval else {
 218:             return
 219:         }
 220:         lastProcessedTime = currentTime
 221:         if self.smoothedAmplitude > minimumAmplitude,
 222:            frequency >= minimumFrequency && frequency <= maximumFrequency {
 223:             let tunerData = tunerEngine.processPitch(frequency: frequency, amplitude: self.smoothedAmplitude)
 224:             // Actualiza la UI en tiempo real sin esperar al hold:
 225:             DispatchQueue.main.async {
 226:                 // Por ejemplo, podrías notificar al delegado o actualizar una propiedad publicada
 227:                 // Aquí actualizamos el tunerData para que los nodos que observan esa propiedad se actualicen:
 228:                 self.tunerData = tunerData
 229:                 // Si tienes otro mecanismo para actualizar la UI, hazlo aquí.
 230:             }
 231:             // Luego, si se cumple el hold, dispara el evento de acierto
 232:             let requiredHoldTime = delegate?.audioControllerRequiredHoldTime(self) ?? 1.0
 233:             if tunerEngine.updateHoldDetection(note: tunerData.note,
 234:                                                currentTime: currentTime.timeIntervalSinceReferenceDate,
 235:                                                requiredHoldTime: requiredHoldTime) {
 236:                 DispatchQueue.main.async {
 237:                     print("🎵 Nota validada tras hold: \(tunerData.note) (requiredHoldTime: \(requiredHoldTime) s)")
 238:                     self.delegate?.audioController(self, didDetectNote: tunerData.note, frequency: frequency, amplitude: self.smoothedAmplitude, deviation: tunerData.deviation)
 239:                 }
 240:             }
 241:             updateStability(frequency: frequency)
 242:         } else {
 243:             DispatchQueue.main.async {
 244:                 self.tunerData = .inactive
 245:                 self.stabilityDuration = 0
 246:                 self.delegate?.audioControllerDidDetectSilence(self)
 247:             }
 248:         }
 249:     }
 250:     private init() {
 251:         do {
 252:             try AVAudioSession.sharedInstance().setCategory(.playAndRecord,
 253:                                                             options: [.defaultToSpeaker, .mixWithOthers])
 254:             try AVAudioSession.sharedInstance().setActive(true)
 255:             guard let input = engine.input else {
 256:                 print("Error: No se detectó entrada de audio")
 257:                 return
 258:             }
 259:             mic = input
 260:             silence = Fader(mic, gain: 0)
 261:             engine.output = silence
 262:             pitchTap = PitchTap(mic) { [weak self] frequency, amplitude in
 263:                 guard let self = self else { return }
 264:                 self.processPitchData(frequency: frequency[0], amplitude: amplitude[0])
 265:             }
 266:             try engine.start()
 267:             print("Motor de audio iniciado correctamente")
 268:         } catch {
 269:             print("Error en la inicialización del audio: \(error)")
 270:         }
 271:     }
 272:     var microphonePermissionStatus: Bool {
 273:         AVCaptureDevice.authorizationStatus(for: .audio) == .authorized
 274:     }
 275:     func start() {
 276:         guard mic != nil else {
 277:             print("Error: Input de audio no disponible")
 278:             return
 279:         }
 280:         // Resetear valores al iniciar
 281:         smoothedAmplitude = 0
 282:         stabilityDuration = 0
 283:         lastProcessedTime = Date()
 284:         stabilityStartTime = nil
 285:         lastStableFrequency = 0
 286:         tunerData = .inactive
 287:         pitchTap.start()
 288:     }
 289:     func stop() {
 290:         pitchTap.stop()
 291:         DispatchQueue.main.async {
 292:             self.tunerData = .inactive
 293:             self.stabilityDuration = 0
 294:         }
 295:     }
 296: }
 297: </file>
 298: <file path="MusicBlocks/Audio/TunerEngine.swift">
 299: //
 300: //  TunerEngine.swift
 301: //  MusicBlocks
 302: //
 303: //  Created by Jose R. García on 13/3/25.
 304: //  Actualización: Se añade la lógica de acumulación para el hold de la nota.
 305: //
 306: import Foundation
 307: class TunerEngine {
 308:     static let shared = TunerEngine()
 309:     // MARK: - Types
 310:     struct TunerData {
 311:         let note: String          // Nota con alteración y octava
 312:         let frequency: Float      // Frecuencia en Hz
 313:         let deviation: Double     // Desviación en cents
 314:         let isActive: Bool        // Si hay suficiente amplitud para detectar
 315:         static let inactive = TunerData(note: "-", frequency: 0, deviation: 0, isActive: false)
 316:     }
 317:     // MARK: - Properties
 318:     private let concertPitch: Double = 442.0
 319:     // Propiedades para la acumulación del hold
 320:     private var noteHoldAccumulator: TimeInterval = 0
 321:     private var lastDetectionTime: TimeInterval? = nil
 322:     private var currentStableNote: String = "-"
 323:     // MARK: - Public Methods
 324:     /// Procesa una frecuencia y amplitud para obtener datos de afinación.
 325:     /// Este método se mantiene sin modificaciones ya que su función es la conversión.
 326:     func processPitch(frequency: Float, amplitude: Float) -> TunerData {
 327:         let minAmplitude: Float = 0.05
 328:         guard amplitude > minAmplitude else {
 329:             return .inactive
 330:         }
 331:         let (note, deviation) = processFrequency(frequency)
 332:         return TunerData(
 333:             note: note,
 334:             frequency: frequency,
 335:             deviation: deviation,
 336:             isActive: true
 337:         )
 338:     }
 339:     /// Parsea una nota desde un string.
 340:     func parseNote(_ noteString: String) -> MusicalNote? {
 341:         return MusicalNote.parse(noteString)
 342:     }
 343:     /// Actualiza el acumulador de "hold" para la nota detectada.
 344:     /// - Parameters:
 345:     ///   - note: La nota detectada en este frame.
 346:     ///   - currentTime: El timestamp actual.
 347:     ///   - requiredHoldTime: El tiempo requerido (en segundos) para considerar que la nota se ha mantenido estable.
 348:     /// - Returns: true si el acumulador alcanza o supera el tiempo requerido; false en caso contrario.
 349:     func updateHoldDetection(note: String, currentTime: TimeInterval, requiredHoldTime: TimeInterval) -> Bool {
 350:         if note == currentStableNote {
 351:             if let lastTime = lastDetectionTime {
 352:                 noteHoldAccumulator += (currentTime - lastTime)
 353:             }
 354:         } else {
 355:             currentStableNote = note
 356:             noteHoldAccumulator = 0
 357:         }
 358:         lastDetectionTime = currentTime
 359:         // Mensaje de debug para seguir el acumulador
 360:         print("TunerEngine - Nota detectada: \(note), acumulador de hold: \(noteHoldAccumulator) segundos")
 361:         // Solo se considera válida si la nota no es un silencio ("-")
 362:         if note != "-" && noteHoldAccumulator >= requiredHoldTime {
 363:             print("TunerEngine - Éxito: la nota \(note) se mantuvo estable por \(noteHoldAccumulator) segundos (requerido: \(requiredHoldTime) segundos)")
 364:             noteHoldAccumulator = 0  // Reiniciar el acumulador al alcanzar el tiempo requerido
 365:             return true
 366:         }
 367:         return false
 368:     }
 369:     // MARK: - Private Methods
 370:     private func processFrequency(_ frequency: Float) -> (String, Double) {
 371:         guard frequency > 0 else { return ("-", 0) }
 372:         let actualFrequency = Double(frequency)
 373:         let halfStepsFromA4 = 12 * log2(actualFrequency / concertPitch)
 374:         let roundedHalfSteps = round(halfStepsFromA4)
 375:         let deviation = 100 * (halfStepsFromA4 - roundedHalfSteps)
 376:         let midiNoteNumber = Int(roundedHalfSteps) + 69
 377:         let octave = (midiNoteNumber / 12) - 1
 378:         let noteIndex = ((midiNoteNumber % 12) + 12) % 12
 379:         let (noteName, alteration) = getNoteNameAndAlteration(forMIDINote: noteIndex)
 380:         return ("\(noteName)\(alteration.rawValue)\(octave)", deviation)
 381:     }
 382:     private func getNoteNameAndAlteration(forMIDINote index: Int) -> (String, MusicalNote.Alteration) {
 383:         switch index {
 384:         case 0: return ("DO", .natural)
 385:         case 1: return Bool.random() ? ("DO", .sharp) : ("RE", .flat)
 386:         case 2: return ("RE", .natural)
 387:         case 3: return Bool.random() ? ("RE", .sharp) : ("MI", .flat)
 388:         case 4: return ("MI", .natural)
 389:         case 5: return ("FA", .natural)
 390:         case 6: return Bool.random() ? ("FA", .sharp) : ("SOL", .flat)
 391:         case 7: return ("SOL", .natural)
 392:         case 8: return Bool.random() ? ("SOL", .sharp) : ("LA", .flat)
 393:         case 9: return ("LA", .natural)
 394:         case 10: return Bool.random() ? ("LA", .sharp) : ("SI", .flat)
 395:         case 11: return ("SI", .natural)
 396:         default: return ("", .natural)
 397:         }
 398:     }
 399: }
 400: </file>
 401: <file path="MusicBlocks/Bloques/BlockContentGenerator.swift">
 402: //
 403: //  BlockContentGenerator.swift
 404: //  MusicBlocks
 405: //
 406: //  Created by Jose R. García on 3/3/25.
 407: //
 408: import SpriteKit
 409: /// Este struct agrupa funciones para generar el contenido visual interno de un bloque,
 410: /// es decir, el pentagrama, la clave de sol, la imagen de la nota, los accidentales y las ledger lines.
 411: struct BlockContentGenerator {
 412:     /// Genera el contenido visual de un bloque.
 413:     static func generateBlockContent(
 414:         with style: BlockStyle,
 415:         blockSize: CGSize,
 416:         desiredNote: MusicalNote,
 417:         baseNoteX: CGFloat,
 418:         baseNoteY: CGFloat,
 419:         leftMargin: CGFloat = 30,
 420:         rightMargin: CGFloat = 30
 421:     ) -> SKNode {
 422:         let contentNode = SKNode()
 423:         // MARK: PENTAGRAMA
 424:         let staffPath = CGMutablePath()
 425:         let lineSpacing: CGFloat = 12
 426:         for i in 0..<5 {
 427:             let y = 24 - CGFloat(i) * lineSpacing
 428:             staffPath.move(to: CGPoint(x: -blockSize.width/2 + leftMargin, y: y))
 429:             staffPath.addLine(to: CGPoint(x: blockSize.width/2 - rightMargin, y: y))
 430:         }
 431:         let staffLines = SKShapeNode(path: staffPath)
 432:         staffLines.strokeColor = .black
 433:         staffLines.lineWidth = 2
 434:         staffLines.zPosition = 1
 435:         contentNode.addChild(staffLines)
 436:         // MARK: CLAVE DE SOL
 437:         let trebleClef = SKSpriteNode(imageNamed: "trebleClef")
 438:         trebleClef.size = CGSize(width: 50, height: 95)
 439:         trebleClef.position = CGPoint(x: -blockSize.width/2 + leftMargin + 25, y: -2)
 440:         trebleClef.zPosition = 2
 441:         contentNode.addChild(trebleClef)
 442:         // MARK: NOTA
 443:         let noteOffset = getNoteOffset(for: desiredNote)
 444:         let notePosition = CGPoint(
 445:             x: baseNoteX,
 446:             y: baseNoteY + noteOffset.y
 447:         )
 448:         let noteImage = SKSpriteNode(imageNamed: "wholeNote")
 449:         noteImage.size = CGSize(width: 23, height: 23)
 450:         noteImage.position = notePosition
 451:         noteImage.zPosition = 3
 452:         contentNode.addChild(noteImage)
 453:         // MARK: ALTERACIONES
 454:         if desiredNote.alteration != .natural {
 455:             let accidentalImage = SKSpriteNode(imageNamed: getAccidentalImageName(for: desiredNote.alteration))
 456:             accidentalImage.size = CGSize(width: 45, height: 80)
 457:             accidentalImage.position = CGPoint(x: notePosition.x - 23, y: notePosition.y)
 458:             accidentalImage.zPosition = 3
 459:             contentNode.addChild(accidentalImage)
 460:         }
 461:         // MARK: LÍNEAS ADICIONALES
 462:         addLedgerLines(for: notePosition.y, in: contentNode, for: desiredNote)
 463:         print("Contenido del bloque generado para nota: \(desiredNote.fullName)")
 464:         return contentNode
 465:     }
 466:     private static func getNoteOffset(for note: MusicalNote) -> CGPoint {
 467:            // Tabla que mapea la combinación de nombre de nota y octava a su offset vertical
 468:            let baseOffsets: [String: CGFloat] = [
 469:                "DO": -36,
 470:                "RE": -30,
 471:                "MI": -24,
 472:                "FA": -18,
 473:                "SOL": -12,
 474:                "LA": -6,
 475:                "SI": 0
 476:            ]
 477:            guard let baseOffset = baseOffsets[note.name] else {
 478:                return .zero
 479:            }
 480:            // Ajustar el offset según la octava
 481:            let octaveOffset = CGFloat(note.octave - 4) * 42
 482:            return CGPoint(x: 0, y: baseOffset + octaveOffset)
 483:        }
 484:     private static func getAccidentalImageName(for alteration: MusicalNote.Alteration) -> String {
 485:         switch alteration {
 486:         case .sharp:
 487:             return "sharp"
 488:         case .flat:
 489:             return "flat"
 490:         case .natural:
 491:             return ""  // No debería llegar aquí, pero por completitud
 492:         }
 493:     }
 494:     /// Dibuja ledger lines (líneas adicionales) si la nota se sale del pentagrama.
 495:     ///
 496:     /// - Parameters:
 497:     ///   - noteY: La posición Y de la nota.
 498:     ///   - node: El nodo al que se añadirán las ledger lines.
 499:     ///   - note: La nota (MusicalNote) para la cual se determinarán las líneas adicionales.
 500:     private static func addLedgerLines(for noteY: CGFloat, in node: SKNode, for note: MusicalNote) {
 501:         let staffTop: CGFloat = 30
 502:         let staffBottom: CGFloat = -30
 503:         let ledgerLineWidth: CGFloat = 30
 504:         let ledgerLineThickness: CGFloat = 2.0
 505:         func createLedgerLine(at ledgerY: CGFloat) {
 506:             let path = CGMutablePath()
 507:             path.move(to: CGPoint(x: -ledgerLineWidth / 2, y: ledgerY))
 508:             path.addLine(to: CGPoint(x: ledgerLineWidth / 2, y: ledgerY))
 509:             let ledgerLine = SKShapeNode(path: path)
 510:             ledgerLine.strokeColor = .black
 511:             ledgerLine.lineWidth = ledgerLineThickness
 512:             ledgerLine.zPosition = 3.5
 513:             node.addChild(ledgerLine)
 514:         }
 515:         // Para "Do6" y "La3", dibujamos dos ledger lines.
 516:         let isHigh = note.name == "DO" && note.octave == 6
 517:                 let isLow = note.name == "LA" && note.octave == 3
 518:                 if isHigh {
 519:                     createLedgerLine(at: staffTop + 6)
 520:                     createLedgerLine(at: staffTop + 18)
 521:                 } else if isLow {
 522:                     createLedgerLine(at: staffBottom - 6)
 523:                     createLedgerLine(at: staffBottom - 18)
 524:                 } else {
 525:                     if noteY > staffTop {
 526:                         createLedgerLine(at: staffTop + 6)
 527:                     } else if noteY < staffBottom {
 528:                         createLedgerLine(at: staffBottom - 6)
 529:                     }
 530:                 }
 531:             }
 532:         }
 533: #if DEBUG
 534: import SwiftUI
 535: // Vista previa del contenido de un bloque
 536: struct BlockPreview: PreviewProvider {
 537:     static var previews: some View {
 538:         BlockPreviewView()
 539:             .frame(width: 300, height: 200)
 540:             .previewLayout(.fixed(width: 300, height: 200))
 541:             .preferredColorScheme(.light)
 542:     }
 543: }
 544: // Vista del bloque para la preview
 545: struct BlockPreviewView: View {
 546:     var body: some View {
 547:         SpriteView(scene: createPreviewScene())
 548:     }
 549:     private func createPreviewScene() -> SKScene {
 550:         let scene = SKScene(size: CGSize(width: 300, height: 200))
 551:         scene.backgroundColor = .white
 552:         // Crear un bloque de ejemplo
 553:         let blockSize = CGSize(width: 270, height: 110)
 554:         let exampleNote = MusicalNote(name: "LA", alteration: .sharp, octave: 4)
 555:         // Crear el contenedor del bloque
 556:         let blockNode = SKNode()
 557:         blockNode.position = CGPoint(x: scene.size.width/2, y: scene.size.height/2)
 558:         // Crear el fondo del bloque
 559:         let background = SKShapeNode(rectOf: blockSize, cornerRadius: 15)
 560:         background.fillColor = .white
 561:         background.strokeColor = .black
 562:         background.lineWidth = 2
 563:         blockNode.addChild(background)
 564:         // Generar el contenido (pentagrama, nota, etc.)
 565:         let content = BlockContentGenerator.generateBlockContent(
 566:             with: .defaultBlock,
 567:             blockSize: blockSize,
 568:             desiredNote: exampleNote,
 569:             baseNoteX: 0,
 570:             baseNoteY: 0
 571:         )
 572:         blockNode.addChild(content)
 573:         scene.addChild(blockNode)
 574:         return scene
 575:     }
 576: }
 577: // Vista previa de diferentes notas
 578: struct BlockNotesPreview: PreviewProvider {
 579:     static var previews: some View {
 580:         VStack(spacing: 20) {
 581:             Text("Ejemplos de Bloques Musicales")
 582:                 .font(.headline)
 583:             VStack(spacing: 20) {
 584:                 BlockNoteView(note: MusicalNote(name: "DO", alteration: .natural, octave: 6))
 585:                     .frame(width: 270, height: 110)
 586:                 BlockNoteView(note: MusicalNote(name: "FA", alteration: .sharp, octave: 4))
 587:                     .frame(width: 270, height: 110)
 588:             }
 589:             VStack(spacing: 20) {
 590:                 BlockNoteView(note: MusicalNote(name: "LA", alteration: .flat, octave: 4))
 591:                     .frame(width: 270, height: 110)
 592:                 BlockNoteView(note: MusicalNote(name: "LA", alteration: .natural, octave: 3))
 593:                     .frame(width: 270, height: 110)
 594:             }
 595:         }
 596:         .padding()
 597:         .background(Color.white.opacity(0.1))
 598:         .previewLayout(.fixed(width: 600, height: 400))
 599:     }
 600: }
 601: // Vista individual de un bloque con una nota específica
 602: struct BlockNoteView: View {
 603:     let note: MusicalNote
 604:     var body: some View {
 605:         SpriteView(scene: createNoteScene())
 606:             .border(Color.gray, width: 1)
 607:     }
 608:     private func createNoteScene() -> SKScene {
 609:         let scene = SKScene(size: CGSize(width: 270, height: 110))
 610:         scene.backgroundColor = .white
 611:         let blockNode = SKNode()
 612:         blockNode.position = CGPoint(x: scene.size.width/2, y: scene.size.height/2)
 613:         let background = SKShapeNode(rectOf: scene.size, cornerRadius: 15)
 614:         background.fillColor = .white
 615:         background.strokeColor = .black
 616:         background.lineWidth = 2
 617:         blockNode.addChild(background)
 618:         let content = BlockContentGenerator.generateBlockContent(
 619:             with: .iceBlock,
 620:             blockSize: scene.size,
 621:             desiredNote: note,
 622:             baseNoteX: 0,
 623:             baseNoteY: 0
 624:         )
 625:         blockNode.addChild(content)
 626:         scene.addChild(blockNode)
 627:         return scene
 628:     }
 629: }
 630: #endif
 631: </file>
 632: <file path="MusicBlocks/Bloques/BlocksManager.swift">
 633: //
 634: //  BlocksManager.swift
 635: //  MusicBlocks
 636: //
 637: //  Creado por Jose R. García el 14/3/25.
 638: //  Versión modificada: Se han añadido mensajes de debug para seguir el flujo de todas las funciones.
 639: //
 640: import SpriteKit
 641: class BlocksManager {
 642:     // MARK: - Properties
 643:     private var blockInfos: [BlockInfo] = []
 644:     private var blocks: [SKNode] = []
 645:     private let blockSize: CGSize
 646:     private let blockSpacing: CGFloat
 647:     private weak var mainAreaNode: SKNode?
 648:     private var mainAreaHeight: CGFloat = 0
 649:     private let gameManager = GameManager.shared
 650:     // Para controlar la generación de bloques
 651:         private var spawnAction: SKAction?
 652:         private var isGeneratingBlocks: Bool = false
 653:         // Ahora interpretamos estos como tiempos en SEGUNDOS:
 654:         // spawnInterval = “tiempo entre bloques”
 655:         // spawnIntervalDecrement = “segundos que restamos tras cada bloque”
 656:         private var spawnInterval: TimeInterval
 657:         private var spawnIntervalDecrement: TimeInterval
 658:     // MARK: - Constants
 659:         private struct Constants {
 660:             static let initialDelay: TimeInterval = 1.0
 661:             static let minSpawnInterval: TimeInterval = 1.5
 662:         }
 663:         // MARK: - Initialization
 664:         init(blockSize: CGSize = CGSize(width: 280, height: 120),
 665:              blockSpacing: CGFloat = 1.0,
 666:              mainAreaNode: SKNode?,
 667:              mainAreaHeight: CGFloat) {
 668:             self.blockSize = blockSize
 669:             self.blockSpacing = blockSpacing
 670:             self.mainAreaNode = mainAreaNode
 671:             self.mainAreaHeight = mainAreaHeight
 672:             // Leemos la “velocidad” del nivel, pero la usamos como spawnInterval (segundos).
 673:             if let fallingSpeed = GameManager.shared.currentLevel?.fallingSpeed {
 674:                 // Por ejemplo: initial=8.0 => 8s entre bloques, increment=2.0 => restar 2s cada bloque
 675:                 self.spawnInterval = fallingSpeed.initial
 676:                 self.spawnIntervalDecrement = fallingSpeed.increment
 677:             } else {
 678:                 // Valores por defecto
 679:                 self.spawnInterval = 4.0
 680:                 self.spawnIntervalDecrement = 0.0
 681:             }
 682:             print("🔧 BlocksManager inicializado. blockSize: \(blockSize), " +
 683:                   "mainAreaHeight: \(mainAreaHeight), " +
 684:                   "spawnInterval inicial: \(spawnInterval) s, " +
 685:                   "decremento: \(spawnIntervalDecrement) s")
 686:         }
 687:     // MARK: - Iniciando generación de bloques
 688:     func startBlockGeneration() {
 689:         print("▶️ startBlockGeneration llamado.")
 690:         guard !isGeneratingBlocks else {
 691:             print("ℹ️ La generación de bloques ya está en curso.")
 692:             return
 693:         }
 694:         isGeneratingBlocks = true
 695:         // Esperamos un delay inicial (opcional)
 696:         let initialDelay = SKAction.wait(forDuration: 1.0) // Por ejemplo 1s
 697:         // Cuando acabe el delay, llamamos a spawnLoop()
 698:         let beginAction = SKAction.run { [weak self] in
 699:             self?.spawnLoop()
 700:         }
 701:         let sequence = SKAction.sequence([initialDelay, beginAction])
 702:         mainAreaNode?.run(sequence)
 703:         print("✅ Generación de bloques iniciada - spawnInterval: \(spawnInterval) s")
 704:     }
 705:     /// Bucle “recursivo” que genera 1 bloque, actualiza el spawnInterval
 706:     /// y programa la siguiente aparición.
 707:     private func spawnLoop() {
 708:         // 1) Verificar si seguimos generando
 709:         guard isGeneratingBlocks else {
 710:             print("🛑 Generación detenida, no se continúa el loop.")
 711:             return
 712:         }
 713:         // 2) Generar el bloque
 714:         spawnBlock()
 715:         // 3) Ajustar spawnInterval (acelerar)
 716:         let newInterval = max(spawnInterval - spawnIntervalDecrement, Constants.minSpawnInterval)
 717:         spawnInterval = newInterval
 718:         print("🚀 Nuevo spawnInterval = \(spawnInterval) s (restado \(spawnIntervalDecrement))")
 719:         // 4) Programar la siguiente aparición usando el spawnInterval actual
 720:         let wait = SKAction.wait(forDuration: spawnInterval)
 721:         let nextCall = SKAction.run { [weak self] in
 722:             self?.spawnLoop()
 723:         }
 724:         let sequence = SKAction.sequence([wait, nextCall])
 725:         mainAreaNode?.run(sequence)
 726:     }
 727:     /// Detener la generación
 728:     func stopBlockGeneration() {
 729:         print("⏹️ stopBlockGeneration llamado.")
 730:         guard isGeneratingBlocks else {
 731:             print("ℹ️ La generación de bloques ya está detenida.")
 732:             return
 733:         }
 734:         isGeneratingBlocks = false
 735:         // También puedes remover todas las acciones del mainAreaNode si quieres
 736:         mainAreaNode?.removeAllActions()
 737:         print("✅ Generación de bloques detenida.")
 738:     }
 739:     // MARK: - Block Generation
 740:     private func generateNote(for blockConfig: Block) -> MusicalNote? {
 741:         guard let randomNoteString = blockConfig.notes.randomElement() else {
 742:             print("❌ Error: No hay notas disponibles en la configuración del bloque")
 743:             return nil
 744:         }
 745:         print("📢 Intentando parsear nota: \(randomNoteString)")
 746:         if let note = MusicalNote.parseSpanishFormat(randomNoteString) {
 747:             print("✅ Nota generada correctamente: \(note.fullName)")
 748:             return note
 749:         } else {
 750:             print("❌ Error al parsear la nota: \(randomNoteString)")
 751:             return nil
 752:         }
 753:     }
 754:     private func createBlock() -> SKNode {
 755:         print("➡️ Creando nuevo bloque...")
 756:         guard let currentLevel = gameManager.currentLevel else {
 757:             print("❌ Error: No hay nivel actual")
 758:             return createDefaultBlock()
 759:         }
 760:         let blockNode = SKNode()
 761:         blockNode.zPosition = 2
 762:         let allowedStyles = currentLevel.allowedStyles
 763:         print("📝 Estilos permitidos: \(allowedStyles)")
 764:         guard let randomStyle = allowedStyles.randomElement() else {
 765:             print("❌ Error: No hay estilos permitidos")
 766:             return createDefaultBlock()
 767:         }
 768:         guard let config = currentLevel.blocks[randomStyle] else {
 769:             print("❌ Error: No se encontró configuración para el bloque \(randomStyle)")
 770:             return createDefaultBlock()
 771:         }
 772:         guard let randomNoteString = config.notes.randomElement(),
 773:               let note = MusicalNote.parseSpanishFormat(randomNoteString),
 774:               let blockStyle = getBlockStyle(for: randomStyle) else {
 775:             print("❌ Error: Falló la generación del bloque, usando bloque por defecto.")
 776:             return createDefaultBlock()
 777:         }
 778:         // Crear contenedor y contenido visual
 779:         let container = createBlockContainer(with: blockStyle)
 780:         blockNode.addChild(container)
 781:         let contentNode = BlockContentGenerator.generateBlockContent(
 782:             with: blockStyle,
 783:             blockSize: blockSize,
 784:             desiredNote: note,
 785:             baseNoteX: 5,
 786:             baseNoteY: 0,
 787:             leftMargin: 30,
 788:             rightMargin: 30
 789:         )
 790:         contentNode.position = .zero
 791:         contentNode.zPosition = 3
 792:         blockNode.addChild(contentNode)
 793:         // Guardar metadata del bloque
 794:         let userData = NSMutableDictionary()
 795:         userData.setValue(note.fullName, forKey: "noteName")
 796:         userData.setValue(randomStyle, forKey: "blockStyle")
 797:         userData.setValue(config.requiredHits, forKey: "requiredHits")
 798:         userData.setValue(config.requiredTime, forKey: "requiredTime")
 799:         blockNode.userData = userData
 800:         print("✅ Bloque creado con nota: \(note.fullName) y estilo: \(randomStyle)")
 801:         return blockNode
 802:     }
 803:     // MARK: - Block Creation Methods
 804:     func spawnBlock() {
 805:             print("➡️ spawnBlock llamado.")
 806:             guard let mainAreaNode = mainAreaNode,
 807:                   isGeneratingBlocks else {
 808:                 print("❌ No se pueden generar bloques: generación detenida o mainAreaNode es nil")
 809:                 return
 810:             }
 811:             // Verificar espacio
 812:             if let firstBlock = blocks.first {
 813:                 let topLimit = mainAreaHeight/2 - blockSize.height/2
 814:                 let firstBlockTopEdge = firstBlock.position.y + blockSize.height/2
 815:                 if abs(firstBlockTopEdge - topLimit) < blockSpacing {
 816:                     print("⏸️ Esperando espacio para nuevo bloque.")
 817:                     return
 818:                 }
 819:             }
 820:             let newBlock = createBlock()
 821:             if let blockInfo = createBlockInfo(for: newBlock) {
 822:                 let startY = mainAreaHeight/2 - blockSize.height/2
 823:                 newBlock.position = CGPoint(x: 0, y: startY)
 824:                 mainAreaNode.addChild(newBlock)
 825:                 blocks.insert(newBlock, at: 0)
 826:                 blockInfos.insert(blockInfo, at: 0)
 827:                 print("✅ Bloque añadido en posición Y: \(startY)")
 828:                 updateBlockPositions()
 829:             } else {
 830:                 print("❌ Error al crear la metadata del bloque.")
 831:             }
 832:         }
 833:     private func createBlockInfo(for block: SKNode) -> BlockInfo? {
 834: //        print("📋 Creando BlockInfo para bloque.")
 835:         guard let userData = block.userData,
 836:               let noteData = userData.value(forKey: "noteName") as? String,
 837:               let styleData = userData.value(forKey: "blockStyle") as? String,
 838:               let config = gameManager.getBlockConfig(for: styleData),
 839:               let requiredHits = userData.value(forKey: "requiredHits") as? Int,
 840:               let requiredTime = userData.value(forKey: "requiredTime") as? TimeInterval else {
 841:             print("❌ Error: Bloque creado sin datos válidos")
 842:             return nil
 843:         }
 844:         let info = BlockInfo(
 845:             node: block,
 846:             note: noteData,
 847:             style: styleData,
 848:             config: config,
 849:             requiredHits: requiredHits,
 850:             requiredTime: requiredTime
 851:         )
 852:         print("✅ BlockInfo creado: nota \(noteData), estilo \(styleData), requiredHits: \(requiredHits), requiredTime: \(requiredTime)")
 853:         return info
 854:     }
 855:     // MARK: - Block Visual Components
 856:     private func createBlockContainer(with style: BlockStyle) -> SKNode {
 857: //        print("🖼️ Creando contenedor para bloque con estilo: \(style)")
 858:         let container = SKNode()
 859:         container.zPosition = 0
 860:         if let shadowColor = style.shadowColor,
 861:            let shadowOffset = style.shadowOffset,
 862:            let shadowBlur = style.shadowBlur {
 863:             let shadowNode = createShadowNode(
 864:                 color: shadowColor,
 865:                 offset: shadowOffset,
 866:                 blur: shadowBlur,
 867:                 cornerRadius: style.cornerRadius
 868:             )
 869:             container.addChild(shadowNode)
 870: //            print("🖼️ Sombra añadida al contenedor.")
 871:         }
 872:         let background = createBackground(with: style)
 873:         container.addChild(background)
 874: //        print("🖼️ Fondo añadido al contenedor.")
 875:         return container
 876:     }
 877:     private func createShadowNode(color: SKColor, offset: CGSize, blur: CGFloat, cornerRadius: CGFloat) -> SKNode {
 878: //        print("🖌️ Creando shadowNode con color: \(color), offset: \(offset), blur: \(blur)")
 879:         let shadowNode = SKEffectNode()
 880:         shadowNode.shouldRasterize = true
 881:         shadowNode.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": blur])
 882:         shadowNode.zPosition = 1
 883:         let shadowShape = SKShapeNode(rectOf: blockSize, cornerRadius: cornerRadius)
 884:         shadowShape.fillColor = color
 885:         shadowShape.strokeColor = .clear
 886:         shadowShape.alpha = 0.5
 887:         shadowNode.addChild(shadowShape)
 888:         shadowNode.position = CGPoint(x: offset.width, y: offset.height)
 889:         return shadowNode
 890:     }
 891:     private func createBackground(with style: BlockStyle) -> SKNode {
 892: //        print("🖌️ Creando background para bloque con estilo: \(style)")
 893:         let background = SKShapeNode(rectOf: blockSize, cornerRadius: style.cornerRadius)
 894:         background.fillColor = style.backgroundColor
 895:         background.strokeColor = style.borderColor
 896:         background.lineWidth = style.borderWidth
 897:         background.zPosition = 2
 898:         if let texture = style.fillTexture {
 899:             background.fillTexture = texture
 900:             background.alpha = style.textureOpacity
 901: //            print("🖼️ Texture aplicada al background.")
 902:         }
 903:         return background
 904:     }
 905:     // MARK: - Block Position Management
 906:     private func updateBlockPositions() {
 907:         print("↕️ Actualizando posiciones de \(blocks.count) bloques.")
 908:         let moveDistance = blockSize.height + blockSpacing
 909:         let moveDuration = 0.5
 910:         for (index, block) in blocks.enumerated() {
 911:             // Calcular la posición final para cada bloque
 912:             let targetY = (mainAreaHeight/2) - (blockSize.height/2) - (moveDistance * CGFloat(index))
 913:             print("   Bloque \(index): moviéndose a Y = \(targetY)")
 914:             // Mover el bloque a su posición con una animación suave
 915:             let moveToPosition = SKAction.moveTo(y: targetY, duration: moveDuration)
 916:             moveToPosition.timingMode = .easeInEaseOut
 917:             // Detener cualquier acción previa
 918:             block.removeAllActions()
 919:             // Aplicar solo el movimiento de posicionamiento
 920:             block.run(moveToPosition)
 921:         }
 922:     }
 923:     // MARK: - Game State Checks
 924:     func hasBlocksBelowLimit() -> Bool {
 925:         let bottomLimit = -mainAreaHeight/2
 926:         let result = blocks.contains { block in
 927:             let blockBottom = block.position.y - blockSize.height/2
 928:             let hasReachedLimit = blockBottom <= bottomLimit
 929:             if hasReachedLimit {
 930:                 print("⚠️ Bloque ha alcanzado la zona de peligro. blockBottom: \(blockBottom), bottomLimit: \(bottomLimit)")
 931:             }
 932:             return hasReachedLimit
 933:         }
 934:         return result
 935:     }
 936:     // MARK: - Public Interface
 937:     var currentBlocks: [SKNode] { blocks }
 938:     var blockCount: Int { blocks.count }
 939:     func clearBlocks() {
 940:         print("🧹 Limpiando bloques...")
 941:         stopBlockGeneration()
 942:         for block in blocks {
 943:             block.removeFromParent()
 944:         }
 945:         blocks.removeAll()
 946:         blockInfos.removeAll()
 947:         print("🧹 Bloques eliminados.")
 948:     }
 949:     func getCurrentBlock() -> BlockInfo? {
 950:         print("🔍 Consultando bloque actual...")
 951:         if let current = blockInfos.last {
 952:             print("🔍 Bloque actual: nota \(current.note), estilo \(current.style)")
 953:         } else {
 954:             print("🔍 No hay bloque actual.")
 955:         }
 956:         return blockInfos.last
 957:     }
 958:     // MARK: - Block Style Management
 959:     private func selectBlockStyleBasedOnWeights(from blocks: [String: Block]) -> BlockStyle {
 960:         print("🔀 Seleccionando estilo basado en pesos...")
 961:         var weightedStyles: [(BlockStyle, Double)] = []
 962:         for (styleName, blockConfig) in blocks {
 963:             if let style = getBlockStyle(for: styleName) {
 964:                 weightedStyles.append((style, blockConfig.weight))
 965:                 print("   Estilo \(styleName) con peso \(blockConfig.weight) añadido.")
 966:             }
 967:         }
 968:         guard !weightedStyles.isEmpty else {
 969:             print("⚠️ No se encontraron estilos con peso. Se retorna defaultBlock.")
 970:             return .defaultBlock
 971:         }
 972:         let totalWeight = weightedStyles.reduce(0) { $0 + $1.1 }
 973:         let randomValue = Double.random(in: 0..<totalWeight)
 974:         print("   Total de peso: \(totalWeight), valor aleatorio: \(randomValue)")
 975:         var accumulatedWeight = 0.0
 976:         for (style, weight) in weightedStyles {
 977:             accumulatedWeight += weight
 978:             if randomValue < accumulatedWeight {
 979:                 print("   Estilo seleccionado: \(style)")
 980:                 return style
 981:             }
 982:         }
 983:         print("   Estilo seleccionado por defecto: \(weightedStyles[0].0)")
 984:         return weightedStyles[0].0
 985:     }
 986:     private func getBlockStyle(for styleName: String) -> BlockStyle? {
 987:         print("🔍 Buscando estilo: \(styleName)")
 988:         switch styleName {
 989:         case "defaultBlock": return .defaultBlock
 990:         case "iceBlock": return .iceBlock
 991:         case "hardIceBlock": return .hardiceBlock
 992:         case "ghostBlock": return .ghostBlock
 993:         case "changingBlock": return .changingBlock
 994:         default:
 995:             print("⚠️ Estilo no reconocido: \(styleName)")
 996:             return nil
 997:         }
 998:     }
 999:     private func createDefaultBlock() -> SKNode {
1000:         print("❓ Creando bloque por defecto.")
1001:         let blockNode = SKNode()
1002:         let style = BlockStyle.defaultBlock
1003:         let container = createBlockContainer(with: style)
1004:         blockNode.addChild(container)
1005:         return blockNode
1006:     }
1007:     // MARK: - Block State Management
1008:     func getCurrentNote() -> String? {
1009:         let note = blocks.first?.userData?.value(forKey: "noteName") as? String
1010:         print("🔍 Nota actual: \(note ?? "ninguna")")
1011:         return note
1012:     }
1013:     func removeLastBlock() {
1014:         print("🗑️ Eliminando último bloque...")
1015:         guard let lastBlock = blocks.last,
1016:               !blockInfos.isEmpty else {
1017:             print("⚠️ No hay bloque para eliminar.")
1018:             return
1019:         }
1020:         let fadeOut = SKAction.fadeOut(withDuration: 0.3)
1021:         let scaleDown = SKAction.scale(to: 0.1, duration: 0.3)
1022:         let group = SKAction.group([fadeOut, scaleDown])
1023:         let remove = SKAction.removeFromParent()
1024:         let sequence = SKAction.sequence([group, remove])
1025:         lastBlock.run(sequence) { [weak self] in
1026:             guard let self = self else { return }
1027:             print("🗑️ Bloque eliminado. Actualizando lista de bloques...")
1028:             self.blocks.removeLast()
1029:             self.blockInfos.removeLast()
1030:             self.updateBlockPositions()
1031:         }
1032:     }
1033:     // MARK: - Block Progress Management
1034:     func updateCurrentBlockProgress(hitTime: Date) -> Bool {
1035:         print("⏱️ updateCurrentBlockProgress llamado a las \(hitTime)")
1036:         guard let index = blockInfos.indices.last else {
1037:             print("⚠️ No hay bloque actual para actualizar.")
1038:             return false
1039:         }
1040:         var currentInfo = blockInfos[index]
1041:         print("   Bloque actual: nota \(currentInfo.note), currentHits: \(currentInfo.currentHits)")
1042:         if currentInfo.holdStartTime == nil {
1043:             currentInfo.holdStartTime = hitTime
1044:             blockInfos[index] = currentInfo
1045:             print("   Se inicia el hold del bloque a \(hitTime)")
1046:         }
1047:         let holdDuration = Date().timeIntervalSince(currentInfo.holdStartTime ?? Date())
1048:         print("   Duración del hold: \(holdDuration) (requerida: \(currentInfo.requiredTime))")
1049:         if holdDuration >= currentInfo.requiredTime {
1050:             currentInfo.currentHits += 1
1051:             print("   Hit registrado. currentHits ahora: \(currentInfo.currentHits)")
1052:             currentInfo.holdStartTime = nil
1053:             blockInfos[index] = currentInfo
1054:             if currentInfo.currentHits >= currentInfo.requiredHits {
1055:                 print("   Requisitos completos (hits: \(currentInfo.currentHits), requeridos: \(currentInfo.requiredHits)). Se eliminará el bloque.")
1056:                 removeLastBlock()
1057:                 return true
1058:             }
1059:         }
1060:         return false
1061:     }
1062:     func resetCurrentBlockProgress() {
1063:         print("🔄 Reset current block progress")
1064:         guard let index = blockInfos.indices.last else {
1065:             print("⚠️ No hay bloque actual para resetear.")
1066:             return
1067:         }
1068:         var currentInfo = blockInfos[index]
1069:         currentInfo.currentHits = 0
1070:         currentInfo.holdStartTime = nil
1071:         blockInfos[index] = currentInfo
1072:         print("   Progreso del bloque reseteado.")
1073:     }
1074: }
1075: </file>
1076: <file path="MusicBlocks/Bloques/BlockStyle.swift">
1077: //
1078: //  BlockStyle.swift
1079: //  MusicBlocks
1080: //
1081: //  Created by Jose R. García on 3/3/25.
1082: //
1083: import SpriteKit
1084: struct BlockStyle {
1085:     // Identificador y propiedades básicas
1086:     let name: String
1087:     // Relleno y borde
1088:     let backgroundColor: SKColor
1089:     let borderColor: SKColor
1090:     let borderWidth: CGFloat
1091:     let cornerRadius: CGFloat
1092:     // Sombra (opcional)
1093:     let shadowColor: SKColor?
1094:     let shadowOffset: CGSize?
1095:     let shadowBlur: CGFloat?
1096:     // Textura
1097:     let fillTexture: SKTexture?
1098:     let textureOpacity: CGFloat
1099:     let textureScale: CGFloat
1100:     // Comportamiento especial (opcional)
1101:     let specialBehavior: SpecialBehavior?
1102:     enum SpecialBehavior {
1103:         case ghost(fadeOutAlpha: CGFloat, fadeInAlpha: CGFloat, duration: TimeInterval)
1104:         case changing(changeInterval: TimeInterval)
1105:         case explosive(holdTime: TimeInterval)
1106:     }
1107: }
1108: extension BlockStyle {
1109:     static let defaultBlock = BlockStyle(
1110:         name: "defaultBlock",
1111:         backgroundColor: .white,
1112:         borderColor: .black,
1113:         borderWidth: 3.0,
1114:         cornerRadius: 20.0,
1115:         shadowColor: .gray,
1116:         shadowOffset: CGSize(width: 3, height: -3),
1117:         shadowBlur: 4.0,
1118:         fillTexture: nil,
1119:         textureOpacity: 1.0,
1120:         textureScale: 1.0,
1121:         specialBehavior: nil
1122:     )
1123:     static let iceBlock = BlockStyle(
1124:         name: "iceBlock",
1125:         backgroundColor: SKColor(red: 0.8, green: 0.9, blue: 1.0, alpha: 0.5),
1126:         borderColor: SKColor(red: 0.5, green: 0.7, blue: 0.9, alpha: 1.0),
1127:         borderWidth: 3.0,
1128:         cornerRadius: 20.0,
1129:         shadowColor: SKColor.blue,
1130:         shadowOffset: CGSize(width: 2, height: -2),
1131:         shadowBlur: 4.0,
1132:         fillTexture: SKTexture(imageNamed: "iceTexture4"),
1133:         textureOpacity: 0.5,
1134:         textureScale: 1.0,
1135:         specialBehavior: nil
1136:     )
1137:     static let hardiceBlock = BlockStyle(
1138:         name: "hardiceBlock",
1139:         backgroundColor: SKColor(red: 0.6, green: 0.8, blue: 1.0, alpha: 1.0),
1140:         borderColor: SKColor.blue,
1141:         borderWidth: 3.0,
1142:         cornerRadius: 20.0,
1143:         shadowColor: SKColor.darkGray,
1144:         shadowOffset: CGSize(width: 3, height: -3),
1145:         shadowBlur: 3.0,
1146:         fillTexture: SKTexture(imageNamed: "iceTexture3"),
1147:         textureOpacity: 0.2,
1148:         textureScale: 1.0,
1149:         specialBehavior: nil
1150:     )
1151:     static let ghostBlock = BlockStyle(
1152:         name: "ghostBlock",
1153:         backgroundColor: SKColor(white: 0.9, alpha: 0.5),
1154:         borderColor: SKColor(white: 0.8, alpha: 0.7),
1155:         borderWidth: 3.0,
1156:         cornerRadius: 20.0,
1157:         shadowColor: nil,
1158:         shadowOffset: nil,
1159:         shadowBlur: nil,
1160:         fillTexture: SKTexture(imageNamed: "ghostTexture"),
1161:         textureOpacity: 1.0,
1162:         textureScale: 1.0,
1163:         specialBehavior: .ghost(fadeOutAlpha: 0.2, fadeInAlpha: 0.7, duration: 0.5)
1164:     )
1165:     static let changingBlock = BlockStyle(
1166:         name: "changingBlock",
1167:         backgroundColor: SKColor(red: 0.8, green: 0.6, blue: 1.0, alpha: 1.0),
1168:         borderColor: SKColor.magenta,
1169:         borderWidth: 3.0,
1170:         cornerRadius: 20.0,
1171:         shadowColor: SKColor.purple,
1172:         shadowOffset: CGSize(width: 2, height: -2),
1173:         shadowBlur: 4.0,
1174:         fillTexture: SKTexture(imageNamed: "wavesTexture"),
1175:         textureOpacity: 1.0,
1176:         textureScale: 1.0,
1177:         specialBehavior: .changing(changeInterval: 1.0)
1178:     )
1179:     static let explosiveBlock = BlockStyle(
1180:         name: "explosiveBlock",
1181:         backgroundColor: SKColor(red: 1.0, green: 0.5, blue: 0.0, alpha: 1.0),
1182:         borderColor: SKColor.red,
1183:         borderWidth: 3.0,
1184:         cornerRadius: 20.0,
1185:         shadowColor: SKColor.red,
1186:         shadowOffset: CGSize(width: 4, height: -4),
1187:         shadowBlur: 6.0,
1188:         fillTexture: SKTexture(imageNamed: "explosionTexture"),
1189:         textureOpacity: 1.0,
1190:         textureScale: 1.0,
1191:         specialBehavior: .explosive(holdTime: 4.0)
1192:     )
1193: }
1194: </file>
1195: <file path="MusicBlocks/Bloques/MusicalNote.swift">
1196: //
1197: //  MusicalNote.swift
1198: //  MusicBlocks
1199: //
1200: //  Created by Jose R. García on 3/3/25.
1201: //
1202: import CoreGraphics
1203: import Foundation
1204: /// Sistema unificado para la gestión de notas musicales
1205: struct MusicalNote: Equatable, Identifiable {
1206:     // MARK: - Types
1207:     enum Alteration: String {
1208:         case sharp = "#"    /// Sostenido
1209:         case flat = "♭"     /// Bemol
1210:         case natural = ""   /// Natural
1211:     }
1212:     // MARK: - Properties
1213:     let id = UUID()
1214:     let name: String         // Nombre de la nota (DO, RE, MI, etc.)
1215:     let alteration: Alteration
1216:     let octave: Int
1217:     // MARK: - Computed Properties
1218:     var fullName: String {
1219:         "\(name)\(alteration.rawValue)\(octave)"
1220:     }
1221:     var displayName: String {
1222:         let baseName = name.capitalized
1223:         return alteration == .natural ? baseName : "\(baseName)\(alteration.rawValue)"
1224:     }
1225:     /// Posición vertical de la nota en el pentagrama
1226:     var staffOffset: CGPoint {
1227:         let baseOffset: [String: CGFloat] = [
1228:             "DO": -36,
1229:             "RE": -30,
1230:             "MI": -24,
1231:             "FA": -18,
1232:             "SOL": -12,
1233:             "LA": -6,
1234:             "SI": 0
1235:         ]
1236:         guard let offset = baseOffset[name] else { return .zero }
1237:         return CGPoint(x: 0, y: offset + (CGFloat(octave - 4) * 42))
1238:     }
1239:     // MARK: - Static Properties
1240:     private static let enharmonicEquivalents: [String: String] = [
1241:         "DO#": "RE♭", "RE♭": "DO#",
1242:         "RE#": "MI♭", "MI♭": "RE#",
1243:         "FA#": "SOL♭", "SOL♭": "FA#",
1244:         "SOL#": "LA♭", "LA♭": "SOL#",
1245:         "LA#": "SI♭", "SI♭": "LA#"
1246:     ]
1247:     // MARK: - Static Methods
1248:     /// Genera todas las notas disponibles en el rango del juego
1249:     static func generateAvailableNotes() -> [MusicalNote] {
1250:         var notes: [MusicalNote] = []
1251:         func addNote(_ name: String, octave: Int) {
1252:             notes.append(MusicalNote(name: name, alteration: .natural, octave: octave))
1253:             switch name {
1254:             case "DO":
1255:                 notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
1256:             case "RE":
1257:                 notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
1258:                 notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
1259:             case "MI":
1260:                 notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
1261:             case "FA":
1262:                 notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
1263:             case "SOL":
1264:                 notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
1265:                 notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
1266:             case "LA":
1267:                 notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
1268:                 notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
1269:             case "SI":
1270:                 notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
1271:             default: break
1272:             }
1273:         }
1274:         // Notas de la octava 3 (empezando desde LA)
1275:         ["LA", "SI"].forEach { name in
1276:             addNote(name, octave: 3)
1277:         }
1278:         // Notas de las octavas 4 y 5
1279:         for octave in 4...5 {
1280:             ["DO", "RE", "MI", "FA", "SOL", "LA", "SI"].forEach { name in
1281:                 addNote(name, octave: octave)
1282:             }
1283:         }
1284:         // Nota DO de la octava 6
1285:         addNote("DO", octave: 6)
1286:         return notes
1287:     }
1288:     /// Parsea una nota desde un string
1289:     static func parse(_ noteString: String) -> MusicalNote? {
1290:         let pattern = "([A-Z]+)([#♭]?)([0-9])"
1291:         let regex = try? NSRegularExpression(pattern: pattern, options: [])
1292:         if let match = regex?.firstMatch(in: noteString, options: [], range: NSRange(noteString.startIndex..., in: noteString)) {
1293:             let name = String(noteString[Range(match.range(at: 1), in: noteString)!])
1294:             let alterationString = String(noteString[Range(match.range(at: 2), in: noteString)!])
1295:             let octave = Int(String(noteString[Range(match.range(at: 3), in: noteString)!]))!
1296:             let alteration: Alteration = alterationString == "#" ? .sharp :
1297:                                        alterationString == "♭" ? .flat : .natural
1298:             return MusicalNote(name: name, alteration: alteration, octave: octave)
1299:         }
1300:         return nil
1301:     }
1302:     // MARK: - Instance Methods
1303:     func isEnharmonicWith(_ other: MusicalNote) -> Bool {
1304:         let thisNote = "\(name)\(alteration.rawValue)"
1305:         let otherNote = "\(other.name)\(other.alteration.rawValue)"
1306:         return MusicalNote.enharmonicEquivalents[thisNote] == otherNote && octave == other.octave
1307:     }
1308:     // MARK: - Equatable
1309:     static func == (lhs: MusicalNote, rhs: MusicalNote) -> Bool {
1310:         return lhs.fullName == rhs.fullName || lhs.isEnharmonicWith(rhs)
1311:     }
1312: }
1313: // MARK: - Note Format Conversion
1314: extension MusicalNote {
1315:     private static let noteNameMap: [String: String] = [
1316:         "do": "DO", "DO": "DO",
1317:         "re": "RE", "RE": "RE",
1318:         "mi": "MI", "MI": "MI",
1319:         "fa": "FA", "FA": "FA",
1320:         "sol": "SOL", "SOL": "SOL",
1321:         "la": "LA", "LA": "LA",
1322:         "si": "SI", "SI": "SI"
1323:     ]
1324:     /// Parsea una nota desde un string en formato español (ej: "sol4", "la#4", "si♭3")
1325:     static func parseSpanishFormat(_ noteString: String) -> MusicalNote? {
1326:         // Patrón para capturar: nombre de nota (en minúsculas o mayúsculas),
1327:         // alteración opcional (#, b, ♭) y número de octava
1328:         let pattern = "([a-zA-Z]+)([#b♭]?)([0-9])"
1329:         let regex = try? NSRegularExpression(pattern: pattern, options: [])
1330:         if let match = regex?.firstMatch(in: noteString, options: [], range: NSRange(noteString.startIndex..., in: noteString)) {
1331:             let noteName = String(noteString[Range(match.range(at: 1), in: noteString)!])
1332:             let alterationString = String(noteString[Range(match.range(at: 2), in: noteString)!])
1333:             let octave = Int(String(noteString[Range(match.range(at: 3), in: noteString)!]))!
1334:             // Convertir el nombre de la nota al formato esperado
1335:             guard let standardName = noteNameMap[noteName.lowercased()] else {
1336:                 print("❌ Nombre de nota no reconocido: \(noteName)")
1337:                 return nil
1338:             }
1339:             // Determinar la alteración
1340:             let alteration: Alteration
1341:             switch alterationString {
1342:             case "#":
1343:                 alteration = .sharp
1344:             case "b", "♭":
1345:                 alteration = .flat
1346:             default:
1347:                 alteration = .natural
1348:             }
1349:             print("✅ Nota parseada: \(standardName)\(alteration.rawValue)\(octave)")
1350:             return MusicalNote(name: standardName, alteration: alteration, octave: octave)
1351:         }
1352:         print("❌ No se pudo parsear la nota: \(noteString)")
1353:         return nil
1354:     }
1355: }
1356: </file>
1357: <file path="MusicBlocks/Inicio y Profile/AchievementBadge.swift">
1358: //
1359: //  AchievementBadge.swift
1360: //  MusicBlocks
1361: //
1362: //  Created by Jose R. García on 28/2/25.
1363: //
1364: import UIKit
1365: // MARK: - Medal Models
1366: struct MedalCategory {
1367:     let type: MedalType
1368:     let medals: [MedalInfo]
1369:     var title: String {
1370:         switch type {
1371:         case .notesHit:
1372:             return "Precisión Musical"
1373:         case .playTime:
1374:             return "Dedicación"
1375:         case .streaks:
1376:             return "Racha"
1377:         case .perfectTuning:
1378:             return "Afinación"
1379:         }
1380:     }
1381: }
1382: enum MedalType: String {
1383:     case notesHit = "notes_hit"
1384:     case playTime = "play_time"
1385:     case streaks = "streaks"
1386:     case perfectTuning = "perfect_tuning"
1387: }
1388: extension MedalType: CaseIterable {
1389:     var icon: String {
1390:         switch self {
1391:         case .notesHit:
1392:             return "🎵"
1393:         case .playTime:
1394:             return "⏱"
1395:         case .streaks:
1396:             return "🔥"
1397:         case .perfectTuning:
1398:             return "⭐️"
1399:         }
1400:     }
1401:     var title: String {
1402:         switch self {
1403:         case .notesHit:
1404:             return "Precisión Musical"
1405:         case .playTime:
1406:             return "Dedicación"
1407:         case .streaks:
1408:             return "Racha"
1409:         case .perfectTuning:
1410:             return "Afinación"
1411:         }
1412:     }
1413:     var shortTitle: String {
1414:         switch self {
1415:         case .notesHit:
1416:             return "Precisión"
1417:         case .playTime:
1418:             return "Tiempo"
1419:         case .streaks:
1420:             return "Rachas"
1421:         case .perfectTuning:
1422:             return "Afinación"
1423:         }
1424:     }
1425: }
1426: struct MedalInfo {
1427:     let name: String
1428:     let requirement: String
1429:     let image: String
1430:     let objective: MedalObjective?
1431:     var isUnlocked: Bool
1432:     init(from medal: Medal, isUnlocked: Bool = false) {
1433:         self.name = medal.name
1434:         self.requirement = medal.requirement
1435:         self.image = medal.image
1436:         self.objective = medal.objective
1437:         self.isUnlocked = isUnlocked
1438:     }
1439: }
1440: // MARK: - Medal Manager
1441: final class MedalManager {
1442:     static let shared = MedalManager()
1443:     private(set) var medals: [MedalCategory] = []
1444:     private var gameConfig: GameConfig?
1445:     private init() {
1446:         loadMedals()
1447:     }
1448:     func loadMedals() {
1449:         gameConfig = GameLevelProcessor.loadGameLevelsFromFile()
1450:         if let config = gameConfig {
1451:             let medalsData = GameLevelProcessor.getMedals(from: config)
1452:             medals = [
1453:                 MedalCategory(type: .notesHit, medals: medalsData.notesHit.map { MedalInfo(from: $0) }),
1454:                 MedalCategory(type: .playTime, medals: medalsData.playTime.map { MedalInfo(from: $0) }),
1455:                 MedalCategory(type: .streaks, medals: medalsData.streaks.map { MedalInfo(from: $0) }),
1456:                 MedalCategory(type: .perfectTuning, medals: medalsData.perfectTuning.map { MedalInfo(from: $0) })
1457:             ]
1458:             loadMedalsProgress()
1459:         }
1460:     }
1461:     func getMedals() -> [MedalCategory] {
1462:         return medals
1463:     }
1464:     func updateMedals(notesHit: Int, playTime: TimeInterval, currentStreak: Int, perfectTuningCount: Int) {
1465:         medals = medals.map { category in
1466:             var updatedMedals = category.medals
1467:             switch category.type {
1468:             case .notesHit:
1469:                 updatedMedals = category.medals.map { medal in
1470:                     var updatedMedal = medal
1471:                     if let requirement = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
1472:                         updatedMedal.isUnlocked = notesHit >= requirement
1473:                     }
1474:                     return updatedMedal
1475:                 }
1476:             case .playTime:
1477:                 updatedMedals = category.medals.map { medal in
1478:                     var updatedMedal = medal
1479:                     let playTimeHours = playTime / 3600
1480:                     if medal.requirement.contains("minutos") {
1481:                         if let minutes = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
1482:                             updatedMedal.isUnlocked = playTimeHours * 60 >= Double(minutes)
1483:                         }
1484:                     } else if medal.requirement.contains("horas") {
1485:                         if let hours = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
1486:                             updatedMedal.isUnlocked = playTimeHours >= Double(hours)
1487:                         }
1488:                     }
1489:                     return updatedMedal
1490:                 }
1491:             case .streaks:
1492:                 updatedMedals = category.medals.map { medal in
1493:                     var updatedMedal = medal
1494:                     if let requirement = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
1495:                         updatedMedal.isUnlocked = currentStreak >= requirement
1496:                     }
1497:                     return updatedMedal
1498:                 }
1499:             case .perfectTuning:
1500:                 updatedMedals = category.medals.map { medal in
1501:                     var updatedMedal = medal
1502:                     if let requirement = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
1503:                         updatedMedal.isUnlocked = perfectTuningCount >= requirement
1504:                     }
1505:                     return updatedMedal
1506:                 }
1507:             }
1508:             return MedalCategory(type: category.type, medals: updatedMedals)
1509:         }
1510:         saveMedalsProgress()
1511:     }
1512:     private func saveMedalsProgress() {
1513:         let progress = medals.map { category in
1514:             return (category.type.rawValue, category.medals.map { $0.isUnlocked })
1515:         }
1516:         let progressDict = Dictionary(uniqueKeysWithValues: progress)
1517:         UserDefaults.standard.set(progressDict, forKey: "medalsProgress")
1518:     }
1519:     private func loadMedalsProgress() {
1520:         if let progressDict = UserDefaults.standard.dictionary(forKey: "medalsProgress") as? [String: [Bool]] {
1521:             medals = medals.map { category in
1522:                 let unlockedStates = progressDict[category.type.rawValue] ?? Array(repeating: false, count: category.medals.count)
1523:                 let updatedMedals = zip(category.medals, unlockedStates).map { medal, isUnlocked in
1524:                     MedalInfo(
1525:                         from: Medal(
1526:                             name: medal.name,
1527:                             requirement: medal.requirement,
1528:                             image: medal.image,
1529:                             objective: medal.objective ?? createDefaultObjective(for: category.type, requirement: medal.requirement)
1530:                         ),
1531:                         isUnlocked: isUnlocked
1532:                     )
1533:                 }
1534:                 return MedalCategory(type: category.type, medals: updatedMedals)
1535:             }
1536:         }
1537:     }
1538:     private func createDefaultObjective(for type: MedalType, requirement: String) -> MedalObjective {
1539:         let target = extractTarget(from: requirement)
1540:         switch type {
1541:         case .notesHit:
1542:             return MedalObjective(
1543:                 type: type.rawValue,
1544:                 target: target,
1545:                 lifetime: true,
1546:                 resetOnFail: false,
1547:                 accuracy: nil
1548:             )
1549:         case .playTime:
1550:             return MedalObjective(
1551:                 type: type.rawValue,
1552:                 target: target,
1553:                 lifetime: true,
1554:                 resetOnFail: false,
1555:                 accuracy: nil
1556:             )
1557:         case .streaks:
1558:             return MedalObjective(
1559:                 type: type.rawValue,
1560:                 target: target,
1561:                 lifetime: false,
1562:                 resetOnFail: true,
1563:                 accuracy: nil
1564:             )
1565:         case .perfectTuning:
1566:             return MedalObjective(
1567:                 type: type.rawValue,
1568:                 target: target,
1569:                 lifetime: true,
1570:                 resetOnFail: false,
1571:                 accuracy: 1.0
1572:             )
1573:         }
1574:     }
1575:     private func extractTarget(from requirement: String) -> Int {
1576:         if let target = Int(requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
1577:             if requirement.contains("minutos") {
1578:                 return target * 60
1579:             } else if requirement.contains("horas") {
1580:                 return target * 3600
1581:             }
1582:             return target
1583:         }
1584:         return 0
1585:     }
1586: }
1587: </file>
1588: <file path="MusicBlocks/Inicio y Profile/AchievementsView.swift">
1589: //
1590: //  AchievementsView.swift
1591: //  MusicBlocks
1592: //
1593: //  Created by Jose R. García on 1/3/25.
1594: //
1595: import UIKit
1596: class AchievementsView: UIView {
1597:     private let stackView: UIStackView = {
1598:         let stack = UIStackView()
1599:         stack.axis = .vertical
1600:         stack.spacing = 16 // Reducido de 24 a 16
1601:         return stack
1602:     }()
1603:     private let medalStatsView = MedalStatsView()
1604:     private let medalsGridView = MedalsGridView()
1605:     init(medals: [MedalCategory]) {
1606:         super.init(frame: .zero)
1607:         setupViews()
1608:         configure(with: medals)
1609:     }
1610:     required init?(coder: NSCoder) {
1611:         fatalError("init(coder:) has not been implemented")
1612:     }
1613:     private func setupViews() {
1614:         stackView.translatesAutoresizingMaskIntoConstraints = false
1615:         addSubview(stackView)
1616:         stackView.addArrangedSubview(medalStatsView)
1617:         stackView.addArrangedSubview(medalsGridView)
1618:         NSLayoutConstraint.activate([
1619:             stackView.topAnchor.constraint(equalTo: topAnchor, constant: 4), // Reducido de 8 a 4
1620:             stackView.leadingAnchor.constraint(equalTo: leadingAnchor),
1621:             stackView.trailingAnchor.constraint(equalTo: trailingAnchor),
1622:             stackView.bottomAnchor.constraint(equalTo: bottomAnchor)
1623:         ])
1624:     }
1625:     func configure(with medals: [MedalCategory]) {
1626:         medalStatsView.configure(with: medals)
1627:         medalsGridView.configure(with: medals)
1628:     }
1629: }
1630: // MARK: - Medal Stats View
1631: class MedalStatsView: UIView {
1632:     private let titleLabel: UILabel = {
1633:         let label = UILabel()
1634:         label.text = "Progreso de Medallas"
1635:         label.font = .systemFont(ofSize: 17, weight: .semibold)
1636:         return label
1637:     }()
1638:     private let subtitleLabel: UILabel = {
1639:         let label = UILabel()
1640:         label.font = .systemFont(ofSize: 14)
1641:         label.textColor = .secondaryLabel
1642:         return label
1643:     }()
1644:     private let typeStackView: UIStackView = {
1645:         let stack = UIStackView()
1646:         stack.axis = .horizontal
1647:         stack.distribution = .fillEqually
1648:         stack.spacing = 16
1649:         return stack
1650:     }()
1651:     override init(frame: CGRect) {
1652:         super.init(frame: frame)
1653:         setupViews()
1654:     }
1655:     required init?(coder: NSCoder) {
1656:         fatalError("init(coder:) has not been implemented")
1657:     }
1658:     private func setupViews() {
1659:         [titleLabel, subtitleLabel, typeStackView].forEach {
1660:             $0.translatesAutoresizingMaskIntoConstraints = false
1661:             addSubview($0)
1662:         }
1663:         NSLayoutConstraint.activate([
1664:             titleLabel.topAnchor.constraint(equalTo: topAnchor, constant: 16),
1665:             titleLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
1666:             subtitleLabel.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 4),
1667:             subtitleLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
1668:             typeStackView.topAnchor.constraint(equalTo: subtitleLabel.bottomAnchor, constant: 16),
1669:             typeStackView.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
1670:             typeStackView.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
1671:             typeStackView.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -16)
1672:         ])
1673:         layer.cornerRadius = 12
1674:         backgroundColor = .systemGray6
1675:     }
1676:     func configure(with medals: [MedalCategory]) {
1677:         // Limpiar vista previa
1678:         typeStackView.arrangedSubviews.forEach { $0.removeFromSuperview() }
1679:         // Calcular totales
1680:         let totalStats = getTotalStats(from: medals)
1681:         subtitleLabel.text = "\(totalStats.unlocked) de \(totalStats.total) medallas desbloqueadas"
1682:         // Crear vistas para cada tipo
1683:         MedalType.allCases.forEach { type in
1684:             if let category = medals.first(where: { $0.type == type }) {
1685:                 let stats = getCategoryStats(for: category)
1686:                 let typeView = MedalTypeView(
1687:                     type: type,
1688:                     unlockedCount: stats.unlocked,
1689:                     totalCount: stats.total
1690:                 )
1691:                 typeStackView.addArrangedSubview(typeView)
1692:             }
1693:         }
1694:     }
1695:     private func getTotalStats(from medals: [MedalCategory]) -> (unlocked: Int, total: Int) {
1696:         let unlocked = medals.reduce(0) { $0 + $1.medals.filter { $0.isUnlocked }.count }
1697:         let total = medals.reduce(0) { $0 + $1.medals.count }
1698:         return (unlocked, total)
1699:     }
1700:     private func getCategoryStats(for category: MedalCategory) -> (unlocked: Int, total: Int) {
1701:         let unlocked = category.medals.filter { $0.isUnlocked }.count
1702:         return (unlocked, category.medals.count)
1703:     }
1704: }
1705: // MARK: - Medal Type View
1706: class MedalTypeView: UIView {
1707:     private let iconLabel: UILabel = {
1708:         let label = UILabel()
1709:         label.font = .systemFont(ofSize: 24)
1710:         label.textAlignment = .center
1711:         return label
1712:     }()
1713:     private let statsLabel: UILabel = {
1714:         let label = UILabel()
1715:         label.font = .systemFont(ofSize: 12, weight: .medium)
1716:         label.textAlignment = .center
1717:         return label
1718:     }()
1719:     private let titleLabel: UILabel = {
1720:         let label = UILabel()
1721:         label.font = .systemFont(ofSize: 10)
1722:         label.textColor = .secondaryLabel
1723:         label.textAlignment = .center
1724:         return label
1725:     }()
1726:     init(type: MedalType, unlockedCount: Int, totalCount: Int) {
1727:         super.init(frame: .zero)
1728:         setupViews()
1729:         configure(with: type, unlockedCount: unlockedCount, totalCount: totalCount)
1730:     }
1731:     required init?(coder: NSCoder) {
1732:         fatalError("init(coder:) has not been implemented")
1733:     }
1734:     private func setupViews() {
1735:         [iconLabel, statsLabel, titleLabel].forEach {
1736:             $0.translatesAutoresizingMaskIntoConstraints = false
1737:             addSubview($0)
1738:         }
1739:         NSLayoutConstraint.activate([
1740:             iconLabel.topAnchor.constraint(equalTo: topAnchor, constant: 8),
1741:             iconLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
1742:             statsLabel.topAnchor.constraint(equalTo: iconLabel.bottomAnchor, constant: 4),
1743:             statsLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
1744:             titleLabel.topAnchor.constraint(equalTo: statsLabel.bottomAnchor, constant: 2),
1745:             titleLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
1746:             titleLabel.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -8)
1747:         ])
1748:         layer.cornerRadius = 8
1749:     }
1750:     private func configure(with type: MedalType, unlockedCount: Int, totalCount: Int) {
1751:         iconLabel.text = type.icon
1752:         statsLabel.text = "\(unlockedCount)/\(totalCount)"
1753:         titleLabel.text = type.shortTitle
1754:         backgroundColor = typeColor(for: type).withAlphaComponent(0.1)
1755:     }
1756:     private func typeColor(for type: MedalType) -> UIColor {
1757:         switch type {
1758:         case .notesHit:
1759:             return .systemBlue
1760:         case .playTime:
1761:             return .systemRed
1762:         case .streaks:
1763:             return .systemYellow
1764:         case .perfectTuning:
1765:             return .systemPurple
1766:         }
1767:     }
1768: }
1769: // MARK: - Medals Grid View
1770: class MedalsGridView: UIView {
1771:     private let stackView: UIStackView = {
1772:         let stack = UIStackView()
1773:         stack.axis = .vertical
1774:         stack.spacing = 16
1775:         return stack
1776:     }()
1777:     override init(frame: CGRect) {
1778:         super.init(frame: frame)
1779:         setupViews()
1780:     }
1781:     required init?(coder: NSCoder) {
1782:         fatalError("init(coder:) has not been implemented")
1783:     }
1784:     private func setupViews() {
1785:         stackView.translatesAutoresizingMaskIntoConstraints = false
1786:         addSubview(stackView)
1787:         NSLayoutConstraint.activate([
1788:             stackView.topAnchor.constraint(equalTo: topAnchor),
1789:             stackView.leadingAnchor.constraint(equalTo: leadingAnchor),
1790:             stackView.trailingAnchor.constraint(equalTo: trailingAnchor),
1791:             stackView.bottomAnchor.constraint(equalTo: bottomAnchor)
1792:         ])
1793:     }
1794:     func configure(with medals: [MedalCategory]) {
1795:         // Limpiar vista previa
1796:         stackView.arrangedSubviews.forEach { $0.removeFromSuperview() }
1797:         // Crear sección para cada categoría
1798:         medals.forEach { category in
1799:             let categoryView = MedalCategoryView(category: category)
1800:             stackView.addArrangedSubview(categoryView)
1801:         }
1802:     }
1803: }
1804: // MARK: - Medal Category View
1805: class MedalCategoryView: UIView {
1806:     private let titleLabel: UILabel = {
1807:         let label = UILabel()
1808:         label.font = .systemFont(ofSize: 17, weight: .semibold)
1809:         return label
1810:     }()
1811:     private let statsLabel: UILabel = {
1812:         let label = UILabel()
1813:         label.font = .systemFont(ofSize: 12)
1814:         label.textColor = .secondaryLabel
1815:         return label
1816:     }()
1817:     private let scrollView: UIScrollView = {
1818:         let scroll = UIScrollView()
1819:         scroll.showsHorizontalScrollIndicator = false
1820:         return scroll
1821:     }()
1822:     private let medalsStack: UIStackView = {
1823:         let stack = UIStackView()
1824:         stack.axis = .horizontal
1825:         stack.spacing = 12
1826:         return stack
1827:     }()
1828:     init(category: MedalCategory) {
1829:         super.init(frame: .zero)
1830:         setupViews()
1831:         configure(with: category)
1832:     }
1833:     required init?(coder: NSCoder) {
1834:         fatalError("init(coder:) has not been implemented")
1835:     }
1836:     private func setupViews() {
1837:         [titleLabel, statsLabel, scrollView].forEach {
1838:             $0.translatesAutoresizingMaskIntoConstraints = false
1839:             addSubview($0)
1840:         }
1841:         scrollView.addSubview(medalsStack)
1842:         medalsStack.translatesAutoresizingMaskIntoConstraints = false
1843:         NSLayoutConstraint.activate([
1844:             titleLabel.topAnchor.constraint(equalTo: topAnchor),
1845:             titleLabel.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
1846:             statsLabel.centerYAnchor.constraint(equalTo: titleLabel.centerYAnchor),
1847:             statsLabel.leadingAnchor.constraint(equalTo: titleLabel.trailingAnchor, constant: 8),
1848:             scrollView.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 12),
1849:             scrollView.leadingAnchor.constraint(equalTo: leadingAnchor),
1850:             scrollView.trailingAnchor.constraint(equalTo: trailingAnchor),
1851:             scrollView.bottomAnchor.constraint(equalTo: bottomAnchor),
1852:             medalsStack.topAnchor.constraint(equalTo: scrollView.topAnchor),
1853:             medalsStack.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor, constant: 16),
1854:             medalsStack.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor, constant: -16),
1855:             medalsStack.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
1856:             medalsStack.heightAnchor.constraint(equalTo: scrollView.heightAnchor)
1857:         ])
1858:     }
1859:     private func configure(with category: MedalCategory) {
1860:         titleLabel.text = category.title
1861:         let stats = getCategoryStats(for: category)
1862:         statsLabel.text = "\(stats.unlocked)/\(stats.total)"
1863:         category.medals.forEach { medal in
1864:             let medalView = MedalView(
1865:                 medalInfo: medal,
1866:                 color: typeColor(for: category.type)
1867:             )
1868:             medalsStack.addArrangedSubview(medalView)
1869:         }
1870:     }
1871:     private func getCategoryStats(for category: MedalCategory) -> (unlocked: Int, total: Int) {
1872:         let unlocked = category.medals.filter { $0.isUnlocked }.count
1873:         return (unlocked, category.medals.count)
1874:     }
1875:     private func typeColor(for type: MedalType) -> UIColor {
1876:         switch type {
1877:         case .notesHit:
1878:             return .systemBlue
1879:         case .playTime:
1880:             return .systemRed
1881:         case .streaks:
1882:             return .systemYellow
1883:         case .perfectTuning:
1884:             return .systemPurple
1885:         }
1886:     }
1887: }
1888: // MARK: - Medal View
1889: class MedalView: UIView {
1890:     private let imageView: UIImageView = {
1891:         let imageView = UIImageView()
1892:         imageView.contentMode = .scaleAspectFit
1893:         return imageView
1894:     }()
1895:     private let lockImageView: UIImageView = {
1896:         let imageView = UIImageView()
1897:         imageView.image = UIImage(systemName: "lock.fill")
1898:         imageView.tintColor = .white
1899:         return imageView
1900:     }()
1901:     private let nameLabel: UILabel = {
1902:         let label = UILabel()
1903:         label.font = .systemFont(ofSize: 12, weight: .medium)
1904:         label.textAlignment = .center
1905:         label.numberOfLines = 0
1906:         return label
1907:     }()
1908:     private let requirementLabel: UILabel = {
1909:         let label = UILabel()
1910:         label.font = .systemFont(ofSize: 10)
1911:         label.textColor = .secondaryLabel
1912:         label.textAlignment = .center
1913:         label.numberOfLines = 0
1914:         return label
1915:     }()
1916:     init(medalInfo: MedalInfo, color: UIColor) {
1917:         super.init(frame: .zero)
1918:         setupViews()
1919:         configure(with: medalInfo, color: color)
1920:     }
1921:     required init?(coder: NSCoder) {
1922:         fatalError("init(coder:) has not been implemented")
1923:     }
1924:     private func setupViews() {
1925:         [imageView, lockImageView, nameLabel, requirementLabel].forEach {
1926:             $0.translatesAutoresizingMaskIntoConstraints = false
1927:             addSubview($0)
1928:         }
1929:         NSLayoutConstraint.activate([
1930:             imageView.topAnchor.constraint(equalTo: topAnchor, constant: 8),
1931:             imageView.centerXAnchor.constraint(equalTo: centerXAnchor),
1932:             imageView.widthAnchor.constraint(equalToConstant: 60),
1933:             imageView.heightAnchor.constraint(equalToConstant: 60),
1934:             lockImageView.centerXAnchor.constraint(equalTo: imageView.centerXAnchor),
1935:             lockImageView.centerYAnchor.constraint(equalTo: imageView.centerYAnchor),
1936:             lockImageView.widthAnchor.constraint(equalToConstant: 20),
1937:             lockImageView.heightAnchor.constraint(equalToConstant: 20),
1938:             nameLabel.topAnchor.constraint(equalTo: imageView.bottomAnchor, constant: 8),
1939:             nameLabel.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 8),
1940:             nameLabel.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -8),
1941:             requirementLabel.topAnchor.constraint(equalTo: nameLabel.bottomAnchor, constant: 4),
1942:             requirementLabel.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 8),
1943:             requirementLabel.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -8),
1944:             requirementLabel.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -8)
1945:         ])
1946:         layer.cornerRadius = 12
1947:         backgroundColor = .systemGray6
1948:         // Establecer ancho fijo para cada medalla
1949:         widthAnchor.constraint(equalToConstant: 120).isActive = true
1950:     }
1951:     private func configure(with medalInfo: MedalInfo, color: UIColor) {
1952:         // Configurar imagen
1953:         imageView.image = UIImage(named: medalInfo.image)
1954:         imageView.alpha = medalInfo.isUnlocked ? 1.0 : 0.3
1955:         // Configurar visibilidad del candado
1956:         lockImageView.isHidden = medalInfo.isUnlocked
1957:         // Configurar textos
1958:         nameLabel.text = medalInfo.name
1959:         nameLabel.textColor = medalInfo.isUnlocked ? .label : .secondaryLabel
1960:         requirementLabel.text = medalInfo.requirement
1961:         // Configurar borde
1962:         layer.borderWidth = 2
1963:         layer.borderColor = medalInfo.isUnlocked ? color.cgColor : UIColor.systemGray.cgColor
1964:         // Configurar opacidad general
1965:         alpha = medalInfo.isUnlocked ? 1.0 : 0.8
1966:         // Añadir superposición oscura si está bloqueada
1967:         if !medalInfo.isUnlocked {
1968:             let overlayView = UIView()
1969:             overlayView.backgroundColor = .black
1970:             overlayView.alpha = 0.3
1971:             overlayView.translatesAutoresizingMaskIntoConstraints = false
1972:             insertSubview(overlayView, aboveSubview: imageView)
1973:             NSLayoutConstraint.activate([
1974:                 overlayView.topAnchor.constraint(equalTo: imageView.topAnchor),
1975:                 overlayView.leadingAnchor.constraint(equalTo: imageView.leadingAnchor),
1976:                 overlayView.trailingAnchor.constraint(equalTo: imageView.trailingAnchor),
1977:                 overlayView.bottomAnchor.constraint(equalTo: imageView.bottomAnchor)
1978:             ])
1979:             overlayView.layer.cornerRadius = 30
1980:             overlayView.clipsToBounds = true
1981:         }
1982:     }
1983: }
1984: #if DEBUG
1985: import SwiftUI
1986: // Función helper para obtener medallas de prueba
1987: private func getMockMedals() -> [MedalCategory] {
1988:     guard let gameConfig = GameLevelProcessor.loadGameLevelsFromFile(),
1989:           let medals = try? JSONDecoder().decode(Medals.self, from: JSONEncoder().encode(gameConfig.medals)) else {
1990:         return []
1991:     }
1992:     return [
1993:         MedalCategory(
1994:             type: .notesHit,
1995:             medals: medals.notesHit.map { medal in
1996:                 MedalInfo(
1997:                     from: medal,
1998:                     isUnlocked: Bool.random() // Para la preview, algunas estarán desbloqueadas al azar
1999:                 )
2000:             }
2001:         ),
2002:         MedalCategory(
2003:             type: .playTime,
2004:             medals: medals.playTime.map { medal in
2005:                 MedalInfo(
2006:                     from: medal,
2007:                     isUnlocked: Bool.random()
2008:                 )
2009:             }
2010:         ),
2011:         MedalCategory(
2012:             type: .streaks,
2013:             medals: medals.streaks.map { medal in
2014:                 MedalInfo(
2015:                     from: medal,
2016:                     isUnlocked: Bool.random()
2017:                 )
2018:             }
2019:         ),
2020:         MedalCategory(
2021:             type: .perfectTuning,
2022:             medals: medals.perfectTuning.map { medal in
2023:                 MedalInfo(
2024:                     from: medal,
2025:                     isUnlocked: Bool.random()
2026:                 )
2027:             }
2028:         )
2029:     ]
2030: }
2031: @available(iOS 17.0, *)
2032: struct AchievementsView_Previews: PreviewProvider {
2033:     static var previews: some View {
2034:         AchievementsViewRepresentable()
2035:             .frame(height: 600)
2036:             .padding()
2037:             .previewDisplayName("Light Mode")
2038:         AchievementsViewRepresentable()
2039:             .frame(height: 600)
2040:             .padding()
2041:             .preferredColorScheme(.dark)
2042:             .previewDisplayName("Dark Mode")
2043:     }
2044:     private struct AchievementsViewRepresentable: UIViewRepresentable {
2045:         func makeUIView(context: Context) -> AchievementsView {
2046:             let mockMedals = getMockMedals()
2047:             return AchievementsView(medals: mockMedals)
2048:         }
2049:         func updateUIView(_ uiView: AchievementsView, context: Context) {}
2050:     }
2051: }
2052: @available(iOS 17.0, *)
2053: struct MedalStatsView_Previews: PreviewProvider {
2054:     static var previews: some View {
2055:         UIViewPreview {
2056:             let view = MedalStatsView()
2057:             view.configure(with: getMockMedals())
2058:             return view
2059:         }
2060:         .frame(height: 200)
2061:         .padding()
2062:         .previewLayout(.sizeThatFits)
2063:         .previewDisplayName("Medal Stats View")
2064:     }
2065: }
2066: @available(iOS 17.0, *)
2067: struct MedalsGridView_Previews: PreviewProvider {
2068:     static var previews: some View {
2069:         UIViewPreview {
2070:             let view = MedalsGridView()
2071:             view.configure(with: getMockMedals())
2072:             return view
2073:         }
2074:         .frame(height: 400)
2075:         .padding()
2076:         .previewLayout(.sizeThatFits)
2077:         .previewDisplayName("Medals Grid View")
2078:     }
2079: }
2080: // Helper para previews de UIView
2081: struct UIViewPreview<View: UIView>: UIViewRepresentable {
2082:     let view: View
2083:     init(_ builder: @escaping () -> View) {
2084:         view = builder()
2085:     }
2086:     func makeUIView(context: Context) -> View {
2087:         return view
2088:     }
2089:     func updateUIView(_ view: View, context: Context) {
2090:         view.setContentHuggingPriority(.defaultHigh, for: .horizontal)
2091:         view.setContentHuggingPriority(.defaultHigh, for: .vertical)
2092:     }
2093: }
2094: #endif
2095: </file>
2096: <file path="MusicBlocks/Inicio y Profile/AvatarPickerViewController.swift">
2097: //
2098: //  AvatarPickerViewController.swift
2099: //  MusicBlocks
2100: //
2101: //  Created by Jose R. García on 1/3/25.
2102: //
2103: import UIKit
2104: protocol AvatarPickerViewControllerDelegate: AnyObject {
2105:     func avatarPicker(_ picker: AvatarPickerViewController, didSelect avatar: String)
2106: }
2107: class AvatarPickerViewController: UIViewController, UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {
2108:     private let collectionView: UICollectionView
2109:     private let availableAvatars: [String]
2110:     private var selectedAvatar: String
2111:     weak var delegate: AvatarPickerViewControllerDelegate?
2112:     init(selectedAvatar: String, availableAvatars: [String]) {
2113:         self.selectedAvatar = selectedAvatar
2114:         self.availableAvatars = availableAvatars
2115:         // Configurar el layout con tamaños estimados
2116:         let layout = UICollectionViewFlowLayout()
2117:         layout.scrollDirection = .vertical
2118:         layout.minimumLineSpacing = 16
2119:         layout.minimumInteritemSpacing = 16
2120:         self.collectionView = UICollectionView(frame: .zero, collectionViewLayout: layout)
2121:         super.init(nibName: nil, bundle: nil)
2122:     }
2123:     required init?(coder: NSCoder) {
2124:         fatalError("init(coder:) has not been implemented")
2125:     }
2126:     override func viewDidLoad() {
2127:         super.viewDidLoad()
2128:         setupViews()
2129:     }
2130:     private func setupViews() {
2131:         title = "Elegir Avatar"
2132:         view.backgroundColor = .systemBackground
2133:         // Configurar botones de navegación
2134:         navigationItem.leftBarButtonItem = UIBarButtonItem(
2135:             title: "Cancelar",
2136:             style: .plain,
2137:             target: self,
2138:             action: #selector(handleCancel)
2139:         )
2140:         navigationItem.rightBarButtonItem = UIBarButtonItem(
2141:             title: "Guardar",
2142:             style: .done,
2143:             target: self,
2144:             action: #selector(handleSave)
2145:         )
2146:         // Configurar collection view
2147:         collectionView.translatesAutoresizingMaskIntoConstraints = false
2148:         collectionView.backgroundColor = .systemBackground
2149:         collectionView.delegate = self
2150:         collectionView.dataSource = self
2151:         collectionView.register(AvatarCell.self, forCellWithReuseIdentifier: "AvatarCell")
2152:         collectionView.contentInset = UIEdgeInsets(top: 16, left: 16, bottom: 16, right: 16)
2153:         view.addSubview(collectionView)
2154:         NSLayoutConstraint.activate([
2155:             collectionView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
2156:             collectionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
2157:             collectionView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
2158:             collectionView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
2159:         ])
2160:     }
2161:     @objc private func handleCancel() {
2162:         dismiss(animated: true)
2163:     }
2164:     @objc private func handleSave() {
2165:         delegate?.avatarPicker(self, didSelect: selectedAvatar)
2166:     }
2167:     // MARK: - UICollectionViewDataSource
2168:     func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
2169:         return availableAvatars.count
2170:     }
2171:     func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
2172:         let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "AvatarCell", for: indexPath) as! AvatarCell
2173:         let avatar = availableAvatars[indexPath.item]
2174:         cell.configure(with: avatar, isSelected: avatar == selectedAvatar)
2175:         return cell
2176:     }
2177:     // MARK: - UICollectionViewDelegate
2178:     func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
2179:         selectedAvatar = availableAvatars[indexPath.item]
2180:         collectionView.reloadData()
2181:     }
2182:     // MARK: - UICollectionViewDelegateFlowLayout
2183:     func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
2184:         let availableWidth = collectionView.bounds.width - 48
2185:         let width = availableWidth / 3
2186:         let height = width * 1.4
2187:         return CGSize(width: width, height: height)
2188:     }
2189: }
2190: // MARK: - Avatar Cell
2191: class AvatarCell: UICollectionViewCell {
2192:     private let containerView: UIView = {
2193:         let view = UIView()
2194:         view.backgroundColor = .systemBackground
2195:         view.layer.cornerRadius = 12
2196:         view.clipsToBounds = true
2197:         return view
2198:     }()
2199:     private let imageView: UIImageView = {
2200:         let imageView = UIImageView()
2201:         imageView.contentMode = .scaleAspectFit
2202:         imageView.clipsToBounds = true
2203:         return imageView
2204:     }()
2205:     private let nameLabel: UILabel = {
2206:         let label = UILabel()
2207:         label.font = .systemFont(ofSize: 12)
2208:         label.textColor = .secondaryLabel
2209:         label.textAlignment = .center
2210:         return label
2211:     }()
2212:     override init(frame: CGRect) {
2213:         super.init(frame: frame)
2214:         setupViews()
2215:     }
2216:     required init?(coder: NSCoder) {
2217:         fatalError("init(coder:) has not been implemented")
2218:     }
2219:     private func setupViews() {
2220:         contentView.addSubview(containerView)
2221:         containerView.addSubview(imageView)
2222:         containerView.addSubview(nameLabel)
2223:         containerView.translatesAutoresizingMaskIntoConstraints = false
2224:         imageView.translatesAutoresizingMaskIntoConstraints = false
2225:         nameLabel.translatesAutoresizingMaskIntoConstraints = false
2226:         NSLayoutConstraint.activate([
2227:             // Container constraints
2228:             containerView.topAnchor.constraint(equalTo: contentView.topAnchor),
2229:             containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
2230:             containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
2231:             containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
2232:             // Image constraints
2233:             imageView.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 8),
2234:             imageView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 8),
2235:             imageView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -8),
2236:             imageView.heightAnchor.constraint(equalTo: imageView.widthAnchor), // Aspecto cuadrado
2237:             // Label constraints
2238:             nameLabel.topAnchor.constraint(equalTo: imageView.bottomAnchor, constant: 4),
2239:             nameLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 4),
2240:             nameLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -4),
2241:             nameLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -8)
2242:         ])
2243:     }
2244:     func configure(with avatar: String, isSelected: Bool) {
2245:         imageView.image = UIImage(named: avatar)
2246:         nameLabel.text = avatar
2247:         containerView.layer.borderWidth = isSelected ? 3 : 0
2248:         containerView.layer.borderColor = isSelected ? UIColor.systemRed.cgColor : nil
2249:         containerView.backgroundColor = isSelected ? .systemRed.withAlphaComponent(0.1) : .systemBackground
2250:     }
2251:     override func prepareForReuse() {
2252:         super.prepareForReuse()
2253:         imageView.image = nil
2254:         nameLabel.text = nil
2255:         containerView.layer.borderWidth = 0
2256:         containerView.layer.borderColor = nil
2257:         containerView.backgroundColor = .systemBackground
2258:     }
2259: }
2260: </file>
2261: <file path="MusicBlocks/Inicio y Profile/ContentView.swift">
2262: //
2263: //  ContentView.swift
2264: //  MusicBlocks
2265: //
2266: //  Created by Jose R. García on 14/2/25.
2267: //
2268: import SwiftUI
2269: import AVFoundation
2270: import SpriteKit
2271: struct ContentView: View {
2272:     @StateObject private var audioController = AudioController.sharedInstance
2273:     @State private var gameVersion: String = "--" // Valor por defecto
2274:     @State private var navigateToGame = false  // Controla la navegación al juego
2275:     var body: some View {
2276:         NavigationStack {
2277:             VStack(spacing: 30) {
2278:                 Spacer()
2279:                 // Logo
2280:                 VStack(spacing: 15) {
2281:                     Image("logoMusicBlocks")
2282:                         .resizable()
2283:                         .scaledToFit()
2284:                         .frame(width: 320, height: 320)
2285:                 }
2286:                 .padding(.bottom, 20)
2287:                 // Botones de navegación
2288:                 VStack(spacing: 20) {
2289:                     Button(action: {
2290:                         startGameSequence()
2291:                     }) {
2292:                         HStack {
2293:                             Image(systemName: "gamecontroller")
2294:                             Text("Jugar")
2295:                                 .font(.headline)
2296:                         }
2297:                         .frame(maxWidth: .infinity)
2298:                         .padding()
2299:                         .background(
2300:                             RoundedRectangle(cornerRadius: 15)
2301:                                 .fill(Color.red)
2302:                         )
2303:                         .foregroundColor(.white)
2304:                     }
2305:                     Button(action: {
2306:                         audioController.playButtonSound()
2307:                         // Presentar el ProfileViewController
2308:                         if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
2309:                            let window = windowScene.windows.first,
2310:                            let rootViewController = window.rootViewController {
2311:                             let profileVC = ProfileViewController()
2312:                             let navController = UINavigationController(rootViewController: profileVC)
2313:                             navController.modalPresentationStyle = .fullScreen
2314:                             rootViewController.present(navController, animated: true)
2315:                         }
2316:                     }) {
2317:                         HStack {
2318:                             Image(systemName: "person.fill")
2319:                             Text("Mi Perfil")
2320:                                 .font(.headline)
2321:                         }
2322:                         .frame(maxWidth: .infinity)
2323:                         .padding()
2324:                         .background(
2325:                             RoundedRectangle(cornerRadius: 15)
2326:                                 .fill(Color.red.opacity(0.8))
2327:                         )
2328:                         .foregroundColor(.white)
2329:                     }
2330:                 }
2331:                 .padding(.horizontal, 40)
2332:                 Spacer()
2333:                 Text(gameVersion)
2334:                     .font(.caption)
2335:                     .foregroundColor(.red)
2336:                     .padding(.bottom, 20)
2337:             }
2338:             .background(Color.white.ignoresSafeArea())
2339:             .navigationBarHidden(true)
2340:             // Navega a MusicBlocksSceneView cuando navigateToGame sea true
2341:             .navigationDestination(isPresented: $navigateToGame) {
2342:                 MusicBlocksSceneView()
2343:             }
2344:         }
2345:         .onAppear {
2346:             setupAudio()
2347:             loadGameVersion()
2348:             // Iniciar la música de fondo en el menú
2349:             audioController.startBackgroundMusic()
2350:         }
2351:         .onDisappear {
2352:             audioController.stop()
2353:         }
2354:     }
2355:     /// Solicita acceso al micrófono si es necesario.
2356:     private func setupAudio() {
2357:         AVCaptureDevice.requestAccess(for: .audio) { granted in
2358:             if granted {
2359:                 DispatchQueue.main.async {
2360:                     // Puedes iniciar alguna acción extra si lo deseas.
2361:                 }
2362:             }
2363:         }
2364:     }
2365:     /// Carga la versión del juego desde el archivo JSON.
2366:     private func loadGameVersion() {
2367:         if let gameConfig = GameLevelProcessor.loadGameLevelsFromFile() {
2368:             DispatchQueue.main.async {
2369:                 self.gameVersion = "v\(gameConfig.gameVersion)"
2370:             }
2371:         }
2372:     }
2373:     /// Secuencia para iniciar el juego:
2374:     /// 1. Reproduce el sonido de clic.
2375:     /// 2. Después de 0.2 s, inicia el fade out de la música (duración 0.5 s).
2376:     /// 3. Tras 0.6 s en total, navega a la escena del juego.
2377:     private func startGameSequence() {
2378:         audioController.playButtonSound()
2379:         DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
2380:             audioController.stopBackgroundMusic(duration: 0.3)
2381:             DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
2382:                 navigateToGame = true
2383:             }
2384:         }
2385:     }
2386: }
2387: struct ContentView_Previews: PreviewProvider {
2388:     static var previews: some View {
2389:         ContentView()
2390:     }
2391: }
2392: </file>
2393: <file path="MusicBlocks/Inicio y Profile/ExpandableSectionView.swift">
2394: //
2395: //  ExpandableSectionView.swift
2396: //  MusicBlocks
2397: //
2398: //  Created by Jose R. García on 1/3/25.
2399: //
2400: import UIKit
2401: protocol ExpandableSectionViewDelegate: AnyObject {
2402:     func expandableSectionDidToggle(_ section: ExpandableSectionView)
2403: }
2404: class ExpandableSectionView: UIView {
2405:     // MARK: - Properties
2406:     private let headerView: UIView = {
2407:         let view = UIView()
2408:         view.backgroundColor = .systemGray6
2409:         view.layer.cornerRadius = 10
2410:         return view
2411:     }()
2412:     private let iconImageView: UIImageView = {
2413:         let imageView = UIImageView()
2414:         imageView.contentMode = .scaleAspectFit
2415:         return imageView
2416:     }()
2417:     private let titleLabel: UILabel = {
2418:         let label = UILabel()
2419:         label.font = .systemFont(ofSize: 17, weight: .semibold)
2420:         return label
2421:     }()
2422:     private let chevronImageView: UIImageView = {
2423:         let config = UIImage.SymbolConfiguration(pointSize: 14)
2424:         let imageView = UIImageView()
2425:         imageView.image = UIImage(systemName: "chevron.down", withConfiguration: config)
2426:         imageView.tintColor = .secondaryLabel
2427:         imageView.contentMode = .scaleAspectFit
2428:         return imageView
2429:     }()
2430:     private var contentView: UIView?
2431:     private var isExpanded = false
2432:     weak var delegate: ExpandableSectionViewDelegate?
2433:     // Constraints que serán activadas/desactivadas
2434:     private var contentConstraints: [NSLayoutConstraint] = []
2435:     private var collapsedConstraint: NSLayoutConstraint?
2436:     // MARK: - Initialization
2437:     init(title: String, icon: UIImage?, iconTintColor: UIColor = .systemBlue) {
2438:         super.init(frame: .zero)
2439:         titleLabel.text = title
2440:         iconImageView.image = icon
2441:         iconImageView.tintColor = iconTintColor
2442:         setupViews()
2443:     }
2444:     required init?(coder: NSCoder) {
2445:         fatalError("init(coder:) has not been implemented")
2446:     }
2447:     // MARK: - Setup
2448:     private func setupViews() {
2449:         [headerView, iconImageView, titleLabel, chevronImageView].forEach {
2450:             $0.translatesAutoresizingMaskIntoConstraints = false
2451:         }
2452:         addSubview(headerView)
2453:         headerView.addSubview(iconImageView)
2454:         headerView.addSubview(titleLabel)
2455:         headerView.addSubview(chevronImageView)
2456:         setupConstraints()
2457:         setupGesture()
2458:     }
2459:     private func setupConstraints() {
2460:         NSLayoutConstraint.activate([
2461:             headerView.topAnchor.constraint(equalTo: topAnchor),
2462:             headerView.leadingAnchor.constraint(equalTo: leadingAnchor),
2463:             headerView.trailingAnchor.constraint(equalTo: trailingAnchor),
2464:             iconImageView.leadingAnchor.constraint(equalTo: headerView.leadingAnchor, constant: 16),
2465:             iconImageView.centerYAnchor.constraint(equalTo: headerView.centerYAnchor),
2466:             iconImageView.widthAnchor.constraint(equalToConstant: 24),
2467:             iconImageView.heightAnchor.constraint(equalToConstant: 24),
2468:             titleLabel.leadingAnchor.constraint(equalTo: iconImageView.trailingAnchor, constant: 12),
2469:             titleLabel.centerYAnchor.constraint(equalTo: headerView.centerYAnchor),
2470:             chevronImageView.trailingAnchor.constraint(equalTo: headerView.trailingAnchor, constant: -16),
2471:             chevronImageView.centerYAnchor.constraint(equalTo: headerView.centerYAnchor),
2472:             chevronImageView.widthAnchor.constraint(equalToConstant: 12),
2473:             chevronImageView.heightAnchor.constraint(equalToConstant: 12),
2474:             headerView.heightAnchor.constraint(equalToConstant: 50)
2475:         ])
2476:         // Crear constraint para el estado colapsado (hace que el bottom de la vista sea igual al bottom del header)
2477:         collapsedConstraint = bottomAnchor.constraint(equalTo: headerView.bottomAnchor)
2478:         // Activar el constraint de colapso inicialmente ya que empezamos colapsados
2479:         collapsedConstraint?.isActive = true
2480:     }
2481:     private func setupGesture() {
2482:         let tapGesture = UITapGestureRecognizer(target: self, action: #selector(handleHeaderTap))
2483:         headerView.addGestureRecognizer(tapGesture)
2484:         headerView.isUserInteractionEnabled = true
2485:     }
2486:     // MARK: - Public Methods
2487:     func setContentView(_ view: UIView) {
2488:         // Remover vista de contenido y constraints anteriores si existen
2489:         contentView?.removeFromSuperview()
2490:         NSLayoutConstraint.deactivate(contentConstraints)
2491:         contentConstraints.removeAll()
2492:         // Configurar nueva vista de contenido
2493:         contentView = view
2494:         if let contentView = contentView {
2495:             contentView.translatesAutoresizingMaskIntoConstraints = false
2496:             addSubview(contentView)
2497:             // Crear nuevas constraints para el contenido
2498:             let topConstraint = contentView.topAnchor.constraint(equalTo: headerView.bottomAnchor, constant: 8)
2499:             let leadingConstraint = contentView.leadingAnchor.constraint(equalTo: leadingAnchor)
2500:             let trailingConstraint = contentView.trailingAnchor.constraint(equalTo: trailingAnchor)
2501:             let bottomConstraint = contentView.bottomAnchor.constraint(equalTo: bottomAnchor)
2502:             // Guardar las constraints para poder activarlas/desactivarlas después
2503:             contentConstraints = [topConstraint, leadingConstraint, trailingConstraint, bottomConstraint]
2504:             // Si la sección está expandida, activar las constraints de contenido y desactivar la de colapso
2505:             if isExpanded {
2506:                 NSLayoutConstraint.activate(contentConstraints)
2507:                 collapsedConstraint?.isActive = false
2508:                 contentView.isHidden = false
2509:                 contentView.alpha = 1
2510:             } else {
2511:                 // Si está colapsada, ocultar el contenido y no activar sus constraints
2512:                 contentView.isHidden = true
2513:                 contentView.alpha = 0
2514:             }
2515:         }
2516:     }
2517:     // MARK: - Actions
2518:     @objc private func handleHeaderTap() {
2519:         toggleSection()
2520:     }
2521:     private func toggleSection() {
2522:         isExpanded.toggle()
2523:         UIView.animate(withDuration: 0.3) {
2524:             // Rotar el chevron
2525:             self.chevronImageView.transform = self.isExpanded ?
2526:                 CGAffineTransform(rotationAngle: .pi) :
2527:                 .identity
2528:             if self.isExpanded {
2529:                 // Expandir: desactivar constraint de colapso, activar constraints de contenido
2530:                 self.collapsedConstraint?.isActive = false
2531:                 NSLayoutConstraint.activate(self.contentConstraints)
2532:                 self.contentView?.isHidden = false
2533:                 self.contentView?.alpha = 1
2534:             } else {
2535:                 // Colapsar: desactivar constraints de contenido, activar constraint de colapso
2536:                 NSLayoutConstraint.deactivate(self.contentConstraints)
2537:                 self.collapsedConstraint?.isActive = true
2538:                 self.contentView?.isHidden = true
2539:                 self.contentView?.alpha = 0
2540:             }
2541:             // Forzar actualización del layout
2542:             self.superview?.layoutIfNeeded()
2543:         }
2544:         delegate?.expandableSectionDidToggle(self)
2545:     }
2546:     // MARK: - Layout
2547:     override func layoutSubviews() {
2548:         super.layoutSubviews()
2549:         // Aplicar sombra al header
2550:         headerView.layer.shadowColor = UIColor.black.cgColor
2551:         headerView.layer.shadowOffset = CGSize(width: 0, height: 2)
2552:         headerView.layer.shadowRadius = 4
2553:         headerView.layer.shadowOpacity = 0.1
2554:         headerView.layer.masksToBounds = false
2555:     }
2556: }
2557: </file>
2558: <file path="MusicBlocks/Inicio y Profile/MusicBlocksApp.swift">
2559: //
2560: //  MusicBlocksApp.swift
2561: //  MusicBlocks
2562: //
2563: //  Created by Jose R. García on 14/2/25.
2564: //
2565: import SwiftUI
2566: @main
2567: struct MusicBlocksApp: App {
2568:     var body: some Scene {
2569:         WindowGroup {
2570:             ContentView()
2571:         }
2572:     }
2573: }
2574: </file>
2575: <file path="MusicBlocks/Inicio y Profile/ProfileHeaderView.swift">
2576: //
2577: //  ProfileHeaderView.swift
2578: //  MusicBlocks
2579: //
2580: //  Created by Jose R. García on 1/3/25.
2581: //
2582: import UIKit
2583: protocol ProfileHeaderViewDelegate: AnyObject {
2584:     func profileHeaderView(_ view: ProfileHeaderView, didUpdateUsername username: String)
2585:     func profileHeaderViewDidTapAvatar(_ view: ProfileHeaderView)
2586: }
2587: class ProfileHeaderView: UIView {
2588:     // MARK: - Properties
2589:     private let avatarImageView: UIImageView = {
2590:         let imageView = UIImageView()
2591:         imageView.contentMode = .scaleAspectFit
2592:         imageView.layer.cornerRadius = 12
2593:         imageView.clipsToBounds = true
2594:         imageView.layer.borderWidth = 2
2595:         imageView.layer.borderColor = UIColor.systemRed.cgColor
2596:         return imageView
2597:     }()
2598:     private let editAvatarButton: UIButton = {
2599:         let button = UIButton()
2600:         let config = UIImage.SymbolConfiguration(pointSize: 30)
2601:         button.setImage(UIImage(systemName: "pencil.circle.fill", withConfiguration: config), for: .normal)
2602:         button.tintColor = .systemRed
2603:         button.backgroundColor = .white
2604:         button.layer.cornerRadius = 15
2605:         return button
2606:     }()
2607:     private let usernameLabel: UILabel = {
2608:             let label = UILabel()
2609:             label.font = .systemFont(ofSize: 20, weight: .medium)
2610:             label.textAlignment = .center
2611:             label.isUserInteractionEnabled = true
2612:             return label
2613:         }()
2614:     private func setupGestures() {
2615:         let tapGesture = UITapGestureRecognizer(target: self, action: #selector(usernameTapped))
2616:         usernameLabel.addGestureRecognizer(tapGesture)
2617:     }
2618:     @objc private func usernameTapped() {
2619:         handleUsernameTap()
2620:     }
2621:     private let editUsernameButton: UIButton = {
2622:         let button = UIButton()
2623:         let config = UIImage.SymbolConfiguration(pointSize: 14)
2624:         button.setImage(UIImage(systemName: "pencil", withConfiguration: config), for: .normal)
2625:         button.tintColor = .systemRed
2626:         return button
2627:     }()
2628:     weak var delegate: ProfileHeaderViewDelegate?
2629:     // MARK: - Initialization
2630:     override init(frame: CGRect) {
2631:         super.init(frame: frame)
2632:         setupViews()
2633:         setupGestures()
2634:     }
2635:     required init?(coder: NSCoder) {
2636:         fatalError("init(coder:) has not been implemented")
2637:     }
2638:     // MARK: - Setup
2639:     private func setupViews() {
2640:         [avatarImageView, editAvatarButton, usernameLabel, editUsernameButton].forEach {
2641:             $0.translatesAutoresizingMaskIntoConstraints = false
2642:             addSubview($0)
2643:         }
2644:         setupConstraints()
2645:         setupActions()
2646:     }
2647:     private func setupConstraints() {
2648:         NSLayoutConstraint.activate([
2649:             avatarImageView.topAnchor.constraint(equalTo: topAnchor, constant: 20),
2650:             avatarImageView.centerXAnchor.constraint(equalTo: centerXAnchor),
2651:             avatarImageView.widthAnchor.constraint(equalToConstant: 120),
2652:             avatarImageView.heightAnchor.constraint(equalToConstant: 160),
2653:             editAvatarButton.trailingAnchor.constraint(equalTo: avatarImageView.trailingAnchor, constant: 5),
2654:             editAvatarButton.bottomAnchor.constraint(equalTo: avatarImageView.bottomAnchor, constant: 5),
2655:             editAvatarButton.widthAnchor.constraint(equalToConstant: 30),
2656:             editAvatarButton.heightAnchor.constraint(equalToConstant: 30),
2657:             usernameLabel.topAnchor.constraint(equalTo: avatarImageView.bottomAnchor, constant: 15),
2658:             usernameLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
2659:             usernameLabel.bottomAnchor.constraint(equalTo: bottomAnchor),
2660:             editUsernameButton.leadingAnchor.constraint(equalTo: usernameLabel.trailingAnchor, constant: 5),
2661:             editUsernameButton.centerYAnchor.constraint(equalTo: usernameLabel.centerYAnchor)
2662:         ])
2663:     }
2664:     private func setupActions() {
2665:         editAvatarButton.addTarget(self, action: #selector(handleAvatarTap), for: .touchUpInside)
2666:         editUsernameButton.addTarget(self, action: #selector(handleUsernameTap), for: .touchUpInside)
2667:     }
2668:     // MARK: - Configuration
2669:     func configure(with profile: UserProfile) {
2670:         usernameLabel.text = profile.username
2671:         if profile.avatarName.isEmpty {
2672:             avatarImageView.image = UIImage(systemName: "person.circle.fill")
2673:             avatarImageView.tintColor = .systemRed
2674:         } else {
2675:             avatarImageView.image = UIImage(named: profile.avatarName)
2676:         }
2677:     }
2678:     // MARK: - Actions
2679:     @objc private func handleAvatarTap() {
2680:         delegate?.profileHeaderViewDidTapAvatar(self)
2681:     }
2682:     @objc private func handleUsernameTap() {
2683:         showEditUsernameAlert()
2684:     }
2685:     private func showEditUsernameAlert() {
2686:         let alert = UIAlertController(
2687:             title: "Editar nombre",
2688:             message: "Introduce tu nuevo nombre de usuario",
2689:             preferredStyle: .alert
2690:         )
2691:         alert.addTextField { textField in
2692:             textField.text = self.usernameLabel.text
2693:             textField.clearButtonMode = .whileEditing
2694:         }
2695:         alert.addAction(UIAlertAction(title: "Cancelar", style: .cancel))
2696:         alert.addAction(UIAlertAction(title: "Guardar", style: .default) { [weak self] _ in
2697:             guard let self = self,
2698:                   let textField = alert.textFields?.first,
2699:                   let newUsername = textField.text?.trimmingCharacters(in: .whitespacesAndNewlines),
2700:                   !newUsername.isEmpty else { return }
2701:             self.usernameLabel.text = newUsername
2702:             self.delegate?.profileHeaderView(self, didUpdateUsername: newUsername)
2703:         })
2704:         // Buscar el view controller más cercano para presentar el alert
2705:         if let viewController = self.findViewController() {
2706:             viewController.present(alert, animated: true)
2707:         } else {
2708:             // Fallback si no encontramos un view controller
2709:             if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
2710:                let window = windowScene.windows.first,
2711:                let rootViewController = window.rootViewController {
2712:                 var topViewController = rootViewController
2713:                 while let presentedViewController = topViewController.presentedViewController {
2714:                     topViewController = presentedViewController
2715:                 }
2716:                 topViewController.present(alert, animated: true)
2717:             }
2718:         }
2719:     }
2720:     // Método auxiliar para encontrar el view controller más cercano
2721:     private func findViewController() -> UIViewController? {
2722:         var responder: UIResponder? = self
2723:         while let nextResponder = responder?.next {
2724:             responder = nextResponder
2725:             if let viewController = responder as? UIViewController {
2726:                 return viewController
2727:             }
2728:         }
2729:         return nil
2730:     }
2731: }
2732: #if DEBUG
2733: import SwiftUI
2734: @available(iOS 17.0, *)
2735: struct ProfileHeaderView_Previews: PreviewProvider {
2736:     static var previews: some View {
2737:         // Preview en modo claro
2738:         ProfileHeaderViewRepresentable()
2739:             .frame(height: 250)
2740:             .padding()
2741:             .previewDisplayName("Light Mode")
2742:         // Preview en modo oscuro
2743:         ProfileHeaderViewRepresentable()
2744:             .frame(height: 250)
2745:             .padding()
2746:             .preferredColorScheme(.dark)
2747:             .previewDisplayName("Dark Mode")
2748:     }
2749:     private struct ProfileHeaderViewRepresentable: UIViewRepresentable {
2750:         func makeUIView(context: Context) -> ProfileHeaderView {
2751:             let view = ProfileHeaderView()
2752:             view.configure(with: UserProfile.mock)
2753:             return view
2754:         }
2755:         func updateUIView(_ uiView: ProfileHeaderView, context: Context) {}
2756:     }
2757: }
2758: extension UserProfile {
2759:     static var mock: UserProfile {
2760:         UserProfile(
2761:             username: "Usuario de Prueba",
2762:             avatarName: "avatar1",
2763:             statistics: Statistics(
2764:                 totalScore: 1000,
2765:                 currentLevel: 5,
2766:                 playTime: 3600,
2767:                 notesHit: 100,
2768:                 currentStreak: 5,
2769:                 bestStreak: 10,
2770:                 perfectLevelsCount: 2,
2771:                 totalGamesPlayed: 15,
2772:                 averageAccuracy: 0.85
2773:             ),
2774:             achievements: Achievements(
2775:                 unlockedMedals: [:],
2776:                 lastUpdateDate: Date()
2777:             )
2778:         )
2779:     }
2780: }
2781: #endif
2782: </file>
2783: <file path="MusicBlocks/Inicio y Profile/ProfileViewController.swift">
2784: //
2785: //  ProfileViewController.swift
2786: //  MusicBlocks
2787: //
2788: //  Created by Jose R. García on 1/3/25.
2789: //
2790: import UIKit
2791: import SpriteKit
2792: /// `ProfileViewController` maneja la visualización y gestión del perfil del usuario.
2793: /// Incluye la información del perfil, estadísticas y logros del usuario.
2794: class ProfileViewController: UIViewController {
2795:     // MARK: - Properties
2796:     /// El perfil del usuario actual cargado desde UserDefaults
2797:     private var profile = UserProfile.load()
2798:     /// Gestor singleton para manejar las medallas y logros
2799:     private let medalManager = MedalManager.shared
2800:     /// ScrollView principal que contiene todo el contenido del perfil
2801:     private var scrollView: UIScrollView!
2802:     /// Vista contenedora para todos los elementos del perfil
2803:     private var contentView: UIView!
2804:     /// Vista de cabecera que muestra la información básica del perfil (avatar y nombre)
2805:     private var profileHeaderView: ProfileHeaderView!
2806:     /// Sección expandible que muestra las estadísticas del usuario
2807:     private var statsSection: ExpandableSectionView!
2808:     /// Sección expandible que muestra los logros del usuario
2809:     private var achievementsSection: ExpandableSectionView!
2810:     // MARK: - Lifecycle
2811:     /// Configura la vista inicial cuando se carga el controlador
2812:     override func viewDidLoad() {
2813:         super.viewDidLoad()
2814:         setupNavigationBar()
2815:         setupViews()
2816:         loadProfile()
2817:     }
2818:     // MARK: - Setup
2819:     /// Configura la barra de navegación y el color de fondo
2820:     private func setupNavigationBar() {
2821:         title = "Perfil"
2822:         navigationController?.navigationBar.prefersLargeTitles = false
2823:         view.backgroundColor = .systemBackground
2824:         // Agregar botón para volver al menú principal
2825:         let menuButton = UIBarButtonItem(
2826:             image: UIImage(systemName: "house.fill"),
2827:             style: .plain,
2828:             target: self,
2829:             action: #selector(returnToMainMenu)
2830:         )
2831:         menuButton.tintColor = .systemRed
2832:         navigationItem.leftBarButtonItem = menuButton
2833:     }
2834:     /// Acción para volver al menú principal (ContentView)
2835:     @objc private func returnToMainMenu() {
2836:         // Cerrar este view controller y volver al ContentView
2837:         dismiss(animated: true)
2838:     }
2839:     /// Configura todas las vistas y su jerarquía
2840:     private func setupViews() {
2841:         // Setup ScrollView
2842:         scrollView = UIScrollView()
2843:         scrollView.translatesAutoresizingMaskIntoConstraints = false
2844:         scrollView.backgroundColor = .systemBackground
2845:         view.addSubview(scrollView)
2846:         // Setup ContentView - Contenedor principal
2847:         contentView = UIView()
2848:         contentView.translatesAutoresizingMaskIntoConstraints = false
2849:         contentView.backgroundColor = .systemBackground
2850:         scrollView.addSubview(contentView)
2851:         // Setup ProfileHeaderView - Vista de cabecera del perfil
2852:         profileHeaderView = ProfileHeaderView()
2853:         profileHeaderView.translatesAutoresizingMaskIntoConstraints = false
2854:         profileHeaderView.delegate = self
2855:         contentView.addSubview(profileHeaderView)
2856:         // Setup StatsSection - Sección de estadísticas
2857:         statsSection = ExpandableSectionView(
2858:             title: "Estadísticas",
2859:             icon: UIImage(systemName: "chart.bar.fill"),
2860:             iconTintColor: .systemRed
2861:         )
2862:         statsSection.translatesAutoresizingMaskIntoConstraints = false
2863:         statsSection.delegate = self
2864:         contentView.addSubview(statsSection)
2865:         // Setup AchievementsSection - Sección de logros
2866:         achievementsSection = ExpandableSectionView(
2867:             title: "Logros",
2868:             icon: UIImage(systemName: "trophy.fill"),
2869:             iconTintColor: .systemYellow
2870:         )
2871:         achievementsSection.translatesAutoresizingMaskIntoConstraints = false
2872:         achievementsSection.delegate = self
2873:         contentView.addSubview(achievementsSection)
2874:         setupConstraints()
2875:     }
2876:     /// Configura las constraints de todas las vistas
2877:     private func setupConstraints() {
2878:         NSLayoutConstraint.activate([
2879:             // ScrollView - Ocupa todo el espacio disponible
2880:             scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
2881:             scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
2882:             scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
2883:             scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
2884:             // ContentView - Se ajusta al ancho del ScrollView
2885:             contentView.topAnchor.constraint(equalTo: scrollView.topAnchor),
2886:             contentView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor),
2887:             contentView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor),
2888:             contentView.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
2889:             contentView.widthAnchor.constraint(equalTo: scrollView.widthAnchor),
2890:             // ProfileHeaderView - Margen superior e inferior
2891:             profileHeaderView.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 20),
2892:             profileHeaderView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20),
2893:             profileHeaderView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20),
2894:             // StatsSection - Separación respecto al header
2895:             statsSection.topAnchor.constraint(equalTo: profileHeaderView.bottomAnchor, constant: 20),
2896:             statsSection.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20),
2897:             statsSection.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20),
2898:             // AchievementsSection - Espaciado reducido respecto a stats
2899:             achievementsSection.topAnchor.constraint(equalTo: statsSection.bottomAnchor, constant: 8),
2900:             achievementsSection.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20),
2901:             achievementsSection.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20),
2902:             achievementsSection.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -20)
2903:         ])
2904:     }
2905:     /// Carga y configura los datos del perfil en las vistas
2906:     private func loadProfile() {
2907:         profileHeaderView.configure(with: profile)
2908:         updateStats()
2909:         updateAchievements()
2910:     }
2911:     /// Actualiza la vista de estadísticas con los datos actuales
2912:     private func updateStats() {
2913:         let statsView = StatsView(statistics: profile.statistics)
2914:         statsView.delegate = self  // Esta línea es la que falta
2915:         statsSection.setContentView(statsView)
2916:     }
2917:     /// Actualiza la vista de logros con las medallas actuales
2918:     private func updateAchievements() {
2919:         let achievementsView = AchievementsView(medals: medalManager.getMedals())
2920:         achievementsSection.setContentView(achievementsView)
2921:     }
2922:     /// Maneja la visualización del alert para editar el nombre de usuario
2923:     private func showEditUsernameAlert(currentUsername: String) {
2924:         // Asegurarnos de que estamos en el hilo principal
2925:         DispatchQueue.main.async {
2926:             let alertController = UIAlertController(
2927:                 title: "Editar Nombre",
2928:                 message: "Introduce tu nuevo nombre de usuario",
2929:                 preferredStyle: .alert
2930:             )
2931:             // Añadir campo de texto
2932:             alertController.addTextField { textField in
2933:                 textField.text = currentUsername
2934:                 textField.placeholder = "Nombre de usuario"
2935:                 textField.autocapitalizationType = .words
2936:             }
2937:             // Acción de guardar
2938:             let saveAction = UIAlertAction(title: "Guardar", style: .default) { [weak self] _ in
2939:                 guard let self = self,
2940:                       let textField = alertController.textFields?.first,
2941:                       let newUsername = textField.text?.trimmingCharacters(in: .whitespacesAndNewlines),
2942:                       !newUsername.isEmpty else {
2943:                     return
2944:                 }
2945:                 // Actualizar el nombre de usuario
2946:                 self.profile.username = newUsername
2947:                 self.profile.save()
2948:                 // Actualizar la interfaz
2949:                 self.profileHeaderView.configure(with: self.profile)
2950:             }
2951:             // Acción de cancelar
2952:             let cancelAction = UIAlertAction(title: "Cancelar", style: .cancel)
2953:             alertController.addAction(saveAction)
2954:             alertController.addAction(cancelAction)
2955:             // Presentar el alert desde el presentador correcto
2956:             if let presentingController = self.presentingViewController {
2957:                 presentingController.present(alertController, animated: true)
2958:             } else {
2959:                 self.present(alertController, animated: true)
2960:             }
2961:         }
2962:     }
2963:     /// Obtiene el view controller más alto en la jerarquía
2964:     private func getTopViewController() -> UIViewController? {
2965:         // Obtener la escena activa y su ventana
2966:         guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
2967:               let keyWindow = windowScene.windows.first(where: { $0.isKeyWindow }) else {
2968:             return nil
2969:         }
2970:         var topController = keyWindow.rootViewController
2971:         while let presentedController = topController?.presentedViewController {
2972:             topController = presentedController
2973:         }
2974:         return topController
2975:     }
2976: }
2977: // MARK: - ProfileHeaderViewDelegate
2978: extension ProfileViewController: ProfileHeaderViewDelegate {
2979:     /// Maneja la actualización del nombre de usuario
2980:     func profileHeaderView(_ view: ProfileHeaderView, didUpdateUsername username: String) {
2981:         // Aquí simplemente actualizamos el modelo con el nuevo nombre
2982:         profile.username = username
2983:         profile.save()
2984:     }
2985:     /// Maneja la selección del avatar mostrando el picker
2986:     func profileHeaderViewDidTapAvatar(_ view: ProfileHeaderView) {
2987:         let avatarPicker = AvatarPickerViewController(
2988:             selectedAvatar: profile.avatarName,
2989:             availableAvatars: ["avatar1", "avatar2", "avatar3", "avatar4", "avatar5", "avatar6", "avatar7", "avatar8", "avatar9", "avatar10", "avatar11", "avatar12", "avatar13", "avatar14"]
2990:         )
2991:         avatarPicker.delegate = self
2992:         let nav = UINavigationController(rootViewController: avatarPicker)
2993:         present(nav, animated: true)
2994:     }
2995: }
2996: // MARK: - AvatarPickerViewControllerDelegate
2997: extension ProfileViewController: AvatarPickerViewControllerDelegate {
2998:     /// Maneja la selección de un nuevo avatar
2999:     func avatarPicker(_ picker: AvatarPickerViewController, didSelect avatar: String) {
3000:         profile.avatarName = avatar
3001:         profile.save()
3002:         profileHeaderView.configure(with: profile)
3003:         dismiss(animated: true)
3004:     }
3005: }
3006: // MARK: - ExpandableSectionViewDelegate
3007: extension ProfileViewController: ExpandableSectionViewDelegate {
3008:     /// Anima los cambios cuando una sección se expande o colapsa
3009:     func expandableSectionDidToggle(_ section: ExpandableSectionView) {
3010:         UIView.animate(withDuration: 0.3) {
3011:             self.view.layoutIfNeeded()
3012:         }
3013:     }
3014: }
3015: // Añadir conformidad al protocolo StatsViewDelegate en la clase ProfileViewController
3016: extension ProfileViewController: StatsViewDelegate {
3017:     func statsViewDidTapResetButton(_ statsView: StatsView) {
3018:         // Mostrar alerta de confirmación
3019:         let alert = UIAlertController(
3020:             title: "Borrar datos",
3021:             message: "¿Estás seguro de que deseas borrar todas tus estadísticas? Esta acción no se puede deshacer.",
3022:             preferredStyle: .alert
3023:         )
3024:         // Acción para confirmar el borrado
3025:         let resetAction = UIAlertAction(title: "Borrar", style: .destructive) { [weak self] _ in
3026:             guard let self = self else { return }
3027:             // Crear estadísticas nuevas (resetear todo a valores iniciales)
3028:             self.profile.statistics = Statistics()
3029:             self.profile.save()
3030:             // Actualizar la vista con las estadísticas reseteadas
3031:             self.updateStats()
3032:             // Mostrar mensaje de confirmación
3033:             self.showToast(message: "Estadísticas restablecidas")
3034:         }
3035:         // Acción para cancelar
3036:         let cancelAction = UIAlertAction(title: "Cancelar", style: .cancel)
3037:         alert.addAction(resetAction)
3038:         alert.addAction(cancelAction)
3039:         // Presentar la alerta
3040:         present(alert, animated: true)
3041:     }
3042:     // Método auxiliar para mostrar un mensaje toast
3043:     private func showToast(message: String) {
3044:         let toastLabel = UILabel()
3045:         toastLabel.backgroundColor = UIColor.black.withAlphaComponent(0.7)
3046:         toastLabel.textColor = .white
3047:         toastLabel.textAlignment = .center
3048:         toastLabel.font = UIFont.systemFont(ofSize: 14)
3049:         toastLabel.text = message
3050:         toastLabel.alpha = 0
3051:         toastLabel.layer.cornerRadius = 10
3052:         toastLabel.clipsToBounds = true
3053:         view.addSubview(toastLabel)
3054:         toastLabel.translatesAutoresizingMaskIntoConstraints = false
3055:         NSLayoutConstraint.activate([
3056:             toastLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),
3057:             toastLabel.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -20),
3058:             toastLabel.widthAnchor.constraint(lessThanOrEqualTo: view.widthAnchor, multiplier: 0.7),
3059:             toastLabel.heightAnchor.constraint(equalToConstant: 40)
3060:         ])
3061:         UIView.animate(withDuration: 0.5, animations: {
3062:             toastLabel.alpha = 1
3063:         }, completion: { _ in
3064:             UIView.animate(withDuration: 0.5, delay: 1.5, options: .curveEaseOut, animations: {
3065:                 toastLabel.alpha = 0
3066:             }, completion: { _ in
3067:                 toastLabel.removeFromSuperview()
3068:             })
3069:         })
3070:     }
3071: }
3072: #if DEBUG
3073: // MARK: - SwiftUI Preview
3074: import SwiftUI
3075: struct ProfileViewControllerPreview: UIViewControllerRepresentable {
3076:     func makeUIViewController(context: Context) -> ProfileViewController {
3077:         // Crear datos de ejemplo para la preview
3078:         let profile = UserProfile(
3079:             username: "Jugador de Prueba",
3080:             avatarName: "avatar1",
3081:             statistics: Statistics(
3082:                 totalScore: 2500,
3083:                 currentLevel: 7,
3084:                 playTime: 7200, // 2 horas
3085:                 notesHit: 450,
3086:                 currentStreak: 15,
3087:                 bestStreak: 25,
3088:                 perfectLevelsCount: 5,
3089:                 totalGamesPlayed: 35,
3090:                 averageAccuracy: 0.88
3091:             ),
3092:             achievements: Achievements(
3093:                 unlockedMedals: [
3094:                     MedalType.notesHit.rawValue: [true, true, false],
3095:                     MedalType.playTime.rawValue: [true, true, false],
3096:                     MedalType.streaks.rawValue: [true, true, true],
3097:                     MedalType.perfectTuning.rawValue: [true, true, false]
3098:                 ],
3099:                 lastUpdateDate: Date()
3100:             )
3101:         )
3102:         profile.save()
3103:         // Crear y devolver el view controller
3104:         let profileVC = ProfileViewController()
3105:         return profileVC
3106:     }
3107:     func updateUIViewController(_ uiViewController: ProfileViewController, context: Context) {
3108:         // No es necesario actualizar nada aquí
3109:     }
3110: }
3111: struct ProfileViewController_Preview: PreviewProvider {
3112:     static var previews: some View {
3113:         // Vista de previsualización para modo claro y oscuro
3114:         Group {
3115:             ProfileViewControllerPreview()
3116:                 .edgesIgnoringSafeArea(.all)
3117:                 .preferredColorScheme(.light)
3118:                 .previewDisplayName("Perfil - Modo Claro")
3119:             ProfileViewControllerPreview()
3120:                 .edgesIgnoringSafeArea(.all)
3121:                 .preferredColorScheme(.dark)
3122:                 .previewDisplayName("Perfil - Modo Oscuro")
3123:         }
3124:     }
3125: }
3126: #endif
3127: </file>
3128: <file path="MusicBlocks/Inicio y Profile/StatsView.swift">
3129: //
3130: //  StatsView.swift
3131: //  MusicBlocks
3132: //
3133: //  Created by Jose R. García on 8/3/25.
3134: //
3135: import UIKit
3136: protocol StatsViewDelegate: AnyObject {
3137:     func statsViewDidTapResetButton(_ statsView: StatsView)
3138: }
3139: class StatsView: UIView {
3140:     // MARK: - Properties
3141:     weak var delegate: StatsViewDelegate?
3142:     private let stackView: UIStackView = {
3143:         let stack = UIStackView()
3144:         stack.axis = .vertical
3145:         stack.spacing = 12
3146:         stack.distribution = .fill
3147:         return stack
3148:     }()
3149:     private let resetButton: UIButton = {
3150:         var configuration = UIButton.Configuration.plain()
3151:         // Configurar el contenido
3152:         configuration.image = UIImage(systemName: "trash")
3153:         configuration.title = "Borrar datos"
3154:         configuration.imagePadding = 5 // Espaciado entre imagen y texto
3155:         // Configurar el estilo
3156:         configuration.baseForegroundColor = .systemRed
3157:         configuration.contentInsets = NSDirectionalEdgeInsets(top: 5, leading: 10, bottom: 5, trailing: 10)
3158:         // Crear el botón con la configuración
3159:         let button = UIButton(configuration: configuration)
3160:         // Configurar el borde
3161:         button.layer.borderColor = UIColor.systemRed.cgColor
3162:         button.layer.borderWidth = 1
3163:         button.layer.cornerRadius = 8
3164:         return button
3165:     }()
3166:     init(statistics: Statistics) {
3167:         super.init(frame: .zero)
3168:         setupViews()
3169:         configure(with: statistics)
3170:         setupActions()
3171:     }
3172:     required init?(coder: NSCoder) {
3173:         fatalError("init(coder:) has not been implemented")
3174:     }
3175:     private func setupViews() {
3176:         stackView.translatesAutoresizingMaskIntoConstraints = false
3177:         resetButton.translatesAutoresizingMaskIntoConstraints = false
3178:         addSubview(stackView)
3179:         addSubview(resetButton)
3180:         NSLayoutConstraint.activate([
3181:             stackView.topAnchor.constraint(equalTo: topAnchor, constant: 8),
3182:             stackView.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
3183:             stackView.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
3184:             resetButton.topAnchor.constraint(equalTo: stackView.bottomAnchor, constant: 16),
3185:             resetButton.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
3186:             resetButton.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -8)
3187:         ])
3188:     }
3189:     private func setupActions() {
3190:             // Añadir acción al botón de reset
3191:             resetButton.addTarget(self, action: #selector(resetButtonTapped), for: .touchUpInside)
3192:         }
3193:     @objc private func resetButtonTapped() {
3194:         print("Botón de reset tocado") // Añadir para depuración
3195:         // Notificar al delegado que se ha pulsado el botón de reset
3196:         delegate?.statsViewDidTapResetButton(self)
3197:     }
3198:     private func configure(with statistics: Statistics) {
3199:             // Limpiar vista previa
3200:             stackView.arrangedSubviews.forEach { $0.removeFromSuperview() }
3201:             // Sección de Puntuación
3202:             addSectionHeader("Puntuación")
3203:             addStatRow(title: "Puntuación Total", value: statistics.formattedTotalScore)
3204:             addStatRow(title: "Nivel Actual", value: "\(statistics.currentLevel)")
3205:             // Sección de Partidas
3206:             addSectionHeader("Partidas")
3207:             addStatRow(title: "Total Jugadas", value: "\(statistics.totalGamesPlayed)")
3208:             addStatRow(title: "Ganadas", value: "\(statistics.gamesWon)")
3209:             addStatRow(title: "Perdidas", value: "\(statistics.gamesLost)")
3210:             let winRate = statistics.totalGamesPlayed > 0 ?
3211:                 Double(statistics.gamesWon) / Double(statistics.totalGamesPlayed) * 100 : 0
3212:             addStatRow(title: "Ratio Victoria", value: String(format: "%.1f%%", winRate))
3213:             // Sección de Rendimiento
3214:             addSectionHeader("Rendimiento")
3215:             addStatRow(title: "Notas Acertadas", value: "\(statistics.notesHit)")
3216:             addStatRow(title: "Mejor Racha", value: "\(statistics.bestStreak)")
3217:             addStatRow(title: "Precisión Media", value: statistics.formattedAccuracy)
3218:             addStatRow(title: "Niveles Perfectos", value: "\(statistics.perfectLevelsCount)")
3219:             // Sección de Tiempo
3220:             addSectionHeader("Tiempo")
3221:             addStatRow(title: "Tiempo Total", value: statistics.formattedPlayTime)
3222:         }
3223:     private func addSectionHeader(_ title: String) {
3224:             let headerView = SectionHeaderView(title: title)
3225:             stackView.addArrangedSubview(headerView)
3226:             // Añadir un pequeño espaciado después del header
3227:             let spacer = UIView()
3228:             spacer.heightAnchor.constraint(equalToConstant: 8).isActive = true
3229:             stackView.addArrangedSubview(spacer)
3230:         }
3231:     private func addStatRow(title: String, value: String) {
3232:         let row = StatRowView(title: title, value: value)
3233:         stackView.addArrangedSubview(row)
3234:     }
3235: }
3236: class StatRowView: UIView {
3237:     private let titleLabel: UILabel = {
3238:         let label = UILabel()
3239:         label.font = .systemFont(ofSize: 15)
3240:         label.textColor = .secondaryLabel
3241:         return label
3242:     }()
3243:     private let valueLabel: UILabel = {
3244:         let label = UILabel()
3245:         label.font = .systemFont(ofSize: 15, weight: .medium)
3246:         label.textColor = .label
3247:         return label
3248:     }()
3249:     init(title: String, value: String) {
3250:         super.init(frame: .zero)
3251:         titleLabel.text = title
3252:         valueLabel.text = value
3253:         setupViews()
3254:     }
3255:     required init?(coder: NSCoder) {
3256:         fatalError("init(coder:) has not been implemented")
3257:     }
3258:     private func setupViews() {
3259:         [titleLabel, valueLabel].forEach {
3260:             $0.translatesAutoresizingMaskIntoConstraints = false
3261:             addSubview($0)
3262:         }
3263:         NSLayoutConstraint.activate([
3264:             titleLabel.leadingAnchor.constraint(equalTo: leadingAnchor),
3265:             titleLabel.centerYAnchor.constraint(equalTo: centerYAnchor),
3266:             valueLabel.trailingAnchor.constraint(equalTo: trailingAnchor),
3267:             valueLabel.centerYAnchor.constraint(equalTo: centerYAnchor),
3268:             heightAnchor.constraint(equalToConstant: 30)
3269:         ])
3270:     }
3271: }
3272: // Nuevo componente para los headers de sección
3273: class SectionHeaderView: UIView {
3274:     private let titleLabel: UILabel = {
3275:         let label = UILabel()
3276:         label.font = .systemFont(ofSize: 17, weight: .bold)
3277:         label.textColor = .systemPurple
3278:         return label
3279:     }()
3280:     private let separatorLine: UIView = {
3281:         let view = UIView()
3282:         view.backgroundColor = .systemPurple.withAlphaComponent(0.3)
3283:         return view
3284:     }()
3285:     init(title: String) {
3286:         super.init(frame: .zero)
3287:         titleLabel.text = title
3288:         setupViews()
3289:     }
3290:     required init?(coder: NSCoder) {
3291:         fatalError("init(coder:) has not been implemented")
3292:     }
3293:     private func setupViews() {
3294:         [titleLabel, separatorLine].forEach {
3295:             $0.translatesAutoresizingMaskIntoConstraints = false
3296:             addSubview($0)
3297:         }
3298:         NSLayoutConstraint.activate([
3299:             titleLabel.topAnchor.constraint(equalTo: topAnchor),
3300:             titleLabel.leadingAnchor.constraint(equalTo: leadingAnchor),
3301:             separatorLine.leadingAnchor.constraint(equalTo: leadingAnchor),
3302:             separatorLine.trailingAnchor.constraint(equalTo: trailingAnchor),
3303:             separatorLine.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 4),
3304:             separatorLine.bottomAnchor.constraint(equalTo: bottomAnchor),
3305:             separatorLine.heightAnchor.constraint(equalToConstant: 1)
3306:         ])
3307:     }
3308: }
3309: // Actualizar la preview
3310: #if DEBUG
3311: import SwiftUI
3312: @available(iOS 17.0, *)
3313: struct StatsView_Previews: PreviewProvider {
3314:     static var previews: some View {
3315:         StatsViewRepresentable()
3316:             .padding()
3317:             .previewDisplayName("Light Mode")
3318:         StatsViewRepresentable()
3319:             .padding()
3320:             .preferredColorScheme(.dark)
3321:             .previewDisplayName("Dark Mode")
3322:     }
3323:     private struct StatsViewRepresentable: UIViewRepresentable {
3324:         func makeUIView(context: Context) -> StatsView {
3325:             let mockStats = Statistics(
3326:                 totalScore: 1500,
3327:                 currentLevel: 5,
3328:                 playTime: 3600,
3329:                 notesHit: 250,
3330:                 currentStreak: 10,
3331:                 bestStreak: 15,
3332:                 perfectLevelsCount: 3,
3333:                 totalGamesPlayed: 20,
3334:                 averageAccuracy: 0.83,
3335:                 gamesWon: 12,
3336:                 gamesLost: 8
3337:             )
3338:             return StatsView(statistics: mockStats)
3339:         }
3340:         func updateUIView(_ uiView: StatsView, context: Context) {}
3341:     }
3342: }
3343: #endif
3344: </file>
3345: <file path="MusicBlocks/Inicio y Profile/UserProfile.swift">
3346: //
3347: //  UserProfile.swift
3348: //  MusicBlocks
3349: //
3350: //  Created by Jose R. García on 8/3/25.
3351: //
3352: import Foundation
3353: /// Estructura principal que representa el perfil del usuario en el juego.
3354: /// Contiene toda la información personal, estadísticas y logros del jugador.
3355: struct UserProfile: Codable {
3356:     /// Nombre de usuario mostrado en el perfil
3357:     var username: String
3358:     /// Nombre del avatar seleccionado por el usuario
3359:     var avatarName: String
3360:     /// Estadísticas acumuladas del jugador
3361:     var statistics: Statistics
3362:     /// Logros y medallas desbloqueadas
3363:     var achievements: Achievements
3364:     /// Nombre de usuario por defecto para nuevos perfiles
3365:     static let defaultUsername = "Pequeño músico"
3366:     /// Avatar por defecto para nuevos perfiles
3367:     static let defaultAvatarName = "avatar1"
3368:     /// Inicializador con valores por defecto para crear un nuevo perfil
3369:     /// - Parameters:
3370:     ///   - username: Nombre de usuario, por defecto "Pequeño músico"
3371:     ///   - avatarName: Nombre del avatar, por defecto "avatar1"
3372:     ///   - statistics: Estadísticas iniciales
3373:     ///   - achievements: Logros iniciales
3374:     init(username: String = defaultUsername,
3375:          avatarName: String = defaultAvatarName,
3376:          statistics: Statistics = Statistics(),
3377:          achievements: Achievements = Achievements()) {
3378:         self.username = username
3379:         self.avatarName = avatarName
3380:         self.statistics = statistics
3381:         self.achievements = achievements
3382:     }
3383:     /// Carga el perfil del usuario desde UserDefaults
3384:     /// - Returns: El perfil guardado o un nuevo perfil con valores por defecto
3385:     static func load() -> UserProfile {
3386:         if let data = UserDefaults.standard.data(forKey: "userProfile"),
3387:            let profile = try? JSONDecoder().decode(UserProfile.self, from: data) {
3388:             return profile
3389:         }
3390:         return UserProfile()
3391:     }
3392:     /// Guarda el perfil actual en UserDefaults
3393:     func save() {
3394:         if let encoded = try? JSONEncoder().encode(self) {
3395:             UserDefaults.standard.set(encoded, forKey: "userProfile")
3396:         }
3397:     }
3398: }
3399: // MARK: - Statistics
3400: /// Estructura que mantiene todas las estadísticas del jugador
3401: struct Statistics: Codable {
3402:     /// Puntuación total acumulada en todos los juegos
3403:     var totalScore: Int
3404:     /// Nivel actual del jugador
3405:     var currentLevel: Int
3406:     /// Tiempo total de juego en segundos
3407:     var playTime: TimeInterval
3408:     /// Número total de notas acertadas
3409:     var notesHit: Int
3410:     /// Racha actual de notas acertadas consecutivas
3411:     var currentStreak: Int
3412:     /// Mejor racha de notas acertadas consecutivas
3413:     var bestStreak: Int
3414:     /// Número de niveles completados con precisión perfecta
3415:     var perfectLevelsCount: Int
3416:     /// Número total de partidas jugadas
3417:     var totalGamesPlayed: Int
3418:     /// Precisión promedio en todas las partidas (0.0 a 1.0)
3419:     var averageAccuracy: Double
3420:     /// Número total de partidas ganadas
3421:     var gamesWon: Int
3422:     /// Número total de partidas perdidas
3423:     var gamesLost: Int
3424:     /// Inicializador con valores por defecto para nuevas estadísticas
3425:     init(totalScore: Int = 0,
3426:          currentLevel: Int = 0,
3427:          playTime: TimeInterval = 0,
3428:          notesHit: Int = 0,
3429:          currentStreak: Int = 0,
3430:          bestStreak: Int = 0,
3431:          perfectLevelsCount: Int = 0,
3432:          totalGamesPlayed: Int = 0,
3433:          averageAccuracy: Double = 0.0,
3434:          gamesWon: Int = 0,
3435:          gamesLost: Int = 0) {
3436:         self.totalScore = totalScore
3437:         self.currentLevel = currentLevel
3438:         self.playTime = playTime
3439:         self.notesHit = notesHit
3440:         self.currentStreak = currentStreak
3441:         self.bestStreak = bestStreak
3442:         self.perfectLevelsCount = perfectLevelsCount
3443:         self.totalGamesPlayed = totalGamesPlayed
3444:         self.averageAccuracy = averageAccuracy
3445:         self.gamesWon = gamesWon
3446:         self.gamesLost = gamesLost
3447:     }
3448:     /// Actualiza la precisión promedio con un nuevo valor
3449:     /// - Parameter newAccuracy: Nueva precisión a incorporar en el promedio (0.0 a 1.0)
3450:     mutating func updateAccuracy(with newAccuracy: Double) {
3451:         if totalGamesPlayed == 0 {
3452:             averageAccuracy = newAccuracy
3453:         } else {
3454:             let totalAccuracy = averageAccuracy * Double(totalGamesPlayed)
3455:             averageAccuracy = (totalAccuracy + newAccuracy) / Double(totalGamesPlayed + 1)
3456:         }
3457:         totalGamesPlayed += 1
3458:     }
3459:     /// Actualiza la racha actual y, si corresponde, la mejor racha
3460:     /// - Parameter hitNote: true si acertó la nota, false si falló
3461:     mutating func updateStreak(hitNote: Bool) {
3462:         if hitNote {
3463:             currentStreak += 1
3464:             if currentStreak > bestStreak {
3465:                 bestStreak = currentStreak
3466:             }
3467:         } else {
3468:             currentStreak = 0
3469:         }
3470:     }
3471:     /// Añade tiempo de juego al total
3472:     /// - Parameter time: Tiempo a añadir en segundos
3473:     mutating func addPlayTime(_ time: TimeInterval) {
3474:         playTime += time
3475:     }
3476: }
3477: // MARK: - Achievements
3478: /// Estructura que gestiona los logros y medallas del jugador
3479: struct Achievements: Codable {
3480:     /// Diccionario que almacena el estado de desbloqueo de las medallas
3481:     /// La clave es el tipo de medalla y el valor es un array de booleanos
3482:     var unlockedMedals: [String: [Bool]]
3483:     /// Fecha de la última actualización de los logros
3484:     var lastUpdateDate: Date
3485:     /// Inicializador con valores por defecto para nuevos logros
3486:     init(unlockedMedals: [String: [Bool]] = [:], lastUpdateDate: Date = Date()) {
3487:         self.unlockedMedals = unlockedMedals
3488:         self.lastUpdateDate = lastUpdateDate
3489:     }
3490:     /// Actualiza el estado de una medalla específica
3491:     /// - Parameters:
3492:     ///   - type: Tipo de medalla
3493:     ///   - index: Índice de la medalla en su categoría
3494:     ///   - isUnlocked: true si se ha desbloqueado, false si no
3495:     mutating func updateMedal(type: MedalType, index: Int, isUnlocked: Bool) {
3496:         if unlockedMedals[type.rawValue] == nil {
3497:             unlockedMedals[type.rawValue] = Array(repeating: false, count: 5)
3498:         }
3499:         unlockedMedals[type.rawValue]?[index] = isUnlocked
3500:         lastUpdateDate = Date()
3501:     }
3502:     /// Verifica si una medalla específica está desbloqueada
3503:     /// - Parameters:
3504:     ///   - type: Tipo de medalla
3505:     ///   - index: Índice de la medalla en su categoría
3506:     /// - Returns: true si está desbloqueada, false si no
3507:     func isMedalUnlocked(type: MedalType, index: Int) -> Bool {
3508:         return unlockedMedals[type.rawValue]?[index] ?? false
3509:     }
3510: }
3511: // MARK: - Formatters
3512: extension Statistics {
3513:     /// Devuelve el tiempo de juego formateado (ej: "1:30 h" o "45 min")
3514:     var formattedPlayTime: String {
3515:         let hours = Int(playTime) / 3600
3516:         let minutes = Int(playTime) / 60 % 60
3517:         if hours > 0 {
3518:             return String(format: "%d:%02d h", hours, minutes)
3519:         } else {
3520:             return String(format: "%d min", minutes)
3521:         }
3522:     }
3523:     /// Devuelve la puntuación total formateada con separadores locales
3524:     var formattedTotalScore: String {
3525:         return NumberFormatter.localizedString(from: NSNumber(value: totalScore), number: .decimal)
3526:     }
3527:     /// Devuelve la precisión promedio formateada como porcentaje
3528:     var formattedAccuracy: String {
3529:         return String(format: "%.1f%%", averageAccuracy * 100)
3530:     }
3531: }
3532: // MARK: - Helper Methods
3533: extension UserProfile {
3534:     /// Actualiza las estadísticas del jugador después de una partida o acción
3535:     /// - Parameters:
3536:     ///   - score: Puntos ganados en la partida
3537:     ///   - noteHit: Indica si se acertó una nota
3538:     ///   - accuracy: Precisión de la partida (0.0 a 1.0)
3539:     ///   - levelCompleted: Indica si se completó un nivel
3540:     ///   - isPerfect: Indica si el nivel se completó con precisión perfecta
3541:     ///   - playTime: Tiempo jugado en la partida
3542:     mutating func updateStatistics(score: Int = 0,
3543:                                  noteHit: Bool = false,
3544:                                  accuracy: Double? = nil,
3545:                                  levelCompleted: Bool = false,
3546:                                  isPerfect: Bool = false,
3547:                                  playTime: TimeInterval = 0,
3548:                                  gamesWon: Int = 0,
3549:                                  gamesLost: Int = 0) {
3550:         statistics.totalScore += score
3551:         if noteHit {
3552:             statistics.notesHit += 1
3553:             statistics.updateStreak(hitNote: true)
3554:         } else {
3555:             statistics.updateStreak(hitNote: false)
3556:         }
3557:         if let accuracy = accuracy {
3558:             statistics.updateAccuracy(with: accuracy)
3559:         }
3560:         if levelCompleted {
3561:             statistics.currentLevel += 1
3562:             if isPerfect {
3563:                 statistics.perfectLevelsCount += 1
3564:             }
3565:         }
3566:         if playTime > 0 {
3567:             statistics.addPlayTime(playTime)
3568:         }
3569:         // Actualizar estadísticas de partidas
3570:             statistics.gamesWon += gamesWon
3571:             statistics.gamesLost += gamesLost
3572:             statistics.totalGamesPlayed = statistics.gamesWon + statistics.gamesLost
3573:             // Actualizar medallas
3574:             MedalManager.shared.updateMedals(
3575:                 notesHit: statistics.notesHit,
3576:                 playTime: statistics.playTime,
3577:                 currentStreak: statistics.currentStreak,
3578:                 perfectTuningCount: statistics.perfectLevelsCount
3579:             )
3580:             save()
3581:         }
3582:     /// Restablece todas las estadísticas y logros a sus valores iniciales
3583:     func resetStatistics() {
3584:         var resetProfile = self
3585:         resetProfile.statistics = Statistics()
3586:         resetProfile.achievements = Achievements()
3587:         resetProfile.save()
3588:     }
3589: }
3590: </file>
3591: <file path="MusicBlocks/Paneles/DetectedNoteCounterNode.swift">
3592: //
3593: //  DetectedNoteCounterNode.swift
3594: //  MusicBlocks
3595: //
3596: //  Created by Jose R. García on 25/2/25.
3597: //
3598: import SpriteKit
3599: class DetectedNoteCounterNode: SKNode {
3600:     // MARK: - Layout Configuration
3601:     struct Layout {
3602:         static let defaultSize = CGSize(width: 100, height: 40)
3603:         static let cornerRadius: CGFloat = 8
3604:         static let backgroundAlpha: CGFloat = 0.95
3605:         static let inactiveAlpha: CGFloat = 0.6
3606:         static let animationDuration: TimeInterval = 0.2
3607:         static let fontSize: CGFloat = 18  // Fuente más pequeña
3608:         static let padding: CGFloat = 10
3609:         static let shadowRadius: CGFloat = 4.0
3610:         static let shadowOpacity: Float = 0.2
3611:         static let shadowOffset = CGPoint(x: 0, y: -1)
3612:     }
3613:     // MARK: - Properties
3614:     private let containerSize: CGSize
3615:     private let container: SKShapeNode
3616:     private let shadowNode: SKEffectNode
3617:     private let noteLabel: SKLabelNode
3618:     var currentNote: String = "-" {
3619:         didSet {
3620:             updateDisplay()
3621:         }
3622:     }
3623:     var isActive: Bool = false {
3624:         didSet {
3625:             updateDisplay()
3626:         }
3627:     }
3628:     // MARK: - Initialization
3629:     init(size: CGSize = Layout.defaultSize) {
3630:         self.containerSize = size
3631:         // Crear nodo de sombra
3632:         shadowNode = SKEffectNode()
3633:         let shadowShape = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
3634:         shadowShape.fillColor = .black
3635:         shadowShape.strokeColor = .clear
3636:         shadowShape.alpha = CGFloat(Layout.shadowOpacity)
3637:         shadowNode.addChild(shadowShape)
3638:         shadowNode.shouldRasterize = true
3639:         shadowNode.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": Layout.shadowRadius])
3640:         shadowNode.position = Layout.shadowOffset
3641:         // Inicializar contenedor principal
3642:         container = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
3643:         // Etiqueta para el valor de la nota (centrada)
3644:         noteLabel = SKLabelNode(fontNamed: "Helvetica-Bold")
3645:         noteLabel.fontSize = min(size.height * 0.5, Layout.fontSize)
3646:         noteLabel.verticalAlignmentMode = .center
3647:         noteLabel.horizontalAlignmentMode = .center
3648:         super.init()
3649:         setupNodes()
3650:         updateDisplay()
3651:     }
3652:     required init?(coder aDecoder: NSCoder) {
3653:         fatalError("init(coder:) has not been implemented")
3654:     }
3655:     // MARK: - Setup
3656:     private func setupNodes() {
3657:         // Aplicar estilo común del contenedor
3658:         applyContainerStyle(size: containerSize)
3659:         // Posicionar etiqueta en el centro
3660:         noteLabel.position = CGPoint(x: 0, y: 0)
3661:         addChild(noteLabel)
3662:     }
3663:     // MARK: - Updates
3664:     private func updateDisplay() {
3665:         // Actualizar texto
3666:         noteLabel.text = currentNote
3667:         // Actualizar colores según estado
3668:         if isActive {
3669:             noteLabel.fontColor = .black
3670:             container.alpha = Layout.backgroundAlpha
3671:         } else {
3672:             noteLabel.fontColor = .gray
3673:             container.alpha = Layout.inactiveAlpha
3674:         }
3675:         // Animar cambio
3676:         animateUpdate()
3677:     }
3678:     private func animateUpdate() {
3679:         let scaleUp = SKAction.scale(to: 1.1, duration: Layout.animationDuration / 2)
3680:         let scaleDown = SKAction.scale(to: 1.0, duration: Layout.animationDuration / 2)
3681:         let sequence = SKAction.sequence([scaleUp, scaleDown])
3682:         noteLabel.run(sequence)
3683:     }
3684:     // MARK: - Factory Methods
3685:     static func createForRightSideBar(at position: CGPoint, size: CGSize = Layout.defaultSize, zPosition: CGFloat = 10) -> DetectedNoteCounterNode {
3686:         let node = DetectedNoteCounterNode(size: size)
3687:         node.position = position
3688:         node.zPosition = zPosition
3689:         return node
3690:     }
3691: }
3692: // MARK: - Previews
3693: #if DEBUG
3694: import SwiftUI
3695: extension DetectedNoteCounterNode {
3696:     static func createPreviewScene() -> SKScene {
3697:         let scene = SKScene(size: CGSize(width: 300, height: 150))
3698:         scene.backgroundColor = .clear
3699:         let activeNode = DetectedNoteCounterNode()
3700:         activeNode.currentNote = "La4"
3701:         activeNode.isActive = true
3702:         activeNode.position = CGPoint(x: 150, y: 100)
3703:         scene.addChild(activeNode)
3704:         let inactiveNode = DetectedNoteCounterNode()
3705:         inactiveNode.currentNote = "-"
3706:         inactiveNode.isActive = false
3707:         inactiveNode.position = CGPoint(x: 150, y: 50)
3708:         scene.addChild(inactiveNode)
3709:         return scene
3710:     }
3711: }
3712: struct DetectedNoteCounterPreview: PreviewProvider {
3713:     static var previews: some View {
3714:         ZStack {
3715:             Color.gray.opacity(0.3)
3716:             SpriteView(scene: DetectedNoteCounterNode.createPreviewScene())
3717:         }
3718:         .frame(width: 300, height: 150)
3719:     }
3720: }
3721: #endif
3722: </file>
3723: <file path="MusicBlocks/Paneles/GameOverlayNode.swift">
3724: //
3725: //  GameOverlayNode.swift
3726: //  MusicBlocks
3727: //
3728: //  Created by Jose R. García on 25/2/25.
3729: //
3730: import SpriteKit
3731: import UIKit
3732: class GameOverlayNode: SKNode {
3733:     // Cambiado de private a internal para que las subclases puedan acceder
3734:     struct Layout {
3735:         static let cornerRadius: CGFloat = 20
3736:         static let padding: CGFloat = 30
3737:         static let iconSize: CGFloat = 40
3738:         static let spacing: CGFloat = 15
3739:         static let backgroundAlpha: CGFloat = 0.7
3740:     }
3741:     enum OverlayPosition {
3742:         case bottom    // For success and failure overlays
3743:         case center    // For game over overlay
3744:         func getPosition(in scene: SKScene) -> CGPoint {
3745:             switch self {
3746:             case .bottom:
3747:                 // Position at 10% from bottom of screen
3748:                 return CGPoint(x: scene.size.width/2, y: scene.size.height * 0.1)
3749:             case .center:
3750:                 // Position at center of screen
3751:                 return CGPoint(x: scene.size.width/2, y: scene.size.height/2)
3752:             }
3753:         }
3754:     }
3755:     private let backgroundNode: SKShapeNode
3756:     // Cambiado de private a protected para que las subclases puedan acceder
3757:     let contentNode: SKNode
3758:     init(size: CGSize) {
3759:         backgroundNode = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
3760:         contentNode = SKNode()
3761:         super.init()
3762:         setupBackground()
3763:         addChild(contentNode)
3764:     }
3765:     required init?(coder aDecoder: NSCoder) {
3766:         fatalError("init(coder:) has not been implemented")
3767:     }
3768:     private func setupBackground() {
3769:         backgroundNode.fillColor = .white
3770:         backgroundNode.strokeColor = .clear
3771:         backgroundNode.alpha = 0.95
3772:         addChild(backgroundNode)
3773:     }
3774:     // Replace the existing show method in GameOverlayNode
3775:     func show(in scene: SKScene, overlayPosition: OverlayPosition = .center, duration: TimeInterval = 0.3) {
3776:         // Set initial state
3777:         alpha = 0
3778:         setScale(0.5)
3779:         // Set position using the enum method
3780:         self.position = overlayPosition.getPosition(in: scene)
3781:         // Ensure overlay is above other content
3782:         zPosition = 100
3783:         let appearAction = SKAction.group([
3784:             SKAction.fadeIn(withDuration: duration),
3785:             SKAction.scale(to: 1.0, duration: duration)
3786:         ])
3787:         run(appearAction)
3788:     }
3789:     func hide(duration: TimeInterval = 0.3) {
3790:         let disappearAction = SKAction.group([
3791:             SKAction.fadeOut(withDuration: duration),
3792:             SKAction.scale(to: 0.5, duration: duration)
3793:         ])
3794:         run(SKAction.sequence([
3795:             disappearAction,
3796:             SKAction.removeFromParent()
3797:         ]))
3798:     }
3799: }
3800: // MARK: - Inicio de Nivel
3801: class LevelStartOverlayNode: GameOverlayNode {
3802:     private var countdownLabel: SKLabelNode?
3803:     private var countdownTimer: Timer?
3804:     private var secondsRemaining: Int = 5
3805:     private var startAction: (() -> Void)?
3806:     init(size: CGSize, levelId: Int, levelName: String, startAction: @escaping () -> Void) {
3807:         super.init(size: size)
3808:         self.startAction = startAction
3809:         // Hacer el fondo más atractivo con un gradiente
3810:         setupBackground()
3811:         // Contenedor para el título y nombre del nivel
3812:         let headerContainer = SKNode()
3813:         // Título del nivel con estilo mejorado
3814:         let titleNode = SKLabelNode(text: "Nivel \(levelId)")
3815:         titleNode.fontSize = min(40, size.width * 0.12) // Ajuste responsivo
3816:         titleNode.fontName = "Helvetica-Bold"
3817:         titleNode.fontColor = .purple
3818:         titleNode.position = CGPoint(x: 0, y: size.height * 0.2)
3819:         headerContainer.addChild(titleNode)
3820:         // Nombre del nivel con estilo mejorado
3821:         let nameNode = SKLabelNode(text: levelName)
3822:         nameNode.fontSize = min(24, size.width * 0.08) // Ajuste responsivo
3823:         nameNode.fontName = "Helvetica"
3824:         nameNode.fontColor = .darkGray
3825:         nameNode.position = CGPoint(x: 0, y: size.height * 0.08)
3826:         headerContainer.addChild(nameNode)
3827:         // Línea separadora
3828:         let separatorLine = SKShapeNode(rectOf: CGSize(width: size.width * 0.8, height: 1))
3829:         separatorLine.fillColor = .lightGray
3830:         separatorLine.strokeColor = .clear
3831:         separatorLine.position = CGPoint(x: 0, y: 0)
3832:         headerContainer.addChild(separatorLine)
3833:         contentNode.addChild(headerContainer)
3834:         // Mensaje "Preparado"
3835:         let readyNode = SKLabelNode(text: "¡Prepárate!")
3836:         readyNode.fontSize = min(28, size.width * 0.09) // Ajuste responsivo
3837:         readyNode.fontName = "Helvetica-Bold"
3838:         readyNode.fontColor = .orange
3839:         readyNode.position = CGPoint(x: 0, y: -size.height * 0.1)
3840:         contentNode.addChild(readyNode)
3841:         // Etiqueta para la cuenta atrás con estilo mejorado
3842:         let countdownNode = SKLabelNode(text: "\(secondsRemaining)")
3843:         countdownNode.fontSize = min(64, size.width * 0.2) // Ajuste responsivo
3844:         countdownNode.fontName = "Helvetica-Bold"
3845:         countdownNode.fontColor = .orange
3846:         countdownNode.position = CGPoint(x: 0, y: -size.height * 0.30)
3847:         contentNode.addChild(countdownNode)
3848:         self.countdownLabel = countdownNode
3849:     }
3850:     private func setupBackground() {
3851:         // Calcular el tamaño basado en el tamaño del nodo
3852:         let nodeSize = self.calculateAccumulatedFrame().size
3853:         // Personalizar el fondo para mejorar la apariencia
3854:         let backgroundNode = SKShapeNode(rectOf: nodeSize, cornerRadius: Layout.cornerRadius)
3855:         let gradientImage = generateGradientImage(
3856:             from: UIColor.systemIndigo,
3857:             to: UIColor.systemBlue.withAlphaComponent(0.7),
3858:             size: nodeSize
3859:         )
3860:         backgroundNode.fillTexture = SKTexture(image: gradientImage)
3861:         backgroundNode.strokeColor = UIColor.white
3862:         backgroundNode.lineWidth = 2
3863:         backgroundNode.alpha = 0.9
3864:         contentNode.addChild(backgroundNode)
3865:     }
3866:     // Función auxiliar para generar un fondo con gradiente
3867:     private func generateGradientImage(from startColor: UIColor, to endColor: UIColor, size: CGSize) -> UIImage {
3868:         let gradientLayer = CAGradientLayer()
3869:         gradientLayer.frame = CGRect(origin: .zero, size: size)
3870:         gradientLayer.colors = [startColor.cgColor, endColor.cgColor]
3871:         gradientLayer.startPoint = CGPoint(x: 0.5, y: 0.0)
3872:         gradientLayer.endPoint = CGPoint(x: 0.5, y: 1.0)
3873:         UIGraphicsBeginImageContext(size)
3874:         gradientLayer.render(in: UIGraphicsGetCurrentContext()!)
3875:         let image = UIGraphicsGetImageFromCurrentImageContext()
3876:         UIGraphicsEndImageContext()
3877:         return image ?? UIImage()
3878:     }
3879:     required init?(coder aDecoder: NSCoder) {
3880:         fatalError("init(coder:) has not been implemented")
3881:     }
3882:     override func show(in scene: SKScene, overlayPosition: OverlayPosition = .center, duration: TimeInterval = 0.5) {
3883:         super.show(in: scene, overlayPosition: overlayPosition, duration: duration)
3884:         startCountdown()
3885:     }
3886:     private func startCountdown() {
3887:         // Establecer el color inicial según el valor inicial (5)
3888:         updateCountdownColor()
3889:         countdownTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] timer in
3890:             guard let self = self else {
3891:                 timer.invalidate()
3892:                 return
3893:             }
3894:             self.secondsRemaining -= 1
3895:             self.countdownLabel?.text = "\(self.secondsRemaining)"
3896:             // Actualizar el color según el nuevo valor
3897:             self.updateCountdownColor()
3898:             // Animar el cambio de número con un efecto más vistoso
3899:             let scaleUp = SKAction.scale(to: 1.3, duration: 0.15)
3900:             let scaleDown = SKAction.scale(to: 1.0, duration: 0.15)
3901:             self.countdownLabel?.run(SKAction.sequence([scaleUp, scaleDown]))
3902:             if self.secondsRemaining <= 0 {
3903:                 timer.invalidate()
3904:                 self.hide()
3905:                 self.startAction?()
3906:             }
3907:         }
3908:     }
3909:     private func updateCountdownColor() {
3910:         // Asignar colores según el valor de la cuenta atrás
3911:         switch secondsRemaining {
3912:         case 5, 4:
3913:             // 5 y 4 son verdes
3914:             countdownLabel?.fontColor = UIColor.systemGreen
3915:         case 3, 2:
3916:             // 3 y 2 son naranjas
3917:             countdownLabel?.fontColor = UIColor.orange
3918:         case 1, 0:
3919:             // 1 y 0 son rojos
3920:             countdownLabel?.fontColor = UIColor.red
3921:         default:
3922:             // Para cualquier otro número (por seguridad)
3923:             countdownLabel?.fontColor = UIColor.white
3924:         }
3925:     }
3926:     override func hide(duration: TimeInterval = 0.3) {
3927:         countdownTimer?.invalidate()
3928:         countdownTimer = nil
3929:         super.hide(duration: duration)
3930:     }
3931: }
3932: // MARK: - Success Overlay
3933: class SuccessOverlayNode: GameOverlayNode {
3934:     init(size: CGSize, multiplier: Int, message: String) {
3935:         super.init(size: size)
3936:         let checkmarkNode = SKLabelNode(text: "✓")
3937:         checkmarkNode.fontSize = 30 // Tamaño reducido
3938:         checkmarkNode.fontName = "Helvetica-Bold"
3939:         checkmarkNode.fontColor = getColor(for: multiplier)
3940:         checkmarkNode.position = CGPoint(x: -60, y: 0) // Ajustado horizontalmente
3941:         contentNode.addChild(checkmarkNode)
3942:         let messageNode = SKLabelNode(text: message)
3943:         messageNode.fontSize = 16 // Tamaño reducido
3944:         messageNode.fontName = "Helvetica-Bold"
3945:         messageNode.fontColor = getColor(for: multiplier)
3946:         messageNode.position = CGPoint(x: 0, y: 0)
3947:         contentNode.addChild(messageNode)
3948:         if multiplier > 1 {
3949:             let multiplierNode = SKLabelNode(text: "x\(multiplier)")
3950:             multiplierNode.fontSize = 18 // Tamaño reducido
3951:             multiplierNode.fontName = "Helvetica-Bold"
3952:             multiplierNode.fontColor = .orange
3953:             multiplierNode.position = CGPoint(x: 60, y: 0) // Ajustado horizontalmente
3954:             contentNode.addChild(multiplierNode)
3955:         }
3956:     }
3957:     required init?(coder aDecoder: NSCoder) {
3958:         fatalError("init(coder:) has not been implemented")
3959:     }
3960:     private func getColor(for multiplier: Int) -> SKColor {
3961:         switch multiplier {
3962:         case 3: return .purple    // Excelente
3963:         case 2: return .green     // Perfecto
3964:         case 1: return .blue      // Bien
3965:         default: return .gray
3966:         }
3967:     }
3968: }
3969: // MARK: - Failure Overlay
3970: class FailureOverlayNode: GameOverlayNode {
3971:     override init(size: CGSize) {
3972:         super.init(size: size)
3973:         let xmarkNode = SKLabelNode(text: "✗")
3974:         xmarkNode.fontSize = 30 // Tamaño reducido
3975:         xmarkNode.fontName = "Helvetica-Bold"
3976:         xmarkNode.fontColor = .red
3977:         xmarkNode.position = CGPoint(x: -90, y: 0) // Ajustado horizontalmente
3978:         contentNode.addChild(xmarkNode)
3979:         let messageNode = SKLabelNode(text: "¡Intenta de nuevo!")
3980:         messageNode.fontSize = 16 // Tamaño reducido
3981:         messageNode.fontName = "Helvetica-Bold"
3982:         messageNode.fontColor = .red
3983:         messageNode.position = CGPoint(x: 0, y: 0)
3984:         contentNode.addChild(messageNode)
3985:     }
3986:     required init?(coder aDecoder: NSCoder) {
3987:         fatalError("init(coder:) has not been implemented")
3988:     }
3989: }
3990: // MARK: - Game Over Overlay
3991: class GameOverOverlayNode: GameOverlayNode {
3992:     private var restartAction: (() -> Void)?
3993:     init(size: CGSize, score: Int, message: String, isVictory: Bool = false, restartAction: @escaping () -> Void) {
3994:         super.init(size: size)
3995:         self.restartAction = restartAction
3996:         let titleColor: SKColor = isVictory ? .systemGreen : .purple
3997:         let messageColor: SKColor = isVictory ? .systemGreen : .red
3998:         // Título Game Over o Victoria
3999:         let gameoverNode = SKLabelNode(text: isVictory ? "¡Victoria!" : "¡Fin del juego!")
4000:         gameoverNode.fontSize = 32
4001:         gameoverNode.fontName = "Helvetica-Bold"
4002:         gameoverNode.fontColor = titleColor
4003:         gameoverNode.position = CGPoint(x: 0, y: size.height/4)
4004:         contentNode.addChild(gameoverNode)
4005:         // Mensaje específico
4006:         let messageNode = SKLabelNode(text: message)
4007:         messageNode.fontSize = 16
4008:         messageNode.fontName = "Helvetica"
4009:         messageNode.fontColor = messageColor
4010:         messageNode.position = CGPoint(x: 0, y: size.height/4 - 40)
4011:         contentNode.addChild(messageNode)
4012:         // Puntuación
4013:         let scoreNode = SKLabelNode(text: "Puntuación: \(score)")
4014:         scoreNode.fontSize = 20
4015:         scoreNode.fontName = "Helvetica-Bold"
4016:         scoreNode.fontColor = titleColor
4017:         scoreNode.position = CGPoint(x: 0, y: 0)
4018:         contentNode.addChild(scoreNode)
4019:         setupRestartButton(isVictory: isVictory)
4020:     }
4021:     required init?(coder aDecoder: NSCoder) {
4022:         fatalError("init(coder:) has not been implemented")
4023:     }
4024:     private func setupRestartButton(isVictory: Bool) {
4025:         let buttonSize = CGSize(width: 170, height: 50)
4026:         let buttonNode = SKShapeNode(rectOf: buttonSize, cornerRadius: 10)
4027:         buttonNode.fillColor = isVictory ? .systemGreen : .purple
4028:         buttonNode.strokeColor = .clear
4029:         buttonNode.position = CGPoint(x: 0, y: -50)
4030:         buttonNode.name = "restartButton"
4031:         contentNode.addChild(buttonNode)
4032:         let buttonText = isVictory ? "Siguiente nivel" : "Intentar de nuevo"
4033:         let buttonLabel = SKLabelNode(text: buttonText)
4034:         buttonLabel.fontSize = 18
4035:         buttonLabel.fontName = "Helvetica-Bold"
4036:         buttonLabel.fontColor = .white
4037:         buttonLabel.verticalAlignmentMode = .center
4038:         buttonNode.addChild(buttonLabel)
4039:     }
4040:     override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
4041:         guard let touch = touches.first else { return }
4042:         let location = touch.location(in: self)
4043:         let nodes = nodes(at: location)
4044:         if nodes.contains(where: { $0.name == "restartButton" }) {
4045:             restartAction?()
4046:         }
4047:     }
4048: }
4049: // MARK: - Previews
4050: #if DEBUG
4051: import SwiftUI
4052: struct GameOverlayPreview: PreviewProvider {
4053:     static var previews: some View {
4054:         VStack(spacing: 20) {
4055:             // Vista del LevelStartOverlay
4056:             SpriteView(scene: {
4057:                 let scene = SKScene(size: CGSize(width: 400, height: 300))
4058:                 scene.backgroundColor = .white
4059:                 let levelStartNode = LevelStartOverlayNode(
4060:                     size: CGSize(width: 350, height: 250),
4061:                     levelId: 1,
4062:                     levelName: "¡Comienza la aventura!",
4063:                     startAction: {}
4064:                 )
4065:                 levelStartNode.position = CGPoint(x: 200, y: 150)
4066:                 scene.addChild(levelStartNode)
4067:                 return scene
4068:             }())
4069:             .frame(width: 400, height: 300)
4070:             .previewDisplayName("Level Start Overlay")
4071:             // Vista de los otros overlays
4072:             SpriteView(scene: {
4073:                 let scene = SKScene(size: CGSize(width: 400, height: 600))
4074:                 scene.backgroundColor = .white
4075:                 // Success Overlay
4076:                 let successNode = SuccessOverlayNode(
4077:                     size: CGSize(width: 300, height: 80),
4078:                     multiplier: 2,
4079:                     message: "¡Perfecto!"
4080:                 )
4081:                 successNode.position = CGPoint(x: 200, y: 450)
4082:                 scene.addChild(successNode)
4083:                 // Failure Overlay
4084:                 let failureNode = FailureOverlayNode(
4085:                     size: CGSize(width: 300, height: 80)
4086:                 )
4087:                 failureNode.position = CGPoint(x: 200, y: 300)
4088:                 scene.addChild(failureNode)
4089:                 // Game Over Overlay
4090:                 let gameOverNode = GameOverOverlayNode(
4091:                     size: CGSize(width: 300, height: 200),
4092:                     score: 1500,
4093:                     message: "¡Juego terminado!",
4094:                     isVictory: true, // Para ver ambas variantes, puedes alternar entre true/false
4095:                     restartAction: {}
4096:                 )
4097:                 gameOverNode.position = CGPoint(x: 200, y: 150)
4098:                 scene.addChild(gameOverNode)
4099:                 return scene
4100:             }())
4101:             .frame(width: 400, height: 600)
4102:             .previewDisplayName("Game State Overlays")
4103:         }
4104:         .previewLayout(.fixed(width: 400, height: 920))
4105:         .background(Color.gray.opacity(0.1))
4106:     }
4107: }
4108: #endif
4109: </file>
4110: <file path="MusicBlocks/Paneles/ScoreProgressNode.swift">
4111: //
4112: //  ScoreProgressNode.swift
4113: //  MusicBlocks
4114: //
4115: //  Created by Jose R. García on 12/3/25.
4116: //
4117: import SpriteKit
4118: class ScoreProgressNode: SKNode {
4119:     // MARK: - Private Properties
4120:     private var progressBar: SKShapeNode
4121:     private var progressFill: SKShapeNode
4122:     private var stars: [SKSpriteNode] = []
4123:     private var litStars: [Bool] = [] // Añadir un array para seguir el estado de las estrellas
4124:     // MARK: - Layout Constants
4125:     private enum Layout {
4126:         static let maxStars: Int = 5
4127:         static let starSize: CGFloat = 20
4128:         /// Offset vertical para las estrellas respecto al centro superior de la barra
4129:         /// (ajústalo a 0 si quieres que queden centradas en la altura).
4130:         static let starVerticalOffset: CGFloat = 1
4131:         static let barHeight: CGFloat = 8
4132:         static let progressBarColor: SKColor = .white.withAlphaComponent(0.6)
4133:         static let progressFillColor: SKColor = .systemPurple
4134:         // Animaciones
4135:         static let animationDuration: TimeInterval = 0.3
4136:         static let starAnimationScale: CGFloat = 0.5
4137:         static let starAnimationDuration: TimeInterval = 0.15
4138:         static let starAnimationDelay: TimeInterval = 0.1
4139:     }
4140:     private let barWidth: CGFloat
4141:     // MARK: - Initialization
4142:     init(width: CGFloat) {
4143:         self.barWidth = width
4144:         // En vez de rectOf(...), creamos rect con origen (0,0) y width = barWidth
4145:         progressBar = SKShapeNode(
4146:             rect: CGRect(x: 0, y: 0, width: width, height: Layout.barHeight),
4147:             cornerRadius: Layout.barHeight / 2
4148:         )
4149:         progressFill = SKShapeNode(
4150:             rect: CGRect(x: 0, y: 0, width: 0, height: Layout.barHeight - 2),
4151:             cornerRadius: (Layout.barHeight - 2) / 2
4152:         )
4153:         // Inicializar el array de estado de estrellas con todas apagadas
4154:         litStars = Array(repeating: false, count: Layout.maxStars)
4155:         super.init()
4156:         setupNodes()
4157:     }
4158:     required init?(coder aDecoder: NSCoder) {
4159:         fatalError("init(coder:) has not been implemented")
4160:     }
4161:     // MARK: - Setup Methods
4162:     private func setupNodes() {
4163:         setupProgressBar()
4164:         setupProgressFill()
4165:         setupStars()
4166:     }
4167:     /// Barra de fondo, va de x=0 a x=barWidth
4168:     private func setupProgressBar() {
4169:         progressBar.fillColor = Layout.progressBarColor
4170:         progressBar.strokeColor = .clear
4171:         // Su origen local es (0,0)
4172:         progressBar.position = .zero
4173:         addChild(progressBar)
4174:     }
4175:     /// Barra "relleno" que crece desde x=0 hacia la derecha
4176:     private func setupProgressFill() {
4177:         progressFill.fillColor = Layout.progressFillColor
4178:         progressFill.strokeColor = .clear
4179:         // También empieza en (0,0)
4180:         progressFill.position = .zero
4181:         addChild(progressFill)
4182:     }
4183:     /// Distribuye las estrellas en el rango [0 .. barWidth]
4184:     private func setupStars() {
4185:         for i in 0..<Layout.maxStars {
4186:             let star = SKSpriteNode(imageNamed: "star_empty")
4187:             star.size = CGSize(width: Layout.starSize, height: Layout.starSize)
4188:             // Fracción de 0 a 1
4189:             let fraction = CGFloat(i) / CGFloat(Layout.maxStars - 1)
4190:             // X = fraction * barWidth
4191:             let xPos = fraction * barWidth
4192:             // Ajusta la altura de las estrellas
4193:             let yPos = (Layout.barHeight / 2) + Layout.starVerticalOffset
4194:             star.position = CGPoint(x: xPos, y: yPos)
4195:             stars.append(star)
4196:             addChild(star)
4197:         }
4198:     }
4199:     // MARK: - Update Methods
4200:     func updateProgress(score: Int, maxScore: Int) {
4201:         animateProgressBar(score: score, maxScore: maxScore)
4202:         updateStars(score: score, maxScore: maxScore)
4203:     }
4204:     private func animateProgressBar(score: Int, maxScore: Int) {
4205:         let fraction = min(CGFloat(score) / CGFloat(maxScore), 1.0)
4206:         let fillWidth = barWidth * fraction
4207:         // Redimensionamos el ancho del rect
4208:         let resizeAction = SKAction.resize(toWidth: fillWidth, duration: Layout.animationDuration)
4209:         resizeAction.timingMode = .easeOut
4210:         progressFill.run(resizeAction)
4211:     }
4212:     private func updateStars(score: Int, maxScore: Int) {
4213:         // Cinco estrellas: se encienden en 1/5, 2/5, 3/5, 4/5, 5/5 de maxScore
4214:         let step = maxScore / Layout.maxStars
4215:         let thresholds = (1...Layout.maxStars).map { step * $0 }
4216:         for (index, threshold) in thresholds.enumerated() {
4217:             let delay = Double(index) * Layout.starAnimationDelay
4218:             updateStar(at: index, lit: score >= threshold, delay: delay)
4219:         }
4220:     }
4221:     private func updateStar(at index: Int, lit: Bool, delay: TimeInterval) {
4222:         guard index < stars.count && index < litStars.count else { return }
4223:         let currentlyLit = litStars[index]
4224:         // Si el estado no cambió, no hacemos nada
4225:         guard lit != currentlyLit else { return }
4226:         // Actualizar estado en nuestro array
4227:         litStars[index] = lit
4228:         DispatchQueue.main.asyncAfter(deadline: .now() + delay) { [weak self, weak star] in
4229:             // Verificar que el nodo y la referencia aún existen
4230:             guard let star = star, let self = self else { return }
4231:             let scaleDown = SKAction.scale(to: Layout.starAnimationScale,
4232:                                           duration: Layout.starAnimationDuration)
4233:             let changeTexture = SKAction.run {
4234:                 star.texture = SKTexture(imageNamed: lit ? "star_filled" : "star_empty")
4235:             }
4236:             let scaleUp = SKAction.scale(to: 1.0,
4237:                                         duration: Layout.starAnimationDuration)
4238:             let sequence = SKAction.sequence([scaleDown, changeTexture, scaleUp])
4239:             star.run(sequence)
4240:         }
4241:     }
4242: }
4243: // MARK: - SwiftUI Preview
4244: #if DEBUG
4245: import SwiftUI
4246: struct ScoreProgressNodePreview: PreviewProvider {
4247:     static var previews: some View {
4248:         ScoreProgressNodeContainer()
4249:             .frame(width: 340, height: 120)
4250:             .previewDisplayName("Barra con 5 estrellas (x=0..barWidth)")
4251:     }
4252: }
4253: /// Contenedor SwiftUI que muestra el nodo en una escena de SpriteKit
4254: struct ScoreProgressNodeContainer: View {
4255:     private func createScene(size: CGSize) -> SKScene {
4256:         let scene = SKScene(size: size)
4257:         scene.backgroundColor = .black
4258:         // Instanciamos la barra con ancho 300, por ejemplo
4259:         let barWidth: CGFloat = 300
4260:         let progressNode = ScoreProgressNode(width: barWidth)
4261:         // Colocamos la barra en x=20, y=centro vertical
4262:         // (así su "lado izquierdo" arranca en x=20)
4263:         progressNode.position = CGPoint(x: 20, y: size.height / 2)
4264:         scene.addChild(progressNode)
4265:         // Simulamos un score para ver la barra rellena a ~66%
4266:         progressNode.updateProgress(score: 200, maxScore: 300)
4267:         return scene
4268:     }
4269:     var body: some View {
4270:         GeometryReader { geometry in
4271:             SpriteView(scene: createScene(size: geometry.size))
4272:         }
4273:     }
4274: }
4275: #endif
4276: </file>
4277: <file path="MusicBlocks/Paneles/StabilityCounterNode.swift">
4278: //
4279: //  StabilityCounterNode.swift
4280: //  MusicBlocks
4281: //
4282: //  Created by Jose R. García on 25/2/25.
4283: //
4284: import SpriteKit
4285: class StabilityCounterNode: SKNode {
4286:     // MARK: - Layout Configuration
4287:     private struct Layout {
4288:         static let primaryFontRatio: CGFloat = 0.4  // Tamaño de fuente relativo a la altura del nodo
4289:         static let secondaryFontRatio: CGFloat = 0.3
4290:         static let cornerRadius: CGFloat = 8
4291:         static let backgroundAlpha: CGFloat = 0.95
4292:         static let animationDuration: TimeInterval = 0.2
4293:         static let shadowRadius: CGFloat = 4.0
4294:         static let shadowOpacity: Float = 0.2
4295:         static let shadowOffset = CGPoint(x: 0, y: -1)
4296:     }
4297:     // MARK: - Properties
4298:     private let containerSize: CGSize
4299:     private let container: SKShapeNode
4300:     private let shadowNode: SKEffectNode
4301:     private let timeLabel: SKLabelNode
4302:     private let unitLabel: SKLabelNode
4303:     var duration: TimeInterval = 0 {
4304:         didSet {
4305:             updateDisplay()
4306:         }
4307:     }
4308:     // MARK: - Initialization
4309:     init(size: CGSize) {
4310:         self.containerSize = size
4311:         // Crear nodo de sombra
4312:         shadowNode = SKEffectNode()
4313:         let shadowShape = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
4314:         shadowShape.fillColor = .black
4315:         shadowShape.strokeColor = .clear
4316:         shadowShape.alpha = CGFloat(Layout.shadowOpacity)
4317:         shadowNode.addChild(shadowShape)
4318:         shadowNode.shouldRasterize = true
4319:         shadowNode.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": Layout.shadowRadius])
4320:         shadowNode.position = Layout.shadowOffset
4321:         // Inicializar contenedor principal
4322:         container = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
4323:         // Inicializar etiquetas con tamaños pequeños
4324:         timeLabel = SKLabelNode(fontNamed: "Helvetica-Bold")
4325:         timeLabel.fontSize = size.height * Layout.primaryFontRatio
4326:         timeLabel.verticalAlignmentMode = .center
4327:         timeLabel.horizontalAlignmentMode = .right
4328:         timeLabel.fontColor = .black
4329:         unitLabel = SKLabelNode(fontNamed: "Helvetica")
4330:         unitLabel.fontSize = size.height * Layout.secondaryFontRatio
4331:         unitLabel.verticalAlignmentMode = .center
4332:         unitLabel.horizontalAlignmentMode = .left
4333:         unitLabel.fontColor = .gray
4334:         unitLabel.text = "seg"
4335:         super.init()
4336:         setupNodes()
4337:         updateDisplay()
4338:     }
4339:     required init?(coder aDecoder: NSCoder) {
4340:         fatalError("init(coder:) has not sido implementado")
4341:     }
4342:     // MARK: - Setup
4343:     private func setupNodes() {
4344:         // Añadir sombra primero
4345:         addChild(shadowNode)
4346:         // Configurar contenedor principal
4347:         container.fillColor = .white
4348:         container.strokeColor = .clear
4349:         container.alpha = Layout.backgroundAlpha
4350:         addChild(container)
4351:         // Posicionar etiquetas horizontalmente para mejor uso del espacio
4352:         timeLabel.position = CGPoint(x: -containerSize.width * 0.05, y: 0)
4353:         unitLabel.position = CGPoint(x: containerSize.width * 0.05, y: 0)
4354:         // Añadir etiquetas al nodo principal (no al contenedor)
4355:         addChild(timeLabel)
4356:         addChild(unitLabel)
4357:     }
4358:     // MARK: - Updates
4359:     private func updateDisplay() {
4360:         timeLabel.text = String(format: "%.1f", duration)
4361:         animateUpdate()
4362:     }
4363:     private func animateUpdate() {
4364:         let scaleUp = SKAction.scale(to: 1.05, duration: Layout.animationDuration / 2)
4365:         let scaleDown = SKAction.scale(to: 1.0, duration: Layout.animationDuration / 2)
4366:         let sequence = SKAction.sequence([scaleUp, scaleDown])
4367:         timeLabel.run(sequence)
4368:     }
4369:     // MARK: - Public Methods
4370:     func reset() {
4371:         duration = 0
4372:     }
4373: }
4374: // MARK: - Previews
4375: #if DEBUG
4376: import SwiftUI
4377: struct StabilityCounterPreview: PreviewProvider {
4378:     static var previews: some View {
4379:         SpriteView(scene: {
4380:             let scene = SKScene(size: CGSize(width: 300, height: 200))
4381:             scene.backgroundColor = .white
4382:             let mediumNode = StabilityCounterNode(size: CGSize(width: 120, height: 60))
4383:             mediumNode.position = CGPoint(x: 150, y: 120)
4384:             mediumNode.duration = 5.5
4385:             scene.addChild(mediumNode)
4386:             let maxNode = StabilityCounterNode(size: CGSize(width: 120, height: 60))
4387:             maxNode.position = CGPoint(x: 150, y: 60)
4388:             maxNode.duration = 10.0
4389:             scene.addChild(maxNode)
4390:             return scene
4391:         }())
4392:         .frame(width: 300, height: 200)
4393:         .previewLayout(.fixed(width: 300, height: 200))
4394:     }
4395: }
4396: #endif
4397: </file>
4398: <file path="MusicBlocks/Paneles/StabilityIndicatorNode.swift">
4399: //
4400: //  StabilityIndicatorNode.swift
4401: //  MusicBlocks
4402: //
4403: //  Created by Jose R. García on 25/2/25.
4404: import SpriteKit
4405: class StabilityIndicatorNode: SKNode {
4406:     // MARK: - Layout Configuration
4407:     private struct Layout {
4408:         static let barWidthRatio: CGFloat = 0.8
4409:         static let markingWidthRatio: CGFloat = 0.6
4410:         static let backgroundAlpha: CGFloat = 0.15
4411:         static let markingsAlpha: CGFloat = 0.3
4412:         static let glowAlpha: CGFloat = 0.8
4413:         static let cornerRadius: CGFloat = 4
4414:         static let animationDuration: TimeInterval = 0.2
4415:     }
4416:     // MARK: - Properties
4417:     var containerSize: CGSize {
4418:         didSet {
4419:             updateLayout()
4420:         }
4421:     }
4422:     private let backgroundBar: SKShapeNode = SKShapeNode()
4423:     private var markings: [SKShapeNode] = []
4424:     private let glowBar: SKShapeNode = SKShapeNode()
4425:     private var maxDuration: TimeInterval = 10.0
4426:     var duration: TimeInterval = 0 {
4427:         didSet {
4428:             updateProgress()
4429:         }
4430:     }
4431:     // MARK: - Initialization
4432:     init(size: CGSize) {
4433:         self.containerSize = size
4434:         // Creación de tres marcas (por ejemplo, para 0, 5 y 10)
4435:         for _ in 0..<3 {
4436:             let mark = SKShapeNode()
4437:             markings.append(mark)
4438:         }
4439:         super.init()
4440:         setupNodes()
4441:         updateLayout()
4442:     }
4443:     required init?(coder aDecoder: NSCoder) {
4444:         fatalError("init(coder:) no ha sido implementado")
4445:     }
4446:     // MARK: - Setup
4447:     private func setupNodes() {
4448:         // Configurar la barra de fondo
4449:         backgroundBar.fillColor = .lightGray
4450:         backgroundBar.strokeColor = .clear
4451:         backgroundBar.alpha = Layout.backgroundAlpha
4452:         addChild(backgroundBar)
4453:         // Configurar las marcas
4454:         for mark in markings {
4455:             mark.fillColor = .darkGray
4456:             mark.strokeColor = .clear
4457:             mark.alpha = Layout.markingsAlpha
4458:             addChild(mark)
4459:         }
4460:         // Agregar glowBar (que se usará para mostrar el progreso)
4461:         addChild(glowBar)
4462:     }
4463:     // MARK: - Layout Update
4464:     private func updateLayout() {
4465:         let barWidth = containerSize.width * Layout.barWidthRatio
4466:         let barHeight = containerSize.height
4467:         // Actualizar el fondo de la barra - asegurándonos que ocupe todo el espacio disponible
4468:         let bgRect = CGRect(x: -barWidth/2, y: -barHeight/2, width: barWidth, height: barHeight)
4469:         backgroundBar.path = CGPath(roundedRect: bgRect, cornerWidth: Layout.cornerRadius, cornerHeight: Layout.cornerRadius, transform: nil)
4470:         // Actualizar la posición y tamaño de cada marca - espaciadas uniformemente
4471:         for (index, mark) in markings.enumerated() {
4472:             let progress = CGFloat(index) / CGFloat(markings.count - 1)
4473:             let yPosition = -containerSize.height * 0.5 + containerSize.height * progress
4474:             // CORREGIDO: Ajustar posición para alinearse mejor con la barra
4475:             mark.position = CGPoint(x: 0, y: yPosition)
4476:             // Ancho de marca consistente
4477:             let markWidth = barWidth * Layout.markingWidthRatio
4478:             let markHeight: CGFloat = 2.0  // Altura fija para que sea visible
4479:             let markRect = CGRect(x: -markWidth/2, y: -markHeight/2, width: markWidth, height: markHeight)
4480:             mark.path = CGPath(rect: markRect, transform: nil)
4481:         }
4482:         updateProgress()
4483:     }
4484:     // MARK: - Updates
4485:     private func updateProgress() {
4486:         let normalizedProgress = CGFloat(min(duration, maxDuration) / maxDuration)
4487:         let progressHeight = containerSize.height * normalizedProgress
4488:         let progressWidth = containerSize.width * Layout.barWidthRatio
4489:         // La posición del rectángulo debe partir desde abajo
4490:         let rect = CGRect(x: -progressWidth / 2,
4491:                           y: -containerSize.height / 2,  // Siempre partimos desde abajo
4492:                           width: progressWidth,
4493:                           height: progressHeight)
4494:         let path = CGMutablePath()
4495:         if progressHeight > Layout.cornerRadius * 2 {
4496:             path.addRoundedRect(in: rect, cornerWidth: Layout.cornerRadius, cornerHeight: Layout.cornerRadius)
4497:         } else {
4498:             path.addRect(rect)
4499:         }
4500:         // Actualización inmediata para mejor rendimiento
4501:         glowBar.path = path
4502:         glowBar.fillColor = getProgressColor()
4503:         glowBar.alpha = normalizedProgress * Layout.glowAlpha
4504:     }
4505:     private func getProgressColor() -> SKColor {
4506:         return UIColor(red: 0, green: 0.4, blue: 0.9, alpha: 1.0)
4507:     }
4508:     // MARK: - Public Methods
4509:     func reset() {
4510:         duration = 0
4511:         updateProgress()
4512:     }
4513:     func setMaxDuration(_ maxDuration: TimeInterval) {
4514:         self.maxDuration = maxDuration
4515:         updateProgress()
4516:     }
4517: }
4518: #if DEBUG
4519: import SwiftUI
4520: // MARK: - Previews
4521: extension StabilityIndicatorNode {
4522:     static func createPreviewScene() -> SKScene {
4523:         let scene = SKScene(size: CGSize(width: 300, height: 200))
4524:         scene.backgroundColor = .white
4525:         let states: [(duration: TimeInterval, position: CGPoint)] = [
4526:             (0.0, CGPoint(x: 75, y: 100)),    // Vacío
4527:             (5.0, CGPoint(x: 150, y: 100)),   // Medio
4528:             (10.0, CGPoint(x: 225, y: 100))   // Lleno
4529:         ]
4530:         for state in states {
4531:             let node = StabilityIndicatorNode(size: CGSize(width: 40, height: 120))
4532:             node.position = state.position
4533:             node.duration = state.duration
4534:             scene.addChild(node)
4535:         }
4536:         return scene
4537:     }
4538: }
4539: struct StabilityIndicatorPreview: PreviewProvider {
4540:     static var previews: some View {
4541:         SpriteView(scene: StabilityIndicatorNode.createPreviewScene())
4542:             .frame(width: 300, height: 200)
4543:             .previewLayout(.fixed(width: 300, height: 200))
4544:     }
4545: }
4546: #endif
4547: </file>
4548: <file path="MusicBlocks/Paneles/TopBar.swift">
4549: //
4550: //  TopBar.swift
4551: //  MusicBlocks
4552: //
4553: //  Created by Jose R. García on 9/23/25.
4554: //
4555: import SpriteKit
4556: import UIKit
4557: class TopBar: SKNode {
4558:     enum TopBarType {
4559:         case main       // Para nivel, puntuación y vidas
4560:         case objectives // Para objetivos
4561:     }
4562:     // MARK: - Layout
4563:     private struct Layout {
4564:         // Tamaño fijo del TopBar
4565:         static let cornerRadius: CGFloat = 10
4566:         // Separaciones
4567:         static let horizontalPadding: CGFloat = 10 // Se usa para desplazar la fila superior hacia la derecha desde el borde izquierdo del contenedor
4568:         static let verticalPadding: CGFloat = 12 // Se usa para desplazar la fila superior hacia abajo desde el borde superior del contenedor.
4569:         // Separaciones para la fila inferior
4570:             static let bottomRowHorizontalPadding: CGFloat = 18
4571:         static let itemSpacing: CGFloat = 8
4572:         // Texto
4573:         static let fontSize: CGFloat = 14
4574:         // Corazones
4575:         static let heartSize: CGFloat = 16
4576:         static let heartSpacing: CGFloat = 6
4577:         // Distancia vertical entre fila superior y fila inferior
4578:         static let rowSpacing: CGFloat = 14
4579:     }
4580:     // MARK: - Propiedades
4581:     private let barSize: CGSize
4582:     private let type: TopBarType
4583:     // Fila superior
4584:     private let topRow = SKNode()
4585:     private var levelLabel: SKLabelNode?
4586:     private var heartsContainer = SKNode()
4587:     // Fila inferior
4588:     private let bottomRow = SKNode()
4589:     private var scoreProgressNode: ScoreProgressNode?
4590:     private var objectivePanel: ObjectiveInfoPanel?
4591:     // Vidas
4592:     private var heartNodes: [SKSpriteNode] = []
4593:     private var maxLives: Int = 0
4594:     private var maxExtraLives: Int = 0
4595:     private var lives: Int = 0
4596:     // MARK: - Init
4597:     private init(width: CGFloat, height: CGFloat, position: CGPoint, type: TopBarType) {
4598:         self.barSize = CGSize(width: width, height: height)
4599:         self.type = type
4600:         super.init()
4601:         self.position = position
4602:         // Fondo y sombra (definido en tu UIContainer.swift)
4603:         applyContainerStyle(size: barSize)
4604:         // Añadir las dos filas
4605:         addChild(topRow)
4606:         addChild(bottomRow)
4607:         switch type {
4608:         case .main:
4609:             setupMainTopBar()
4610:         case .objectives:
4611:             // El panel de objetivos se configura luego en configureObjectivesBar(...)
4612:             break
4613:         }
4614:     }
4615:     required init?(coder aDecoder: NSCoder) {
4616:         fatalError("init(coder:) has not been implemented")
4617:     }
4618:     // MARK: - Crear la TopBar
4619:     static func create(width: CGFloat, height: CGFloat, position: CGPoint, type: TopBarType) -> TopBar {
4620:         return TopBar(width: width, height: height, position: position, type: type)
4621:     }
4622:     // MARK: - Setup para la barra principal
4623:     private func setupMainTopBar() {
4624:         // Fila superior: Nivel, separador y contenedor de corazones
4625:         levelLabel = SKLabelNode(fontNamed: "Helvetica-Bold")
4626:         levelLabel?.fontSize = Layout.fontSize
4627:         levelLabel?.fontColor = .purple
4628:         levelLabel?.verticalAlignmentMode = .center
4629:         levelLabel?.horizontalAlignmentMode = .left
4630:         levelLabel?.text = "Nivel ?" // Se actualiza en configure(...)
4631:         let separator = SKLabelNode(fontNamed: "Helvetica-Bold")
4632:         separator.text = "·"
4633:         separator.fontSize = Layout.fontSize
4634:         separator.fontColor = .darkGray
4635:         separator.verticalAlignmentMode = .center
4636:         separator.horizontalAlignmentMode = .left
4637:         // Layout horizontal en topRow
4638:         var currentX: CGFloat = -barSize.width/2 + Layout.horizontalPadding
4639:         let rowY: CGFloat = barSize.height/2 - Layout.verticalPadding
4640:         // 1) levelLabel
4641:         if let label = levelLabel {
4642:             label.position = CGPoint(x: currentX, y: rowY)
4643:             topRow.addChild(label)
4644:             currentX += label.frame.width + Layout.itemSpacing
4645:         }
4646:         // 2) separador
4647:         separator.position = CGPoint(x: currentX, y: rowY)
4648:         topRow.addChild(separator)
4649:         currentX += separator.frame.width + Layout.itemSpacing + 5
4650:         // 3) heartsContainer
4651:         heartsContainer.position = CGPoint(x: currentX, y: rowY)
4652:         topRow.addChild(heartsContainer)
4653:         // (los corazones se crean en setupHearts(...) luego)
4654:     }
4655:     private func setupScoreDisplay() {
4656:         let topRowHeight = topRow.calculateAccumulatedFrame().height
4657:         bottomRow.position = CGPoint(
4658:             x: 0,
4659:             y: (barSize.height/2 - Layout.verticalPadding) - topRowHeight - Layout.rowSpacing
4660:         )
4661:         // Ahora restamos bottomRowHorizontalPadding en lugar de horizontalPadding
4662:         let availableWidth = barSize.width - (Layout.bottomRowHorizontalPadding * 2)
4663:         let progressNode = ScoreProgressNode(width: availableWidth)
4664:         // Centrarlo horizontalmente en bottomRow,
4665:         // dejando bottomRowHorizontalPadding desde el borde izquierdo del TopBar
4666:         progressNode.position = CGPoint(
4667:             x: -barSize.width/2 + Layout.bottomRowHorizontalPadding,
4668:             y: 0
4669:         )
4670:         bottomRow.addChild(progressNode)
4671:         scoreProgressNode = progressNode
4672:     }
4673:     // MARK: - Configuración
4674:     func configure(withLevel level: GameLevel, objectiveTracker: LevelObjectiveTracker) {
4675:         switch type {
4676:         case .main:
4677:             configureMainBar(withLevel: level)
4678:         case .objectives:
4679:             configureObjectivesBar(withLevel: level, objectiveTracker: objectiveTracker)
4680:         }
4681:     }
4682:     private func configureMainBar(withLevel level: GameLevel) {
4683:         // 1) Ajustamos el texto y las vidas
4684:         levelLabel?.text = "Nivel \(level.levelId)"
4685:         maxLives = level.lives.initial
4686:         maxExtraLives = level.lives.extraLives.maxExtra
4687:         lives = level.lives.initial
4688:         setupHearts(in: heartsContainer)
4689:         updateLives(lives)
4690:         // 2) En vez de llamar a setupScoreDisplay() directamente,
4691:         //    lo hacemos en la siguiente iteración del runloop:
4692:         DispatchQueue.main.async {
4693:             self.setupScoreDisplay()
4694:         }
4695:     }
4696:     private func configureObjectivesBar(withLevel level: GameLevel, objectiveTracker: LevelObjectiveTracker) {
4697:         topRow.removeFromParent()  // si no usas la fila superior
4698:         objectivePanel?.removeFromParent()
4699:         let panelSize = CGSize(width: barSize.width, height: barSize.height)
4700:         let panel = ObjectivePanelFactory.createPanel(
4701:             for: level.objectives.primary,
4702:             size: panelSize,
4703:             tracker: objectiveTracker
4704:         )
4705:         objectivePanel = panel
4706:         // bottomRow centrado en (0,0)
4707:         bottomRow.position = .zero
4708:         bottomRow.removeAllChildren()
4709:         // AHORA, para alinear el borde izquierdo del panel con la TopBar:
4710:         // la TopBar va de x = -barSize.width/2 a x = +barSize.width/2
4711:         // si pones panel.position.x = -barSize.width/2 + 10, dejas 10 px de margen
4712:         panel.position = CGPoint(x: -barSize.width/2 + 10, y: 0)
4713:         bottomRow.addChild(panel)
4714:     }
4715:     // MARK: - Score y Vidas
4716:     func updateScore(_ newScore: Int) {
4717:         if type == .main,
4718:            let currentLevel = GameManager.shared.currentLevel {
4719:             scoreProgressNode?.updateProgress(score: newScore, maxScore: currentLevel.maxScore)
4720:         }
4721:     }
4722:     func updateLives(_ newLives: Int) {
4723:         if type == .main {
4724:             lives = newLives
4725:             updateHeartsDisplay()
4726:         }
4727:     }
4728:     // MARK: - Corazones
4729:     private func setupHearts(in container: SKNode) {
4730:         // Limpia corazones anteriores
4731:         heartNodes.forEach { $0.removeFromParent() }
4732:         heartNodes.removeAll()
4733:         var currentX: CGFloat = 0
4734:         // Vidas base
4735:         for _ in 0..<maxLives {
4736:             let heart = SKSpriteNode(imageNamed: "heart_filled")
4737:             heart.size = CGSize(width: Layout.heartSize, height: Layout.heartSize)
4738:             heart.position = CGPoint(x: currentX, y: 0)
4739:             container.addChild(heart)
4740:             heartNodes.append(heart)
4741:             currentX += Layout.heartSize + Layout.heartSpacing
4742:         }
4743:         // Vidas extra
4744:         for _ in 0..<maxExtraLives {
4745:             let heart = SKSpriteNode(imageNamed: "heart_extra")
4746:             heart.size = CGSize(width: Layout.heartSize, height: Layout.heartSize)
4747:             heart.alpha = 0
4748:             heart.position = CGPoint(x: currentX, y: 0)
4749:             container.addChild(heart)
4750:             heartNodes.append(heart)
4751:             currentX += Layout.heartSize + Layout.heartSpacing
4752:         }
4753:     }
4754:     private func updateHeartsDisplay() {
4755:         for (index, heart) in heartNodes.enumerated() {
4756:             heart.alpha = 1.0
4757:             if index < maxLives {
4758:                 if index < lives {
4759:                     heart.texture = SKTexture(imageNamed: "heart_filled")
4760:                 } else {
4761:                     heart.texture = SKTexture(imageNamed: "heart_empty")
4762:                 }
4763:             } else if index < (maxLives + maxExtraLives) {
4764:                 if index < lives {
4765:                     heart.texture = SKTexture(imageNamed: "heart_extra_filled")
4766:                     heart.alpha = 1.0
4767:                 } else {
4768:                     heart.alpha = 0
4769:                 }
4770:             }
4771:         }
4772:     }
4773:     // MARK: - Objetivos
4774:     func updateObjectiveInfo(with progress: ObjectiveProgress) {
4775:         if type == .objectives {
4776:             objectivePanel?.updateInfo(with: progress)
4777:         }
4778:     }
4779: }
4780: // MARK: - SwiftUI Previews
4781: #if DEBUG
4782: import SwiftUI
4783: struct TopBarPreview: PreviewProvider {
4784:     static var previews: some View {
4785:         TopBarPreviewContainer()
4786:             .previewDisplayName("TopBar")
4787:     }
4788: }
4789: struct TopBarPreviewContainer: View {
4790:     var body: some View {
4791:         GeometryReader { geometry in
4792:             SpriteView(scene: createScene(size: geometry.size))
4793:                 .background(Color.gray.opacity(0.2))
4794:         }
4795:     }
4796:     private func createScene(size: CGSize) -> SKScene {
4797:         let scene = SKScene(size: size)
4798:         scene.backgroundColor = .darkGray
4799:         let level = GameLevel(
4800:             levelId: 1,
4801:             name: "Nivel de prueba",
4802:             maxScore: 600,
4803:             allowedStyles: [],
4804:             fallingSpeed: FallingSpeed(initial: 8.0, increment: 0.0),
4805:             lives: Lives(
4806:                 initial: 3,
4807:                 extraLives: ExtraLives(scoreThresholds: [500, 1000], maxExtra: 2)
4808:             ),
4809:             objectives: Objectives(primary: Objective(
4810:                 type: "score",
4811:                 target: 1000,
4812:                 timeLimit: 180,
4813:                 minimumAccuracy: nil,
4814:                 details: nil
4815:             )),
4816:             blocks: [:]
4817:         )
4818:         // TopBar de tipo .main (izquierda)
4819:         let topBarWidth = min(size.width * 0.45, 300)
4820:         let topBarHeight: CGFloat = 60
4821:         let leftBar = TopBar.create(
4822:             width: topBarWidth,
4823:             height: topBarHeight,
4824:             position: CGPoint(x: size.width/2, y: size.height/2 + 50),
4825:             type: .main
4826:         )
4827:         leftBar.configure(withLevel: level, objectiveTracker: LevelObjectiveTracker(level: level))
4828:         leftBar.updateScore(300)
4829:         leftBar.updateLives(2)
4830:         scene.addChild(leftBar)
4831:         // TopBar de tipo .objectives (derecha)
4832:         let rightBar = TopBar.create(
4833:             width: topBarWidth,
4834:             height: topBarHeight,
4835:             position: CGPoint(x: size.width/2, y: size.height/2 - 50),
4836:             type: .objectives
4837:         )
4838:         rightBar.configure(withLevel: level, objectiveTracker: LevelObjectiveTracker(level: level))
4839:         let progress = ObjectiveProgress(
4840:             score: 300,
4841:             notesHit: 15,
4842:             accuracySum: 85.0,
4843:             accuracyCount: 1,
4844:             totalBlocksDestroyed: 15,
4845:             timeElapsed: 45
4846:         )
4847:         rightBar.updateObjectiveInfo(with: progress)
4848:         scene.addChild(rightBar)
4849:         return scene
4850:     }
4851: }
4852: #endif
4853: </file>
4854: <file path="MusicBlocks/Paneles/TopBarComponents.swift">
4855: //
4856: //  TopBarComponents.swift
4857: //  MusicBlocks
4858: //
4859: //  Created by Jose R. García on 14/3/25.
4860: //
4861: import SpriteKit
4862: import UIKit
4863: import Foundation
4864: // MARK: - Constantes y Configuración
4865: private enum TopBarLayout {
4866:     static let cornerRadius: CGFloat = 15
4867:     static let padding: CGFloat = 18
4868:     static let iconTextSpacing: CGFloat = 16      // Reducido para mejor ajuste
4869:     static let fontSize: CGFloat = 14
4870:     static let titleFontSize: CGFloat = 16
4871:     static let smallFontSize: CGFloat = 12
4872:     static let verticalSpacing: CGFloat = 8       // Aumentado para mejor separación
4873:     static let horizontalSpacing: CGFloat = 8
4874:     static let panelHeight: CGFloat = 60
4875:     /// Tamaño máximo para la dimensión más larga del icono.
4876:     static let iconSize: CGFloat = 18
4877:     // Valores para layout de columnas en block_destruction
4878:     static let columnWidth: CGFloat = 80          // Ancho de cada columna
4879:     static let rowSpacing: CGFloat = 20           // Espacio vertical entre filas
4880:     static let maxItemsPerColumn: Int = 2         // Máximo de items por columna
4881:     static let maxColumns: Int = 4                // Aumentado a 4 columnas máximo
4882: }
4883: // MARK: - Estructuras de Datos
4884: struct ObjectiveProgress {
4885:     var score: Int = 0
4886:     var notesHit: Int = 0
4887:     var accuracySum: Double = 0
4888:     var accuracyCount: Int = 0
4889:     var blocksByType: [String: Int] = [:]
4890:     var totalBlocksDestroyed: Int = 0
4891:     var timeElapsed: TimeInterval = 0
4892:     var averageAccuracy: Double {
4893:         return accuracyCount > 0 ? accuracySum / Double(accuracyCount) : 0
4894:     }
4895: }
4896: // MARK: - Iconos
4897: enum ObjectiveIcon {
4898:     case score
4899:     case totalNotes
4900:     case accuracy
4901:     case blocks
4902:     case time
4903:     var imageName: String {
4904:         switch self {
4905:         case .score: return "coin_icon"
4906:         case .totalNotes: return "note_icon"
4907:         case .accuracy: return "target_icon"
4908:         case .blocks: return "defaultBlock_icon"
4909:         case .time: return "timer_icon"
4910:         }
4911:     }
4912: }
4913: // MARK: - Bloque extra: mapeo de estilo -> icono
4914: private let blockStyleIcons: [String: String] = [
4915:     "defaultBlock": "defaultBlock_icon",
4916:     "iceBlock": "iceBlock_icon",
4917:     "hardiceBlock": "hardiceBlock_icon",
4918:     "ghostBlock": "ghostBlock_icon",
4919:     "changingBlock": "changingBlock_icon",
4920:     "explosiveBlock": "explosiveBlock_icon",
4921: ]
4922: // MARK: - ObjectiveIconNode
4923: class ObjectiveIconNode: SKNode {
4924:     private let icon: SKSpriteNode
4925:     private let value: SKLabelNode
4926:     init(type: ObjectiveIcon) {
4927:         // Cargamos la textura
4928:         let iconTexture = SKTexture(imageNamed: type.imageName)
4929:         // Mantener relación de aspecto
4930:         let originalSize = iconTexture.size()
4931:         let w = originalSize.width
4932:         let h = originalSize.height
4933:         // Ratio para ajustar la dimensión más larga a 'iconSize'
4934:         let maxDim: CGFloat = TopBarLayout.iconSize
4935:         let scale = max(w, h) > 0 ? (maxDim / max(w, h)) : 1.0
4936:         let finalWidth = w * scale
4937:         let finalHeight = h * scale
4938:         icon = SKSpriteNode(texture: iconTexture)
4939:         icon.size = CGSize(width: finalWidth, height: finalHeight)
4940:         value = SKLabelNode(fontNamed: "Helvetica")
4941:         super.init()
4942:         // Posicionamos el icono y la etiqueta
4943:         icon.position = CGPoint(x: -TopBarLayout.iconTextSpacing/2, y: 0)
4944:         value.fontSize = TopBarLayout.smallFontSize
4945:         value.fontColor = .darkGray
4946:         value.verticalAlignmentMode = .center
4947:         value.horizontalAlignmentMode = .left
4948:         value.position = CGPoint(x: icon.position.x + TopBarLayout.iconTextSpacing, y: 0)
4949:         addChild(icon)
4950:         addChild(value)
4951:     }
4952:     required init?(coder aDecoder: NSCoder) {
4953:         fatalError("init(coder:) has not been implemented")
4954:     }
4955:     func updateValueColor(_ color: SKColor) {
4956:         value.fontColor = color
4957:     }
4958:     func updateValue(_ newValue: String) {
4959:         value.text = newValue
4960:     }
4961: }
4962: // MARK: - Nodos Base
4963: class TopBarBaseNode: SKNode {
4964:     var size: CGSize
4965:     init(size: CGSize) {
4966:         self.size = size
4967:         super.init()
4968:         setupBackground()
4969:     }
4970:     required init?(coder aDecoder: NSCoder) {
4971:         fatalError("init(coder:) has not been implemented")
4972:     }
4973:     func setupBackground() {
4974:         let background = SKShapeNode(rectOf: size, cornerRadius: TopBarLayout.cornerRadius)
4975:         background.fillColor = .white
4976:         background.strokeColor = .clear
4977:         background.alpha = 0.95
4978:         addChild(background)
4979:     }
4980:     func createLabel(_ text: String, fontSize: CGFloat = TopBarLayout.fontSize) -> SKLabelNode {
4981:         let label = SKLabelNode(fontNamed: "Helvetica")
4982:         label.text = text
4983:         label.fontSize = fontSize
4984:         label.fontColor = .darkGray
4985:         return label
4986:     }
4987: }
4988: // MARK: - Componente de Tiempo
4989: class TimeDisplayNode: SKNode {
4990:     private let timeIcon: SKSpriteNode
4991:     private let timeLabel: SKLabelNode
4992:     private let timeLimit: TimeInterval
4993:     private let startTime: Date
4994:     init(timeLimit: TimeInterval) {
4995:         // Crear icono de tiempo
4996:         let iconTexture = SKTexture(imageNamed: "timer_icon")
4997:         timeIcon = SKSpriteNode(texture: iconTexture)
4998:         // Mantener la relación de aspecto para el icono del tiempo, si lo deseas
4999:         let originalSize = iconTexture.size()
5000:         let w = originalSize.width
5001:         let h = originalSize.height
5002:         let maxDim: CGFloat = TopBarLayout.iconSize
5003:         let scale = max(w, h) > 0 ? (maxDim / max(w, h)) : 1.0
5004:         timeIcon.size = CGSize(width: w * scale, height: h * scale)
5005:         self.timeLabel = SKLabelNode(fontNamed: "Helvetica")
5006:         self.timeLimit = timeLimit
5007:         self.startTime = Date()
5008:         super.init()
5009:         setupTimeComponents()
5010:     }
5011:     required init?(coder aDecoder: NSCoder) {
5012:         fatalError("init(coder:) has not been implemented")
5013:     }
5014:     private func setupTimeComponents() {
5015:         // Posición del icono
5016:         timeIcon.position = CGPoint(x: -TopBarLayout.iconTextSpacing/2, y: 0)
5017:         addChild(timeIcon)
5018:         // Configuración de la etiqueta
5019:         timeLabel.fontSize = TopBarLayout.fontSize
5020:         timeLabel.fontColor = .darkGray
5021:         timeLabel.verticalAlignmentMode = .center
5022:         timeLabel.horizontalAlignmentMode = .left
5023:         timeLabel.position = CGPoint(x: timeIcon.position.x + TopBarLayout.iconTextSpacing, y: 0)
5024:         addChild(timeLabel)
5025:         // Actualizar el tiempo inicial
5026:         update()
5027:     }
5028:     func update() {
5029:         if timeLimit == 0 {
5030:             timeLabel.text = "∞"
5031:             return
5032:         }
5033:         let elapsedTime = Date().timeIntervalSince(startTime)
5034:         let remainingTime = max(timeLimit - elapsedTime, 0)
5035:         let minutes = Int(remainingTime) / 60
5036:         let seconds = Int(remainingTime) % 60
5037:         timeLabel.text = String(format: "%02d:%02d", minutes, seconds)
5038:         timeLabel.fontColor = remainingTime < 30 ? .red : .darkGray
5039:     }
5040: }
5041: // MARK: - Panel Base de Objetivos
5042: class ObjectiveInfoPanel: TopBarBaseNode {
5043:     weak var objectiveTracker: LevelObjectiveTracker?
5044:     // Icono único para "score", "time", etc.
5045:     private var objectiveIconNode: ObjectiveIconNode?
5046:     private var timeIconNode: ObjectiveIconNode?
5047:     // Lista de iconos por estilo de bloque
5048:     private var blockIcons: [String: ObjectiveIconNode] = [:]
5049:     // Contenedor para el objetivo "block_destruction"
5050:     private var blockDestructionContainer: SKNode?
5051:     init(size: CGSize, objectiveTracker: LevelObjectiveTracker) {
5052:         self.objectiveTracker = objectiveTracker
5053:         super.init(size: size)
5054:         setupPanel()
5055:     }
5056:     required init?(coder aDecoder: NSCoder) {
5057:         fatalError("init(coder:) has not been implemented")
5058:     }
5059:     override func setupBackground() {
5060:         // No crear fondo blanco para el panel de objetivos
5061:     }
5062:     func setupPanel() {
5063:         guard let objective = objectiveTracker?.getPrimaryObjective() else { return }
5064:         let contentContainer = SKNode()
5065:         contentContainer.position = CGPoint(x: TopBarLayout.padding, y: 0)
5066:         addChild(contentContainer)
5067:         switch objective.type {
5068:         case "block_destruction":
5069:             // Para block_destruction, creamos un contenedor especial que organizará los bloques en columnas
5070:             let container = SKNode()
5071:             contentContainer.addChild(container)
5072:             blockDestructionContainer = container
5073:             // Ya no creamos el timeIconNode aquí, lo incluiremos en el contenedor de columnas
5074:         case "total_blocks":
5075:             // Para total_blocks, solo mostramos el total y opcionalmente el tiempo
5076:             objectiveIconNode = ObjectiveIconNode(type: .blocks)
5077:             if let objIcon = objectiveIconNode {
5078:                 objIcon.position = CGPoint(x: 0, y: TopBarLayout.verticalSpacing * 2)
5079:                 contentContainer.addChild(objIcon)
5080:             }
5081:             // Si hay límite de tiempo
5082:             if objective.timeLimit != nil {
5083:                 timeIconNode = ObjectiveIconNode(type: .time)
5084:                 if let timeIcon = timeIconNode {
5085:                     timeIcon.position = CGPoint(x: 0, y: -TopBarLayout.verticalSpacing * 2)
5086:                     contentContainer.addChild(timeIcon)
5087:                 }
5088:             }
5089:         default:
5090:             let iconType: ObjectiveIcon = getObjectiveIconType(for: objective.type)
5091:             objectiveIconNode = ObjectiveIconNode(type: iconType)
5092:             if let objIcon = objectiveIconNode {
5093:                 objIcon.position = CGPoint(x: 0, y: TopBarLayout.verticalSpacing * 2)
5094:                 contentContainer.addChild(objIcon)
5095:             }
5096:             timeIconNode = ObjectiveIconNode(type: .time)
5097:             if let timeIcon = timeIconNode {
5098:                 timeIcon.position = CGPoint(x: 0, y: -TopBarLayout.verticalSpacing * 2)
5099:                 contentContainer.addChild(timeIcon)
5100:             }
5101:         }
5102:     }
5103:     private func createBlockIconNode(for blockType: String) -> ObjectiveIconNode {
5104:         let imageName = blockStyleIcons[blockType] ?? "default_block_icon"
5105:         let iconTexture = SKTexture(imageNamed: imageName)
5106:         // Mantener la relación de aspecto
5107:         let originalSize = iconTexture.size()
5108:         let w = originalSize.width
5109:         let h = originalSize.height
5110:         let maxDim: CGFloat = TopBarLayout.iconSize
5111:         let scale = max(w, h) > 0 ? (maxDim / max(w, h)) : 1.0
5112:         let finalWidth = w * scale
5113:         let finalHeight = h * scale
5114:         // Creamos un icono .blocks
5115:         let node = ObjectiveIconNode(type: .blocks)
5116:         // Reemplazamos textura y tamaño del SKSpriteNode "existingIcon"
5117:         if let existingIcon = node.children.first as? SKSpriteNode {
5118:             existingIcon.texture = iconTexture
5119:             existingIcon.size = CGSize(width: finalWidth, height: finalHeight)
5120:         }
5121:         return node
5122:     }
5123:     private func getObjectiveIconType(for objectiveType: String) -> ObjectiveIcon {
5124:         switch objectiveType {
5125:         case "score": return .score
5126:         case "total_notes": return .totalNotes
5127:         case "note_accuracy": return .accuracy
5128:         case "block_destruction", "total_blocks": return .blocks
5129:         default: return .score
5130:         }
5131:     }
5132:     func updateInfo(with progress: ObjectiveProgress) {
5133:         guard let objective = objectiveTracker?.getPrimaryObjective() else { return }
5134:         switch objective.type {
5135:         case "block_destruction":
5136:             if let details = objective.details {
5137:                 // Actualizar el layout de los bloques en formato de columnas
5138:                 updateBlockDestructionLayout(with: progress, details: details)
5139:             }
5140:             if let timeLimit = objective.timeLimit {
5141:                 updateTimeIcon(progress: progress, timeLimit: timeLimit)
5142:             } else {
5143:                 timeIconNode?.updateValue("∞")
5144:             }
5145:         default:
5146:             switch objective.type {
5147:             case "score":
5148:                 objectiveIconNode?.updateValue("\(progress.score)/\(objective.target ?? 0)")
5149:             case "total_notes":
5150:                 objectiveIconNode?.updateValue("\(progress.notesHit)/\(objective.target ?? 0)")
5151:             case "note_accuracy":
5152:                 let accuracy = Int(progress.averageAccuracy * 100)
5153:                 objectiveIconNode?.updateValue("\(accuracy)%")
5154:             case "total_blocks":
5155:                 objectiveIconNode?.updateValue("\(progress.totalBlocksDestroyed)/\(objective.target ?? 0)")
5156:             default:
5157:                 break
5158:             }
5159:             if let timeLimit = objective.timeLimit {
5160:                 updateTimeIcon(progress: progress, timeLimit: timeLimit)
5161:             } else {
5162:                 timeIconNode?.updateValue("∞")
5163:             }
5164:         }
5165:     }
5166:     // Método para actualizar el layout de block_destruction en formato de columnas
5167:     private func updateBlockDestructionLayout(with progress: ObjectiveProgress, details: [String: Int]) {
5168:          // Limpiar el contenedor existente si hay uno
5169:          blockDestructionContainer?.removeAllChildren()
5170:          guard let container = blockDestructionContainer else { return }
5171:          guard let objective = objectiveTracker?.getPrimaryObjective() else { return }
5172:          // Crear una lista de todos los elementos a mostrar (bloques + tiempo si hay límite)
5173:          var displayItems: [(type: String, label: String, isTimeIcon: Bool)] = []
5174:          // Añadir bloques
5175:          for (blockType, required) in details {
5176:              let destroyed = progress.blocksByType[blockType, default: 0]
5177:              let text = "\(destroyed)/\(required)"
5178:              displayItems.append((type: blockType, label: text, isTimeIcon: false))
5179:          }
5180:          // Añadir tiempo si hay límite
5181:          if let timeLimit = objective.timeLimit {
5182:              let timeLimitInterval = TimeInterval(timeLimit)
5183:              let remainingTime = max(timeLimitInterval - progress.timeElapsed, 0)
5184:              let minutes = Int(remainingTime) / 60
5185:              let seconds = Int(remainingTime) % 60
5186:              let timeText = String(format: "%02d:%02d", minutes, seconds)
5187:              displayItems.append((type: "time", label: timeText, isTimeIcon: true))
5188:          }
5189:          // Calcular cuántas columnas necesitamos
5190:          let totalItems = displayItems.count
5191:          let columnsNeeded = min((totalItems + 1) / 2, TopBarLayout.maxColumns) // Máximo 4 columnas
5192:          // Calcular posición inicial
5193:          var startX: CGFloat = 0
5194:          // Si tenemos más de una columna, alineamos desde la izquierda
5195:          if columnsNeeded > 1 {
5196:              startX = -((CGFloat(columnsNeeded - 1) * TopBarLayout.columnWidth) / 2)
5197:          }
5198:          var currentX = startX
5199:          var currentY: CGFloat = TopBarLayout.rowSpacing // Primera fila
5200:          var itemsInCurrentColumn = 0
5201:          // Organizar bloques en columnas
5202:         for (_, item) in displayItems.enumerated() {
5203:              // Si completamos 2 items en la columna actual, pasamos a la siguiente columna
5204:              if itemsInCurrentColumn >= TopBarLayout.maxItemsPerColumn {
5205:                  currentX += TopBarLayout.columnWidth
5206:                  currentY = TopBarLayout.rowSpacing // Volvemos a la primera fila
5207:                  itemsInCurrentColumn = 0
5208:              }
5209:              // Crear nodo para este elemento
5210:              let iconNode: ObjectiveIconNode
5211:              if item.isTimeIcon {
5212:                  iconNode = ObjectiveIconNode(type: .time)
5213:              } else {
5214:                  iconNode = createBlockIconNode(for: item.type)
5215:              }
5216:              // Posicionar según la columna y fila actual
5217:              let yPos = currentY - (CGFloat(itemsInCurrentColumn) * TopBarLayout.rowSpacing)
5218:              iconNode.position = CGPoint(x: currentX, y: yPos)
5219:              // Actualizar valor
5220:              iconNode.updateValue(item.label)
5221:              // Si es el icono de tiempo y queda poco tiempo, colorear en rojo
5222:              if item.isTimeIcon {
5223:                  if let timeLimit = objective.timeLimit {
5224:                      let timeLimitInterval = TimeInterval(timeLimit)
5225:                      let remainingTime = max(timeLimitInterval - progress.timeElapsed, 0)
5226:                      if remainingTime < 30 {
5227:                          iconNode.updateValueColor(.red)
5228:                      }
5229:                  }
5230:              }
5231:              // Añadir al contenedor
5232:              container.addChild(iconNode)
5233:              // Actualizar contadores
5234:              itemsInCurrentColumn += 1
5235:          }
5236:          // Posicionar el contenedor en la parte superior del panel
5237:          container.position = CGPoint(x: 0, y: TopBarLayout.verticalSpacing * 2)
5238:      }
5239:     private func updateTimeIcon(progress: ObjectiveProgress, timeLimit: Int) {
5240:         let timeLimitInterval = TimeInterval(timeLimit)
5241:         let remainingTime = max(timeLimitInterval - progress.timeElapsed, 0)
5242:         let minutes = Int(remainingTime) / 60
5243:         let seconds = Int(remainingTime) % 60
5244:         let timeText = String(format: "%02d:%02d", minutes, seconds)
5245:         timeIconNode?.updateValue(timeText)
5246:         if remainingTime < 30 {
5247:             timeIconNode?.updateValueColor(.red)
5248:         } else {
5249:             timeIconNode?.updateValueColor(.darkGray)
5250:         }
5251:     }
5252: }
5253:     // MARK: - Fábrica de Paneles
5254:     class ObjectivePanelFactory {
5255:         static func createPanel(for objective: Objective, size: CGSize, tracker: LevelObjectiveTracker) -> ObjectiveInfoPanel {
5256:             return ObjectiveInfoPanel(size: size, objectiveTracker: tracker)
5257:         }
5258:     }
5259: // MARK: - Preview
5260: #if DEBUG
5261: import SwiftUI
5262: /// Vista previa que muestra cada ObjectiveInfoPanel en una escena separada
5263: struct ObjectivePanelsPreview: PreviewProvider {
5264:     static var previews: some View {
5265:         VStack {
5266:             ScoreObjectivePreviewContainer()
5267:                 .frame(height: 150)
5268:                 .padding(.bottom, 10)
5269:                 .previewDisplayName("Score Objective")
5270:             TotalNotesObjectivePreviewContainer()
5271:                 .frame(height: 150)
5272:                 .padding(.bottom, 10)
5273:                 .previewDisplayName("Total Notes Objective")
5274:             NoteAccuracyObjectivePreviewContainer()
5275:                 .frame(height: 150)
5276:                 .padding(.bottom, 10)
5277:                 .previewDisplayName("Note Accuracy Objective")
5278:             BlockDestructionObjectivePreviewContainer()
5279:                 .frame(height: 150)
5280:                 .padding(.bottom, 10)
5281:                 .previewDisplayName("Block Destruction Objective (Columnas)")
5282:             TotalBlocksObjectivePreviewContainer()
5283:                 .frame(height: 150)
5284:                 .previewDisplayName("Total Blocks Objective")
5285:         }
5286:     }
5287: }
5288: // Contenedor base para reutilizar código
5289: protocol ObjectivePreviewContainer: View {
5290:     var objectiveType: String { get }
5291:     func createObjectiveDetails() -> [String: Int]?
5292:     func createBlocksDestroyed() -> [String: Int]
5293:     func createAllowedStyles() -> [String]
5294: }
5295: extension ObjectivePreviewContainer {
5296:     func createPreviewScene(size: CGSize) -> SKScene {
5297:         let scene = SKScene(size: size)
5298:         scene.scaleMode = .resizeFill
5299:         scene.backgroundColor = .lightGray
5300:         let objectiveDetails = createObjectiveDetails()
5301:         let allowedStyles = createAllowedStyles()
5302:         let blocksDestroyed = createBlocksDestroyed()
5303:         let objective = Objective(
5304:             type: objectiveType,
5305:             target: 1000,
5306:             timeLimit: 180,
5307:             minimumAccuracy: objectiveType == "note_accuracy" ? 0.85 : nil,
5308:             details: objectiveDetails
5309:         )
5310:         let level = GameLevel(
5311:             levelId: 1,
5312:             name: "Nivel de prueba",
5313:             maxScore: 500,
5314:             allowedStyles: allowedStyles,
5315:             fallingSpeed: FallingSpeed(initial: 8.0, increment: 0.0),
5316:             lives: Lives(
5317:                 initial: 3,
5318:                 extraLives: ExtraLives(scoreThresholds: [], maxExtra: 0)
5319:             ),
5320:             objectives: Objectives(primary: objective),
5321:             blocks: [:]
5322:         )
5323:         let tracker = LevelObjectiveTracker(level: level)
5324:         let progress = ObjectiveProgress(
5325:             score: 350,
5326:             notesHit: 40,
5327:             accuracySum: 85.0,
5328:             accuracyCount: 100,
5329:             blocksByType: blocksDestroyed,
5330:             totalBlocksDestroyed: blocksDestroyed.values.reduce(0, +),
5331:             timeElapsed: 60
5332:         )
5333:         let panelSize = CGSize(width: size.width * 0.8, height: size.height * 0.7)
5334:         let panel = ObjectivePanelFactory.createPanel(for: objective, size: panelSize, tracker: tracker)
5335:         panel.updateInfo(with: progress)
5336:         panel.position = CGPoint(x: size.width/2, y: size.height/2)
5337:         scene.addChild(panel)
5338:         return scene
5339:     }
5340: }
5341: // Implementaciones específicas para cada tipo de objetivo
5342: struct ScoreObjectivePreviewContainer: View, ObjectivePreviewContainer {
5343:     var objectiveType: String { "score" }
5344:     func createObjectiveDetails() -> [String: Int]? { nil }
5345:     func createBlocksDestroyed() -> [String: Int] { [:] }
5346:     func createAllowedStyles() -> [String] { [] }
5347:     var body: some View {
5348:         GeometryReader { geometry in
5349:             SpriteView(scene: createPreviewScene(size: geometry.size))
5350:                 .background(Color.gray.opacity(0.2))
5351:         }
5352:     }
5353: }
5354: struct TotalNotesObjectivePreviewContainer: View, ObjectivePreviewContainer {
5355:     var objectiveType: String { "total_notes" }
5356:     func createObjectiveDetails() -> [String: Int]? { nil }
5357:     func createBlocksDestroyed() -> [String: Int] { [:] }
5358:     func createAllowedStyles() -> [String] { [] }
5359:     var body: some View {
5360:         GeometryReader { geometry in
5361:             SpriteView(scene: createPreviewScene(size: geometry.size))
5362:                 .background(Color.gray.opacity(0.2))
5363:         }
5364:     }
5365: }
5366: struct NoteAccuracyObjectivePreviewContainer: View, ObjectivePreviewContainer {
5367:     var objectiveType: String { "note_accuracy" }
5368:     func createObjectiveDetails() -> [String: Int]? { nil }
5369:     func createBlocksDestroyed() -> [String: Int] { [:] }
5370:     func createAllowedStyles() -> [String] { [] }
5371:     var body: some View {
5372:         GeometryReader { geometry in
5373:             SpriteView(scene: createPreviewScene(size: geometry.size))
5374:                 .background(Color.gray.opacity(0.2))
5375:         }
5376:     }
5377: }
5378: struct BlockDestructionObjectivePreviewContainer: View, ObjectivePreviewContainer {
5379:     var objectiveType: String { "block_destruction" }
5380:     func createObjectiveDetails() -> [String: Int]? {
5381:         return [
5382:             "defaultBlock": 5,
5383:             "iceBlock": 3,
5384:             "hardiceBlock": 7,
5385:             "ghostBlock": 4,
5386:             "changingBlock": 6,
5387:             "explosiveBlock": 2
5388:         ]
5389:     }
5390:     func createBlocksDestroyed() -> [String: Int] {
5391:         return [
5392:             "defaultBlock": 2,
5393:             "iceBlock": 3,
5394:             "hardiceBlock": 5,
5395:             "ghostBlock": 1,
5396:             "changingBlock": 4,
5397:             "explosiveBlock": 0
5398:         ]
5399:     }
5400:     func createAllowedStyles() -> [String] {
5401:         return ["defaultBlock", "iceBlock", "hardiceBlock", "ghostBlock", "changingBlock", "explosiveBlock"]
5402:     }
5403:     var body: some View {
5404:         GeometryReader { geometry in
5405:             SpriteView(scene: createPreviewScene(size: geometry.size))
5406:                 .background(Color.gray.opacity(0.2))
5407:         }
5408:     }
5409:     // Sobrescribir la función createPreviewScene para asegurar que incluya tiempo
5410:     func createPreviewScene(size: CGSize) -> SKScene {
5411:         let scene = SKScene(size: size)
5412:         scene.scaleMode = .resizeFill
5413:         scene.backgroundColor = .lightGray
5414:         let objectiveDetails = createObjectiveDetails()
5415:         let allowedStyles = createAllowedStyles()
5416:         let blocksDestroyed = createBlocksDestroyed()
5417:         let objective = Objective(
5418:             type: objectiveType,
5419:             target: 1000,
5420:             timeLimit: 180, // Asegurar que tenga límite de tiempo
5421:             minimumAccuracy: nil,
5422:             details: objectiveDetails
5423:         )
5424:         let level = GameLevel(
5425:             levelId: 1,
5426:             name: "Nivel de prueba",
5427:             maxScore: 500,
5428:             allowedStyles: allowedStyles,
5429:             fallingSpeed: FallingSpeed(initial: 8.0, increment: 0.0),
5430:             lives: Lives(
5431:                 initial: 3,
5432:                 extraLives: ExtraLives(scoreThresholds: [], maxExtra: 0)
5433:             ),
5434:             objectives: Objectives(primary: objective),
5435:             blocks: [:]
5436:         )
5437:         let tracker = LevelObjectiveTracker(level: level)
5438:         let progress = ObjectiveProgress(
5439:             score: 350,
5440:             notesHit: 40,
5441:             accuracySum: 85.0,
5442:             accuracyCount: 100,
5443:             blocksByType: blocksDestroyed,
5444:             totalBlocksDestroyed: blocksDestroyed.values.reduce(0, +),
5445:             timeElapsed: 60
5446:         )
5447:         let panelSize = CGSize(width: size.width * 0.8, height: size.height * 0.7)
5448:         let panel = ObjectivePanelFactory.createPanel(for: objective, size: panelSize, tracker: tracker)
5449:         panel.updateInfo(with: progress)
5450:         panel.position = CGPoint(x: size.width/2, y: size.height/2)
5451:         scene.addChild(panel)
5452:         return scene
5453:     }
5454: }
5455: struct TotalBlocksObjectivePreviewContainer: View, ObjectivePreviewContainer {
5456:     var objectiveType: String { "total_blocks" }
5457:     func createObjectiveDetails() -> [String: Int]? { nil }
5458:     func createBlocksDestroyed() -> [String: Int] {
5459:         // Para total_blocks solo importa el total, no los detalles por tipo
5460:         return [
5461:             "defaultBlock": 3,
5462:             "iceBlock": 5,
5463:             "hardiceBlock": 2,
5464:         ]
5465:     }
5466:     func createAllowedStyles() -> [String] {
5467:         return ["defaultBlock", "iceBlock", "hardiceBlock"]
5468:     }
5469:     var body: some View {
5470:         GeometryReader { geometry in
5471:             SpriteView(scene: createPreviewScene(size: geometry.size))
5472:                 .background(Color.gray.opacity(0.2))
5473:         }
5474:     }
5475: }
5476: #endif
5477: </file>
5478: <file path="MusicBlocks/Paneles/TuningIndicatorNode.swift">
5479: //
5480: //  TuningIndicatorNode.swift
5481: //  MusicBlocks
5482: //
5483: //  Created by Jose R. García on 25/2/25.
5484: //
5485: //
5486: //  TuningIndicatorNode.swift
5487: //  MusicBlocks
5488: //
5489: //  Creado por Jose R. García el 25/2/25.
5490: //
5491: import SpriteKit
5492: // Extensión para limitar valores numéricos
5493: extension Comparable {
5494:     func clamped(to range: ClosedRange<Self>) -> Self {
5495:         return min(max(self, range.lowerBound), range.upperBound)
5496:     }
5497: }
5498: class TuningIndicatorNode: SKNode {
5499:     // MARK: - Layout Configuration
5500:     private struct Layout {
5501:         static let barWidthRatio: CGFloat = 0.8
5502:         static let markingWidthRatio: CGFloat = 0.6
5503:         // Cambiamos el ratio del indicador para que ocupe todo el ancho de la barra
5504:         static let indicatorSizeRatio: CGFloat = 1.0  // Cambiado de 0.15 a 1.0
5505:         static let backgroundAlpha: CGFloat = 0.15
5506:         static let markingsAlpha: CGFloat = 0.3
5507:         static let glowAlpha: CGFloat = 0.8
5508:         static let inactiveAlpha: CGFloat = 0.2
5509:         static let animationDuration: TimeInterval = 0.2
5510:         static let glowRadius: Float = 15.0
5511:         static let glowLineWidth: CGFloat = 8.0
5512:     }
5513:     // MARK: - Properties
5514:     var containerSize: CGSize {
5515:         didSet {
5516:             updateLayout()
5517:         }
5518:     }
5519:     private let backgroundBar: SKShapeNode = SKShapeNode()
5520:     private var markings: [SKShapeNode] = []
5521:     // Indicador central
5522:     private let indicatorContainer: SKNode = SKNode()
5523:     private let indicatorCore: SKShapeNode = SKShapeNode()
5524:     // Glow de la barra (se muestra como contorno)
5525:     private let barGlow: SKEffectNode = SKEffectNode()
5526:     private let barGlowShape: SKShapeNode = SKShapeNode()
5527:     var deviation: Double = 0 {
5528:         didSet {
5529:             updateIndicator()
5530:         }
5531:     }
5532:     var isActive: Bool = false {
5533:         didSet {
5534:             updateIndicator()
5535:         }
5536:     }
5537:     // MARK: - Initialization
5538:     init(size: CGSize) {
5539:         self.containerSize = size
5540:         // Crear marcas basadas en valores fijos [-25, -10, 0, 10, 25]
5541:         let markValues = [-25, -10, 0, 10, 25]
5542:         for _ in markValues {
5543:             let mark = SKShapeNode()
5544:             markings.append(mark)
5545:         }
5546:         super.init()
5547:         setupNodes()
5548:         updateLayout()
5549:     }
5550:     required init?(coder aDecoder: NSCoder) {
5551:         fatalError("init(coder:) no ha sido implementado")
5552:     }
5553:     // MARK: - Setup
5554:     private func setupNodes() {
5555:         // Aplicar estilo común del contenedor
5556:         applyContainerStyle(size: containerSize)
5557:         // Mantener configuración del glow
5558:         barGlow.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": Layout.glowRadius])
5559:         barGlow.shouldRasterize = true
5560:         barGlow.addChild(barGlowShape)
5561:         barGlow.zPosition = -1
5562:         addChild(barGlow)
5563:         // Configurar marcas
5564:         for mark in markings {
5565:             mark.fillColor = .darkGray
5566:             mark.strokeColor = .clear
5567:             mark.alpha = Layout.markingsAlpha
5568:             addChild(mark)
5569:         }
5570:         // Configurar indicador central
5571:         addChild(indicatorContainer)
5572:         // Configurar el indicador core (círculo que ocupa todo el ancho de la barra)
5573:         let barWidth = containerSize.width * Layout.barWidthRatio
5574:         let indicatorDiameter = barWidth // El diámetro será igual al ancho de la barra
5575:         let indicatorRadius = indicatorDiameter / 2
5576:         indicatorCore.path = CGPath(ellipseIn: CGRect(x: -indicatorRadius,
5577:                                                      y: -indicatorRadius,
5578:                                                      width: indicatorDiameter,
5579:                                                      height: indicatorDiameter),
5580:                                   transform: nil)
5581:         indicatorCore.strokeColor = .clear
5582:         indicatorContainer.addChild(indicatorCore)
5583:         updateIndicator()
5584:     }
5585:     // MARK: - Layout Update
5586:     private func updateLayout() {
5587:         let barWidth = containerSize.width * Layout.barWidthRatio
5588:         let barHeight = containerSize.height
5589:         let bgRect = CGRect(x: -barWidth/2, y: -barHeight/2, width: barWidth, height: barHeight)
5590:         backgroundBar.path = CGPath(rect: bgRect, transform: nil)
5591:         barGlowShape.path = CGPath(rect: bgRect, transform: nil)
5592:         barGlowShape.lineWidth = Layout.glowLineWidth
5593:         // Actualizar marcas
5594:         for (index, mark) in markings.enumerated() {
5595:             let progress = CGFloat(index) / CGFloat(markings.count - 1)
5596:             let yPosition = -containerSize.height / 2 + containerSize.height * progress
5597:             mark.position = CGPoint(x: 0, y: yPosition)
5598:             let markWidth: CGFloat
5599:             // Se define una marca central más ancha (por ejemplo, índice 2)
5600:             if index == 2 {
5601:                 markWidth = barWidth * 0.8
5602:             } else {
5603:                 markWidth = barWidth * Layout.markingWidthRatio
5604:             }
5605:             let markRect = CGRect(x: -markWidth/2, y: -0.5, width: markWidth, height: 1)
5606:             mark.path = CGPath(rect: markRect, transform: nil)
5607:         }
5608:         updateIndicator()
5609:     }
5610:     // MARK: - Updates
5611:     private func updateIndicator() {
5612:         let normalizedDeviation = CGFloat((deviation + 25) / 50).clamped(to: 0...1)
5613:         let barWidth = containerSize.width * Layout.barWidthRatio
5614:         let indicatorRadius = barWidth * Layout.indicatorSizeRatio
5615:         let effectiveHeight = containerSize.height - (indicatorRadius * 2)
5616:         let minY = -containerSize.height / 2 + indicatorRadius
5617:         let yPosition = minY + (effectiveHeight * normalizedDeviation)
5618:         // Asegúrate de que el indicador tenga una forma definida
5619:         if indicatorCore.path == nil {
5620:             indicatorCore.path = CGPath(ellipseIn: CGRect(x: -indicatorRadius, y: -indicatorRadius,
5621:                                                        width: indicatorRadius*2, height: indicatorRadius*2), transform: nil)
5622:         }
5623:         let moveAction = SKAction.move(to: CGPoint(x: 0, y: yPosition), duration: Layout.animationDuration)
5624:         moveAction.timingMode = .easeOut
5625:         indicatorContainer.run(moveAction)
5626:         let color = getDeviationColor()
5627:         indicatorCore.fillColor = color
5628:         indicatorCore.alpha = isActive ? Layout.glowAlpha : Layout.inactiveAlpha
5629:         barGlowShape.strokeColor = color
5630:         barGlowShape.fillColor = .clear
5631:         barGlowShape.alpha = isActive ? Layout.glowAlpha : Layout.inactiveAlpha
5632:     }
5633:     private func getDeviationColor() -> SKColor {
5634:         guard isActive else {
5635:             return .gray
5636:         }
5637:         let absDeviation = abs(deviation)
5638:         if absDeviation < 5 {
5639:             return .green
5640:         } else if absDeviation < 15 {
5641:             return .orange
5642:         } else {
5643:             return .red
5644:         }
5645:     }
5646: }
5647: #if DEBUG
5648: import SwiftUI
5649: // MARK: - Previews
5650: extension TuningIndicatorNode {
5651:     static func createPreviewScene() -> SKScene {
5652:         let scene = SKScene(size: CGSize(width: 300, height: 200))
5653:         scene.backgroundColor = .white
5654:         let states: [(deviation: Double, isActive: Bool, position: CGPoint)] = [
5655:             (0, true, CGPoint(x: 75, y: 100)),     // Perfecta afinación
5656:             (12, true, CGPoint(x: 150, y: 100)),   // Desviación leve
5657:             (-20, true, CGPoint(x: 225, y: 100))   // Desviación grande
5658:         ]
5659:         for state in states {
5660:             let node = TuningIndicatorNode(size: CGSize(width: 20, height: 190))
5661:             node.position = state.position
5662:             node.deviation = state.deviation
5663:             node.isActive = state.isActive
5664:             scene.addChild(node)
5665:         }
5666:         return scene
5667:     }
5668: }
5669: struct TuningIndicatorPreview: PreviewProvider {
5670:     static var previews: some View {
5671:         SpriteView(scene: TuningIndicatorNode.createPreviewScene())
5672:             .frame(width: 300, height: 200)
5673:             .previewLayout(.fixed(width: 300, height: 200))
5674:     }
5675: }
5676: #endif
5677: </file>
5678: <file path="MusicBlocks/Paneles/UIContainer.swift">
5679: //
5680: //  UIContainer.swift
5681: //  MusicBlocks
5682: //
5683: //  Created by Jose R. García on 8/3/25.
5684: //
5685: import SpriteKit
5686: struct CommonStyle {
5687:     static let containerBackgroundColor: SKColor = .white
5688:     static let containerBackgroundAlpha: CGFloat = 0.85
5689:     static let containerCornerRadius: CGFloat = 12
5690:     static let shadowColor: SKColor = .black
5691:     static let shadowRadius: Float = 4.0
5692:     static let shadowOpacity: Float = 0.2
5693:     static let shadowOffset = CGPoint(x: 0, y: -2)
5694: }
5695: extension SKNode {
5696:     func applyContainerStyle(size: CGSize) {
5697:         // Crear y configurar sombra
5698:         let shadowNode = SKEffectNode()
5699:         shadowNode.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": CommonStyle.shadowRadius])
5700:         shadowNode.shouldRasterize = true
5701:         let shadowShape = SKShapeNode(rectOf: size, cornerRadius: CommonStyle.containerCornerRadius)
5702:         shadowShape.fillColor = CommonStyle.shadowColor
5703:         shadowShape.strokeColor = .clear
5704:         shadowShape.alpha = CGFloat(CommonStyle.shadowOpacity)
5705:         shadowShape.position = CommonStyle.shadowOffset
5706:         shadowNode.addChild(shadowShape)
5707:         // Crear y configurar contenedor principal
5708:         let container = SKShapeNode(rectOf: size, cornerRadius: CommonStyle.containerCornerRadius)
5709:         container.fillColor = CommonStyle.containerBackgroundColor
5710:         container.strokeColor = .clear
5711:         container.alpha = CommonStyle.containerBackgroundAlpha
5712:         // Añadir nodos en orden correcto
5713:         addChild(shadowNode)
5714:         addChild(container)
5715:     }
5716: }
5717: </file>
5718: <file path="MusicBlocks/Preview Content/Preview Assets.xcassets/Contents.json">
5719: {
5720:   "info" : {
5721:     "author" : "xcode",
5722:     "version" : 1
5723:   }
5724: }
5725: </file>
5726: <file path="MusicBlocks/BackgroundPatternNode.swift">
5727: //
5728: //  BackgroundPatternNode.swift
5729: //  MusicBlocks
5730: //
5731: //  Created by Jose R. García on 27/2/25.
5732: //
5733: import SpriteKit
5734: class BackgroundPatternNode: SKNode {
5735:     // MARK: - Properties
5736:     let pastelColors: [UIColor]
5737:     private let contrastColor: UIColor
5738:     private let opacity: CGFloat
5739:     private let colors: [UIColor] = []
5740:     // Configuración de elementos
5741:     private let numberOfWaves = 8
5742:     private let numberOfLines = 12
5743:     private let numberOfCircles = 6
5744:     private let numberOfDiagonals = 15
5745:     private let numberOfNotes = 10
5746:     // Rangos para símbolos musicales
5747:     private let notesSizeRange: ClosedRange<CGFloat> = 20...50
5748:     private let notesRotationRange: ClosedRange<CGFloat> = -45...45
5749:     private let musicImages = [
5750:         "MusicalSymbol_01", "MusicalSymbol_02", "MusicalSymbol_03", "MusicalSymbol_04", "MusicalSymbol_05",
5751:         "MusicalSymbol_06", "MusicalSymbol_07", "MusicalSymbol_08", "MusicalSymbol_09", "MusicalSymbol_10",
5752:         "MusicalSymbol_11", "MusicalSymbol_12", "MusicalSymbol_13", "MusicalSymbol_14", "MusicalSymbol_15",
5753:         "MusicalSymbol_16", "MusicalSymbol_17", "MusicalSymbol_18", "MusicalSymbol_19", "MusicalSymbol_20",
5754:         "MusicalSymbol_21", "MusicalSymbol_22", "MusicalSymbol_23"
5755:     ]
5756:     // MARK: - Inicialización
5757:     init(size: CGSize) {
5758:         // Se generan dos colores pastel para el degradado
5759:         self.pastelColors = Self.generatePastelColors()
5760:         // Se calcula un color de contraste (por ejemplo, complementario del primero)
5761:         self.contrastColor = Self.contrastingColor(for: pastelColors.first ?? .white)
5762:         self.opacity = CGFloat.random(in: 0.1...0.2)
5763:         super.init()
5764:         // Se agrega el fondo degradado
5765:         addGradientBackground(size: size, colors: pastelColors)
5766:         // Se agregan las capas de formas y símbolos en color de contraste
5767:         setupLayers(size: size)
5768:     }
5769:     required init?(coder aDecoder: NSCoder) {
5770:         fatalError("init(coder:) has not been implementado")
5771:     }
5772:     // MARK: - Métodos de Configuración
5773:     private func addGradientBackground(size: CGSize, colors: [UIColor]) {
5774:         let texture = gradientTexture(size: size, colors: colors)
5775:         let backgroundNode = SKSpriteNode(texture: texture)
5776:         // Forzamos anclaje en la esquina inferior izquierda
5777:         backgroundNode.anchorPoint = CGPoint(x: 0, y: 0)
5778:         // Así, position (0,0) en el padre coincide con la esquina inferior izqda.
5779:         backgroundNode.position = .zero
5780:         backgroundNode.size = size
5781:         backgroundNode.zPosition = -1
5782:         addChild(backgroundNode)
5783:     }
5784:     private func setupLayers(size: CGSize) {
5785:         addWavesLayer(size: size)
5786:         addLinesLayer(size: size)
5787:         addCirclesLayer(size: size)
5788:         addDiagonalBarsLayer(size: size)
5789:         addNotesLayer(size: size)
5790:     }
5791:     // MARK: - Creación de Capas
5792:     private func addWavesLayer(size: CGSize) {
5793:         let path = CGMutablePath()
5794:         for i in 0...numberOfWaves {
5795:             let x = CGFloat(i) * size.width / CGFloat(numberOfWaves)
5796:             path.move(to: CGPoint(x: x, y: 0))
5797:             path.addCurve(
5798:                 to: CGPoint(x: x, y: size.height),
5799:                 control1: CGPoint(x: x + 60 * sin(CGFloat(i)), y: size.height * 0.3),
5800:                 control2: CGPoint(x: x - 60 * cos(CGFloat(i)), y: size.height * 0.7)
5801:             )
5802:         }
5803:         let shapeNode = SKShapeNode(path: path)
5804:         shapeNode.strokeColor = contrastColor
5805:         shapeNode.lineWidth = 1.5
5806:         shapeNode.alpha = opacity * 0.7
5807:         addChild(shapeNode)
5808:     }
5809:     private func addLinesLayer(size: CGSize) {
5810:         let path = CGMutablePath()
5811:         for _ in 0..<numberOfLines {
5812:             let start = CGPoint(
5813:                 x: .random(in: 0...size.width),
5814:                 y: .random(in: 0...size.height)
5815:             )
5816:             let end = CGPoint(
5817:                 x: .random(in: 0...size.width),
5818:                 y: .random(in: 0...size.height)
5819:             )
5820:             path.move(to: start)
5821:             path.addLine(to: end)
5822:         }
5823:         let shapeNode = SKShapeNode(path: path)
5824:         shapeNode.strokeColor = contrastColor
5825:         shapeNode.lineWidth = 1.0
5826:         shapeNode.alpha = opacity * 0.6
5827:         addChild(shapeNode)
5828:     }
5829:     private func addCirclesLayer(size: CGSize) {
5830:         for _ in 0..<numberOfCircles {
5831:             let diameter = CGFloat.random(in: 40...180)
5832:             let circle = SKShapeNode(circleOfRadius: diameter / 2)
5833:             circle.position = CGPoint(
5834:                 x: .random(in: 0...size.width),
5835:                 y: .random(in: 0...size.height)
5836:             )
5837:             circle.strokeColor = contrastColor
5838:             circle.lineWidth = 1.5
5839:             circle.alpha = opacity * 0.5
5840:             addChild(circle)
5841:         }
5842:     }
5843:     private func addDiagonalBarsLayer(size: CGSize) {
5844:         let path = CGMutablePath()
5845:         let spacing: CGFloat = 50
5846:         let rotationAngle: CGFloat = .pi / 4
5847:         for x in stride(from: -size.width, through: size.width * 2, by: spacing) {
5848:             let transform = CGAffineTransform(rotationAngle: rotationAngle)
5849:             let start = CGPoint(x: x, y: 0).applying(transform)
5850:             let end = CGPoint(x: x, y: size.height).applying(transform)
5851:             path.move(to: start)
5852:             path.addLine(to: end)
5853:         }
5854:         let shapeNode = SKShapeNode(path: path)
5855:         shapeNode.strokeColor = contrastColor
5856:         shapeNode.lineWidth = 1.0
5857:         shapeNode.alpha = opacity * 0.4
5858:         addChild(shapeNode)
5859:     }
5860:     private func addNotesLayer(size: CGSize) {
5861:         for _ in 0..<numberOfNotes {
5862:             guard let imageName = musicImages.randomElement() else { continue }
5863:             let noteSize = CGFloat.random(in: notesSizeRange)
5864:             let texture = SKTexture(imageNamed: imageName)
5865:             let noteNode = SKSpriteNode(texture: texture)
5866:             noteNode.size = CGSize(width: noteSize, height: noteSize)
5867:             noteNode.position = CGPoint(
5868:                 x: .random(in: 0...size.width),
5869:                 y: .random(in: 0...size.height)
5870:             )
5871:             noteNode.zRotation = CGFloat.random(in: notesRotationRange) * .pi / 180
5872:             noteNode.alpha = opacity * 0.8
5873:             noteNode.color = contrastColor
5874:             noteNode.colorBlendFactor = 1.0
5875:             addChild(noteNode)
5876:         }
5877:     }
5878:     // MARK: - Métodos Auxiliares
5879:     private static func generatePastelColors() -> [UIColor] {
5880:         let baseHues = [
5881:             CGFloat.random(in: 0...1),
5882:             CGFloat.random(in: 0...1)
5883:         ]
5884:         return baseHues.map { hue in
5885:             UIColor(
5886:                 hue: hue,
5887:                 saturation: CGFloat.random(in: 0.3...0.4),
5888:                 brightness: CGFloat.random(in: 0.9...1.0),
5889:                 alpha: 1.0
5890:             )
5891:         }
5892:     }
5893:     private static func contrastingColor(for color: UIColor) -> UIColor {
5894:         var hue: CGFloat = 0, saturation: CGFloat = 0, brightness: CGFloat = 0, alpha: CGFloat = 0
5895:         if color.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: &alpha) {
5896:             // Se calcula el color complementario
5897:             let complementaryHue = (hue + 0.5).truncatingRemainder(dividingBy: 1.0)
5898:             return UIColor(
5899:                 hue: complementaryHue,
5900:                 saturation: max(saturation, 0.7),
5901:                 brightness: max(brightness - 0.5, 0.3),
5902:                 alpha: 1.0
5903:             )
5904:         }
5905:         return .black
5906:     }
5907:     private func gradientTexture(size: CGSize, colors: [UIColor]) -> SKTexture {
5908:         let gradientLayer = CAGradientLayer()
5909:         gradientLayer.frame = CGRect(origin: .zero, size: size)
5910:         gradientLayer.colors = colors.map { $0.cgColor }
5911:         gradientLayer.startPoint = CGPoint(x: 0, y: 0)
5912:         gradientLayer.endPoint = CGPoint(x: 1, y: 1)
5913:         UIGraphicsBeginImageContext(gradientLayer.frame.size)
5914:         guard let context = UIGraphicsGetCurrentContext() else {
5915:             return SKTexture()
5916:         }
5917:         gradientLayer.render(in: context)
5918:         let image = UIGraphicsGetImageFromCurrentImageContext() ?? UIImage()
5919:         UIGraphicsEndImageContext()
5920:         return SKTexture(image: image)
5921:     }
5922: }
5923: #if DEBUG
5924: import SwiftUI
5925: import SpriteKit
5926: struct BackgroundPatternNodePreview: UIViewRepresentable {
5927:     let sceneSize: CGSize
5928:     func makeUIView(context: Context) -> SKView {
5929:         // Se crea una SKView con el tamaño de la preview
5930:         let skView = SKView(frame: CGRect(origin: .zero, size: sceneSize))
5931:         // Se configura la escena para que se redimensione automáticamente
5932:         let scene = SKScene(size: sceneSize)
5933:         scene.scaleMode = .resizeFill
5934:         scene.backgroundColor = .white
5935:         // Se crea y posiciona el BackgroundPatternNode
5936:         let patternNode = BackgroundPatternNode(size: sceneSize)
5937:         patternNode.position = CGPoint(x: sceneSize.width / 2, y: sceneSize.height / 2)
5938:         scene.addChild(patternNode)
5939:         skView.presentScene(scene)
5940:         return skView
5941:     }
5942:     func updateUIView(_ uiView: SKView, context: Context) {
5943:         // Se actualiza el tamaño de la escena para ocupar todo el espacio de la SKView
5944:         if let scene = uiView.scene {
5945:             scene.size = uiView.bounds.size
5946:         }
5947:     }
5948: }
5949: struct BackgroundPatternNode_Previews: PreviewProvider {
5950:     static var previews: some View {
5951:         GeometryReader { geometry in
5952:             BackgroundPatternNodePreview(sceneSize: geometry.size)
5953:         }
5954:         .ignoresSafeArea()
5955:         .previewDevice("iPhone 16 Pro")
5956:     }
5957: }
5958: #endif
5959: </file>
5960: <file path="MusicBlocks/game_levels.json">
5961: {
5962:     /*
5963:     Configuración principal del juego MusicBlocks
5964:     Última actualización: 29-02-2025
5965:     */
5966:     "game_version": "0.7",
5967:     /*
5968:     Tipos de objetivos soportados:
5969:     score: Alcanzar una puntuación específica en un tiempo límite
5970:     total_notes: Acertar un número de notas específico
5971:     note_accuracy: Acertar un número determinado de notas con cierta precisión de afinación
5972:     block_destruction: Destruir un número específico de bloques de ciertos tipos
5973:     total_blocks: Destruir un número total de bloques sin importar el tipo
5974:     */
5975:     "objective_types": {
5976:         // El tipo de objetivo score, total_notes, note_accuracy, block_destruction, total_blocks
5977:         "score": {
5978:             "type": "score",
5979:             "description": "Alcanzar una puntuación específica en un tiempo límite",
5980:             "params": {
5981:                 "target": 100, // La puntuación a alcanzar
5982:                 "time_limit": 180 // Límite de tiempo (0 para sin límite)
5983:             }
5984:         },
5985:         "total_notes": {
5986:             "type": "total_notes",
5987:             "description": "Acertar un número de notas específico",
5988:             "params": {
5989:                 "target": 50, // El número de notas a acertar
5990:                 "time_limit": 90 // Límite de tiempo (0 para sin límite)
5991:             }
5992:         },
5993:         "note_accuracy": {
5994:             "type": "note_accuracy",
5995:             "description": "Acertar un número de notas con cierta precisión",
5996:             "params": {
5997:                 "target": 10, // El número de notas a acertar
5998:                 "minimum_accuracy": 0.8, // Precisión mínima requerida
5999:                 "time_limit": 90 // Límite de tiempo (0 para sin límite)
6000:             }
6001:         },
6002:         "block_destruction": {
6003:             "type": "block_destruction",
6004:             "description": "Destruir bloques específicos",
6005:             "params": {
6006:                 "details": {
6007:                     "ghostBlock": 2, // El tipo de bloque y el número de bloques a acertar
6008:                     "hardIceBlock": 3,
6009:                     "defaultBlock": 6
6010:                 },
6011:                 "time_limit": 90, // Límite de tiempo (0 para sin límite)
6012:             }
6013:         },
6014:         "total_blocks": {
6015:             "type": "total_blocks",
6016:             "description": "Destruir un número total de bloques",
6017:             "params": {
6018:                 "target": 15, // El número de bloques a destruir
6019:                 "time_limit": 240 // Límite de tiempo (0 para sin límite)
6020:             }
6021:         }
6022:     },
6023:     "accuracy_thresholds": {
6024:         "perfect": {
6025:             "threshold": 0.95,
6026:             "multiplier": 2.0
6027:         },
6028:         "excellent": {
6029:             "threshold": 0.80,
6030:             "multiplier": 1.5
6031:         },
6032:         "good": {
6033:             "threshold": 0.60,
6034:             "multiplier": 1.0
6035:         }
6036:     },
6037:     "levels": [
6038:         {
6039:             "level_id": 0,
6040:             "name": "Tutorial",
6041:             "max_score": 500,
6042:             "allowed_styles": ["defaultBlock"], // Estilos de bloque en el nivel
6043:             "falling_speed": {
6044:                 "initial": 8.0,  // Velocidad de caida inicial 8.0 segundos
6045:                 "increment": 0.0 // Incremento de velocidad de caida. Quitar 0.0 segundos en cada bloque
6046:             },
6047:             "lives": {
6048:                 "initial": 3,  // Número de vidas al inicio del nivel
6049:                 "extra_lives": {
6050:                     "score_thresholds": [500, 1000],  // Puntuaciones necesarias para ganar vidas extra
6051:                     "max_extra": 1  // Máximo de vidas extra en el nivel
6052:                 }
6053:             },
6054:             "objectives": {
6055:                 "primary": {
6056:                     "type": "score",
6057:                     "target": 100,
6058:                     "time_limit": 180
6059:                 }
6060:             },
6061:             "blocks": {
6062:                 "defaultBlock": {
6063:                     "notes": [      // Notas disponibles del bloque
6064:                         "SOL4",
6065:                         "LA4",
6066:                         "SI4"
6067:                     ],
6068:                     "requiredHits": 1, // Aciertos necesarios para destruir bloque
6069:                     "requiredTime": 0.8, // Tiempo necesarios aguantando la nota para destruir bloque
6070:                     "style": "default",  // Nombre del estilo del bloque
6071:                     "weight": 1, // Peso para probabilidad en generarse el bloque
6072:                     "base_points": 5  // Puntos base al destruirlo
6073:                 }
6074:             }
6075:         },
6076:         {
6077:             "level_id": 1,
6078:             "name": "¡Comienza la aventura!",
6079:             "max_score": 600,
6080:             "allowed_styles": ["defaultBlock", "iceBlock"],
6081:             "falling_speed": {
6082:                 "initial": 7.0,  // Velocidad de caida inicial
6083:                 "increment": 0.1 // Incremento de velocidad de caida
6084:             },
6085:             "lives": {
6086:                 "initial": 3,  // Número de vidas al inicio del nivel
6087:                 "extra_lives": {
6088:                     "score_thresholds": [500, 1000],  // Puntuaciones necesarias para ganar vidas extra
6089:                     "max_extra": 2  // Máximo de vidas extra en el nivel
6090:                 }
6091:             },
6092:             "objectives": {
6093:                 "primary": {
6094:                     "type": "note_accuracy",
6095:                     "target": 10,  // número de notas a acertar
6096:                     "minimum_accuracy": 0.8,  // 80% de precisión mínima
6097:                     "time_limit": 0  // 0 significa sin límite de tiempo
6098:                 }
6099:             },
6100:             "blocks": {
6101:                 "defaultBlock": {
6102:                     "notes": [
6103:                         "SOL4",
6104:                         "LA4",
6105:                         "SI4"
6106:                     ],
6107:                     "requiredHits": 1,
6108:                     "requiredTime": 0.8,
6109:                     "style": "defaultBlock",
6110:                     "weight": 0.8,
6111:                     "base_points": 5
6112:                 },
6113:                 "iceBlock": {
6114:                     "notes": [
6115:                         "FA#4",
6116:                         "DO5"
6117:                     ],
6118:                     "requiredHits": 2,
6119:                     "requiredTime": 1.2,
6120:                     "style": "iceBlock",
6121:                     "weight": 0.2,
6122:                     "base_points": 10
6123:                 }
6124:             }
6125:         },
6126:         {
6127:             "level_id": 2,
6128:             "name": "Más bloques...!",
6129:             "max_score": 700,
6130:             "allowed_styles": ["defaultBlock", "hardIceBlock", "ghostBlock"],
6131:             "falling_speed": {
6132:                 "initial": 6.0,  // Velocidad de caida inicial
6133:                 "increment": 0.2 // Incremento de velocidad de caida
6134:             },
6135:             "lives": {
6136:                 "initial": 3,  // Número de vidas al inicio del nivel
6137:                 "extra_lives": {
6138:                     "score_thresholds": [500, 1000],  // Puntuaciones necesarias para ganar vidas extra
6139:                     "max_extra": 2  // Máximo de vidas extra en el nivel
6140:                 }
6141:             },
6142:             "objectives": {
6143:                 "primary": { // El objetivo principal que debe cumplirse para completar el nivel
6144:                     "type": "total_blocks",
6145:                     "target": 15,  // destruir 15 bloques en total
6146:                     "time_limit": 240
6147:                 }
6148:             },
6149:             "blocks": {
6150:                 "defaultBlock": {
6151:                     "notes": [
6152:                         "SOL4",
6153:                         "LA4",
6154:                         "SI4"
6155:                     ],
6156:                     "requiredHits": 1,
6157:                     "requiredTime": 0.8,
6158:                     "style": "defaultBlock",
6159:                     "weight": 0.4,
6160:                     "base_points": 10
6161:                 },
6162:                 "hardIceBlock": {
6163:                     "notes": [
6164:                         "DO6",
6165:                         "LA5",
6166:                         "SI5"
6167:                     ],
6168:                     "requiredHits": 3,
6169:                     "requiredTime": 1.6,
6170:                     "style": "hardIceBlock",
6171:                     "weight": 0.3,
6172:                     "base_points": 20
6173:                 },
6174:                 "ghostBlock": {
6175:                     "notes": [
6176:                         "SOL5",
6177:                         "FA5",
6178:                         "MI4"
6179:                     ],
6180:                     "requiredHits": 1,
6181:                     "requiredTime": 1,
6182:                     "style": "ghostBlock",
6183:                     "weight": 0.3,
6184:                     "base_points": 25
6185:                 }
6186:             }
6187:         }
6188:     ],
6189:     "medals": {
6190:         "notes_hit": [
6191:             {
6192:                 "name": "Aprendiz del Pentagrama",
6193:                 "requirement": "50 notas acertadas",
6194:                 "image": "Badge-azul-1",
6195:                 "objective": {
6196:                     "type": "notes_hit",
6197:                     "target": 50,
6198:                     "lifetime": true
6199:                 }
6200:             },
6201:             {
6202:                 "name": "Intérprete Prometedor",
6203:                 "requirement": "250 notas acertadas",
6204:                 "image": "Badge-azul-2",
6205:                 "objective": {
6206:                     "type": "notes_hit",
6207:                     "target": 250,
6208:                     "lifetime": true
6209:                 }
6210:             },
6211:             {
6212:                 "name": "Virtuoso del Ritmo",
6213:                 "requirement": "500 notas acertadas",
6214:                 "image": "Badge-azul-3",
6215:                 "objective": {
6216:                     "type": "notes_hit",
6217:                     "target": 500,
6218:                     "lifetime": true
6219:                 }
6220:             },
6221:             {
6222:                 "name": "Maestro Melódico",
6223:                 "requirement": "1000 notas acertadas",
6224:                 "image": "Badge-azul-4",
6225:                 "objective": {
6226:                     "type": "notes_hit",
6227:                     "target": 1000,
6228:                     "lifetime": true
6229:                 }
6230:             },
6231:             {
6232:                 "name": "Leyenda Musical",
6233:                 "requirement": "5000 notas acertadas",
6234:                 "image": "Badge-azul-5",
6235:                 "objective": {
6236:                     "type": "notes_hit",
6237:                     "target": 5000,
6238:                     "lifetime": true
6239:                 }
6240:             }
6241:         ],
6242:         "play_time": [
6243:             {
6244:                 "name": "Toca y Aprende",
6245:                 "requirement": "30 minutos jugados",
6246:                 "image": "Badge-rojo-1",
6247:                 "objective": {
6248:                     "type": "play_time",
6249:                     "target": 1800,  // 30 minutos en segundos
6250:                     "lifetime": true
6251:                 }
6252:             },
6253:             {
6254:                 "name": "Sesión de Ensayo",
6255:                 "requirement": "2 horas jugadas",
6256:                 "image": "Badge-rojo-2",
6257:                 "objective": {
6258:                     "type": "play_time",
6259:                     "target": 7200,  // 2 horas en segundos
6260:                     "lifetime": true
6261:                 }
6262:             },
6263:             {
6264:                 "name": "Músico Apasionado",
6265:                 "requirement": "10 horas jugadas",
6266:                 "image": "Badge-rojo-3",
6267:                 "objective": {
6268:                     "type": "play_time",
6269:                     "target": 36000,  // 10 horas en segundos
6270:                     "lifetime": true
6271:                 }
6272:             },
6273:             {
6274:                 "name": "Compositor Dedicado",
6275:                 "requirement": "25 horas jugadas",
6276:                 "image": "Badge-rojo-4",
6277:                 "objective": {
6278:                     "type": "play_time",
6279:                     "target": 90000,  // 25 horas en segundos
6280:                     "lifetime": true
6281:                 }
6282:             },
6283:             {
6284:                 "name": "Eterno Virtuoso",
6285:                 "requirement": "50 horas jugadas",
6286:                 "image": "Badge-rojo-5",
6287:                 "objective": {
6288:                     "type": "play_time",
6289:                     "target": 180000,  // 50 horas en segundos
6290:                     "lifetime": true
6291:                 }
6292:             }
6293:         ],
6294:         "streaks": [
6295:             {
6296:                 "name": "Afinado",
6297:                 "requirement": "10 notas seguidas sin errores",
6298:                 "image": "Badge-oro-1",
6299:                 "objective": {
6300:                     "type": "streak",
6301:                     "target": 10,
6302:                     "reset_on_fail": true
6303:                 }
6304:             },
6305:             {
6306:                 "name": "Cuerda Perfecta",
6307:                 "requirement": "50 notas seguidas sin errores",
6308:                 "image": "Badge-oro-2",
6309:                 "objective": {
6310:                     "type": "streak",
6311:                     "target": 50,
6312:                     "reset_on_fail": true
6313:                 }
6314:             },
6315:             {
6316:                 "name": "Ejecutante de Concierto",
6317:                 "requirement": "100 notas seguidas sin errores",
6318:                 "image": "Badge-oro-3",
6319:                 "objective": {
6320:                     "type": "streak",
6321:                     "target": 100,
6322:                     "reset_on_fail": true
6323:                 }
6324:             },
6325:             {
6326:                 "name": "Prodigio Preciso",
6327:                 "requirement": "250 notas seguidas sin errores",
6328:                 "image": "Badge-oro-4",
6329:                 "objective": {
6330:                     "type": "streak",
6331:                     "target": 250,
6332:                     "reset_on_fail": true
6333:                 }
6334:             },
6335:             {
6336:                 "name": "Músico Impecable",
6337:                 "requirement": "500 notas seguidas sin errores",
6338:                 "image": "Badge-oro-5",
6339:                 "objective": {
6340:                     "type": "streak",
6341:                     "target": 500,
6342:                     "reset_on_fail": true
6343:                 }
6344:             }
6345:         ],
6346:         "perfect_tuning": [
6347:             {
6348:                 "name": "Afinación Perfecta",
6349:                 "requirement": "Completa un nivel con 100% de precisión",
6350:                 "image": "Badge-multi-1",
6351:                 "objective": {
6352:                     "type": "perfect_tuning",
6353:                     "target": 1,
6354:                     "accuracy": 1.0,
6355:                     "lifetime": true
6356:                 }
6357:             },
6358:             {
6359:                 "name": "Maestro de la Afinación",
6360:                 "requirement": "Completa 5 niveles con 100% de precisión",
6361:                 "image": "Badge-multi-2",
6362:                 "objective": {
6363:                     "type": "perfect_tuning",
6364:                     "target": 5,
6365:                     "accuracy": 1.0,
6366:                     "lifetime": true
6367:                 }
6368:             },
6369:             {
6370:                 "name": "Ejecutor Infalible",
6371:                 "requirement": "Completa 10 niveles con 100% de precisión",
6372:                 "image": "Badge-multi-3",
6373:                 "objective": {
6374:                     "type": "perfect_tuning",
6375:                     "target": 10,
6376:                     "accuracy": 1.0,
6377:                     "lifetime": true
6378:                 }
6379:             },
6380:             {
6381:                 "name": "Perfección Sonora",
6382:                 "requirement": "Completa 25 niveles con 100% de precisión",
6383:                 "image": "Badge-multi-4",
6384:                 "objective": {
6385:                     "type": "perfect_tuning",
6386:                     "target": 25,
6387:                     "accuracy": 1.0,
6388:                     "lifetime": true
6389:                 }
6390:             },
6391:             {
6392:                 "name": "Leyenda de la Precisión",
6393:                 "requirement": "Completa 50 niveles con 100% de precisión",
6394:                 "image": "Badge-multi-5",
6395:                 "objective": {
6396:                     "type": "perfect_tuning",
6397:                     "target": 50,
6398:                     "accuracy": 1.0,
6399:                     "lifetime": true
6400:                 }
6401:             }
6402:         ]
6403:     }
6404: }
6405: </file>
6406: <file path="MusicBlocks/GameEngine.swift">
6407: //
6408: //  GameEngine.swift
6409: //  MusicBlocks
6410: //
6411: //  Created by Jose R. García on 13/3/25.
6412: //
6413: import Foundation
6414: import SpriteKit
6415: class GameEngine: ObservableObject {
6416:     // MARK: - Published Properties
6417:     @Published var score: Int = 0
6418:     @Published var lives: Int = 0
6419:     @Published var gameState: GameState = .countdown
6420:     @Published var noteState: NoteState = .waiting
6421:     @Published var combo: Int = 0
6422:     // MARK: - Private Properties
6423:     private let tunerEngine: TunerEngine
6424:     private let gameManager = GameManager.shared
6425:     private weak var blockManager: BlocksManager?
6426:     var objectiveTracker: LevelObjectiveTracker?
6427:     // Configuración del nivel
6428:     private var maxExtraLives: Int = 0
6429:     private var scoreThresholdsForExtraLives: [Int] = []
6430:     // Constantes de tiempo
6431:     private struct TimeConstants {
6432:         static let errorDisplayTime: TimeInterval = 2.0
6433:         static let silenceThreshold: TimeInterval = 0.3
6434:         static let minimalNoteDetectionTime: TimeInterval = 0.5
6435:         static let acceptableDeviation: Double = 10.0
6436:     }
6437:     // Estado del juego
6438:     private var isShowingError: Bool = false
6439:     private var isInSuccessState: Bool = false
6440:     // Métricas de partidas
6441:     private var gamesWon: Int = 0
6442:     private var gamesLost: Int = 0
6443:     // Métricas de la partida actual
6444:     private var gameStartTime: Date?
6445:     private var notesHitInGame: Int = 0
6446:     private var bestStreakInGame: Int = 0
6447:     private var totalAccuracyInGame: Double = 0.0
6448:     private var accuracyMeasurements: Int = 0
6449:     // Seguimiento de bloques por estilo en el nivel actual
6450:     private var blockHitsByStyle: [String: Int] = [:]
6451:     // MARK: - Initialization
6452:     /// Inicializa el GameEngine con el TunerEngine y el BlocksManager (que puede ser nil)
6453:     init(tunerEngine: TunerEngine = .shared, blockManager: BlocksManager?) {
6454:         self.tunerEngine = tunerEngine
6455:         self.blockManager = blockManager
6456:         gameState = .countdown
6457:         print("GameEngine inicializado. Estado inicial: \(gameState)")
6458:     }
6459:     // MARK: - Game Control
6460:     /// Inicia una nueva partida, reseteando todas las métricas y configurando el nivel actual.
6461:     func startNewGame() {
6462:         guard let currentLevel = gameManager.currentLevel else {
6463:             print("No se pudo iniciar el juego: no hay nivel actual")
6464:             return
6465:         }
6466:         print("Iniciando nueva partida para el nivel \(currentLevel.levelId)")
6467:         resetGameState()
6468:         // Reiniciar contadores por estilo de bloque
6469:         blockHitsByStyle.removeAll()
6470:         for style in currentLevel.allowedStyles {
6471:             blockHitsByStyle[style] = 0
6472:         }
6473:         // Inicializar métricas de partida
6474:         gameStartTime = Date()
6475:         notesHitInGame = 0
6476:         bestStreakInGame = 0
6477:         totalAccuracyInGame = 0.0
6478:         accuracyMeasurements = 0
6479:         // Crear tracker para objetivos
6480:         objectiveTracker = LevelObjectiveTracker(level: currentLevel)
6481:         // Configurar vidas y puntuación
6482:             lives = currentLevel.lives.initial
6483:             maxExtraLives = currentLevel.lives.extraLives.maxExtra
6484:             scoreThresholdsForExtraLives = currentLevel.lives.extraLives.scoreThresholds
6485:             // Añadir notificación para actualizar la UI con los valores iniciales
6486:             NotificationCenter.default.post(
6487:                 name: NSNotification.Name("GameDataUpdated"),
6488:                 object: nil,
6489:                 userInfo: [
6490:                     "score": score,
6491:                     "lives": lives,
6492:                     "resetObjectives": true // Flag para indicar reinicio completo
6493:                 ]
6494:             )
6495:         // Iniciar generación de bloques
6496:         blockManager?.startBlockGeneration()
6497:         // Cambiar estado del juego a 'playing'
6498:         gameState = .playing
6499:         print("🎮 Nuevo juego iniciado - Nivel: \(currentLevel.levelId)")
6500:     }
6501:     /// Pausa la partida actual.
6502:     func pauseGame() {
6503:         guard case .playing = gameState else { return }
6504:         gameState = .paused
6505:         blockManager?.stopBlockGeneration()
6506:         print("Juego pausado")
6507:     }
6508:     /// Reanuda la partida pausada.
6509:     func resumeGame() {
6510:         guard case .paused = gameState else { return }
6511:         gameState = .playing
6512:         blockManager?.startBlockGeneration()
6513:         print("Juego reanudado")
6514:     }
6515:     /// Finaliza la partida, calcula estadísticas y actualiza el perfil del usuario.
6516:     func endGame(reason: GameOverReason) {
6517:         gameState = .gameOver(reason: reason)
6518:         blockManager?.stopBlockGeneration()
6519:         // Actualización final de la UI antes de terminar
6520:            NotificationCenter.default.post(
6521:                name: NSNotification.Name("GameDataUpdated"),
6522:                object: nil,
6523:                userInfo: [
6524:                    "score": score,
6525:                    "lives": lives,
6526:                    "gameOver": true,
6527:                    "reason": reason.rawValue
6528:                ]
6529:            )
6530:         let playTime = gameStartTime.map { Date().timeIntervalSince($0) } ?? 0
6531:         let averageAccuracy = accuracyMeasurements > 0 ? totalAccuracyInGame / Double(accuracyMeasurements) : 0.0
6532:         let requiredScore = gameManager.currentLevel?.requiredScore ?? 0
6533:         let isGameWon = reason != .blocksOverflow && score >= requiredScore
6534:         if isGameWon {
6535:             gamesWon += 1
6536:         } else {
6537:             gamesLost += 1
6538:         }
6539:         let userProfile = UserProfile.load()
6540:         var updatedProfile = userProfile
6541:         updatedProfile.updateStatistics(
6542:             score: score,
6543:             noteHit: false,
6544:             accuracy: averageAccuracy,
6545:             levelCompleted: isGameWon,
6546:             isPerfect: averageAccuracy >= 0.95,
6547:             playTime: playTime,
6548:             gamesWon: gamesWon,
6549:             gamesLost: gamesLost
6550:         )
6551:         print("📊 Estadísticas finales:")
6552:         print("Tiempo jugado: \(Int(playTime))s, Notas acertadas: \(notesHitInGame), Mejor racha: \(bestStreakInGame), Precisión: \(Int(averageAccuracy * 100))%")
6553:         print("Estado: \(isGameWon ? "Victoria" : "Derrota")")
6554:         print("Total partidas - Ganadas: \(gamesWon), Perdidas: \(gamesLost)")
6555:         let totalBlocksAcertados = blockHitsByStyle.values.reduce(0, +)
6556:         print("Bloques acertados: \(totalBlocksAcertados)")
6557:         for (style, count) in blockHitsByStyle {
6558:             print("• \(style): \(count)")
6559:         }
6560:         resetGameState()
6561:     }
6562:     // MARK: - Note Processing
6563:     /// Compara la nota detectada con el objetivo y delega el manejo correcto o incorrecto.
6564:     func checkNote(currentNote: String, deviation: Double, isActive: Bool) {
6565:         guard case .playing = gameState, !isInSuccessState, !isShowingError else {
6566:             return
6567:         }
6568:         guard let currentBlock = blockManager?.getCurrentBlock(), isActive else {
6569:             print("No se procesará nota: no hay bloque activo o no está activa")
6570:             return
6571:         }
6572:         print("🎯 Comparando nota detectada (\(currentNote)) con objetivo (\(currentBlock.note)), desviación: \(deviation)")
6573:         if currentNote == currentBlock.note {
6574:             handleCorrectNote(deviation: deviation, block: currentBlock)
6575:         } else {
6576:             handleWrongNote()
6577:         }
6578:     }
6579:     // MARK: - Note Handling
6580:     /// Maneja la nota correcta: actualiza el progreso del bloque y, si se cumplen los requisitos, registra el éxito.
6581:     private func handleCorrectNote(deviation: Double, block: BlockInfo) {
6582:         if blockManager?.updateCurrentBlockProgress(hitTime: Date()) == true {
6583:             handleSuccess(deviation: deviation, blockConfig: block.config)
6584:         } else {
6585:             noteState = .correct(deviation: deviation)
6586:         }
6587:         combo += 1
6588:     }
6589:     /// Maneja el caso de nota incorrecta: reduce vidas y reinicia el progreso del bloque.
6590:     private func handleWrongNote() {
6591:         guard !isShowingError else { return }
6592:         isShowingError = true
6593:         lives -= 1
6594:         combo = 0
6595:         noteState = .wrong
6596:         blockManager?.resetCurrentBlockProgress()
6597:         // Añadir notificación para actualizar la UI inmediatamente
6598:         NotificationCenter.default.post(
6599:             name: NSNotification.Name("GameDataUpdated"),
6600:             object: nil,
6601:             userInfo: ["lives": lives, "combo": combo]
6602:         )
6603:         if lives <= 0 {
6604:             endGame(reason: .noLives)
6605:             return
6606:         }
6607:         DispatchQueue.main.asyncAfter(deadline: .now() + TimeConstants.errorDisplayTime) { [weak self] in
6608:             self?.isShowingError = false
6609:             self?.noteState = .waiting
6610:         }
6611:     }
6612:     /// Maneja el éxito al completar el bloque: actualiza estadísticas, suma puntos y verifica objetivos.
6613:     private func handleSuccess(deviation: Double, blockConfig: Block) {
6614:         isInSuccessState = true
6615:         if let currentBlock = blockManager?.getCurrentBlock() {
6616:             blockHitsByStyle[currentBlock.style] = (blockHitsByStyle[currentBlock.style] ?? 0) + 1
6617:             print("📊 Bloques acertados actualizados:")
6618:             for (style, count) in blockHitsByStyle {
6619:                 print("• \(style): \(count)")
6620:             }
6621:         }
6622:         let accuracy = calculateAccuracy(deviation: deviation)
6623:         let (baseScore, message) = calculateScore(accuracy: accuracy, blockConfig: blockConfig)
6624:         let comboBonus = calculateComboBonus(baseScore: baseScore)
6625:         let finalScore = baseScore + comboBonus
6626:         score += finalScore
6627:         checkForExtraLife(currentScore: score)
6628:         // Obtener el estilo del bloque actual
6629:         let blockStyle = blockManager?.getCurrentBlock()?.style ?? "defaultBlock"
6630:         // Actualizar TODOS los datos relevantes para CUALQUIER tipo de objetivo
6631:             objectiveTracker?.updateProgress(
6632:                 score: score,             // Para objetivos tipo "score"
6633:                 noteHit: true,            // Para objetivos tipo "total_notes"
6634:                 accuracy: accuracy,       // Para objetivos tipo "note_accuracy"
6635:                 blockDestroyed: blockStyle // Para objetivos tipo "block_destruction" y "total_blocks"
6636:             )
6637:             // Enviar notificación con TODOS los datos relevantes
6638:         // Enviar notificación después de actualizar el tracker
6639:         NotificationCenter.default.post(
6640:             name: NSNotification.Name("GameDataUpdated"),
6641:             object: nil,
6642:             userInfo: [
6643:                 "lives": lives,
6644:                 "combo": combo,
6645:                 "noteState": "wrong"
6646:             ]
6647:         )
6648:         if let primaryComplete = objectiveTracker?.checkObjectives(), primaryComplete {
6649:             endGame(reason: .victory)
6650:         }
6651:         noteState = .success(
6652:             multiplier: finalScore / blockConfig.basePoints,
6653:             message: "\(message) (\(combo)x Combo!)"
6654:         )
6655:         DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
6656:             self?.isInSuccessState = false
6657:             self?.noteState = .waiting
6658:         }
6659:     }
6660:     // MARK: - Score Calculation
6661:     /// Calcula la precisión a partir de la desviación.
6662:     private func calculateAccuracy(deviation: Double) -> Double {
6663:         let absDeviation = abs(deviation)
6664:         if absDeviation > TimeConstants.acceptableDeviation { return 0.0 }
6665:         return 1.0 - (absDeviation / TimeConstants.acceptableDeviation)
6666:     }
6667:     /// Calcula la puntuación base y un mensaje en función de la precisión.
6668:     private func calculateScore(accuracy: Double, blockConfig: Block) -> (score: Int, message: String) {
6669:         guard let thresholds = gameManager.gameConfig?.accuracyThresholds else {
6670:             return (blockConfig.basePoints, "¡Bien!")
6671:         }
6672:         if accuracy >= thresholds.perfect.threshold {
6673:             return (Int(Double(blockConfig.basePoints) * thresholds.perfect.multiplier), "¡Perfecto!")
6674:         } else if accuracy >= thresholds.excellent.threshold {
6675:             return (Int(Double(blockConfig.basePoints) * thresholds.excellent.multiplier), "¡Excelente!")
6676:         } else if accuracy >= thresholds.good.threshold {
6677:             return (Int(Double(blockConfig.basePoints) * thresholds.good.multiplier), "¡Bien!")
6678:         }
6679:         return (0, "Fallo")
6680:     }
6681:     /// Calcula el bono por combo.
6682:     private func calculateComboBonus(baseScore: Int) -> Int {
6683:         let comboMultiplier = min(combo, 10)
6684:         return baseScore * (comboMultiplier - 1) / 2
6685:     }
6686:     // MARK: - Lives Management
6687:     /// Verifica y concede vidas extra si se alcanza el umbral de puntuación.
6688:     private func checkForExtraLife(currentScore: Int) {
6689:         for threshold in scoreThresholdsForExtraLives {
6690:             if currentScore >= threshold && lives < (gameManager.currentLevel?.lives.initial ?? 3) + maxExtraLives {
6691:                 lives += 1
6692:                 print("🎉 Vida extra ganada. Vidas actuales: \(lives)")
6693:                 // Añadir notificación para actualizar la UI inmediatamente
6694:                 NotificationCenter.default.post(
6695:                     name: NSNotification.Name("GameDataUpdated"),
6696:                     object: nil,
6697:                     userInfo: ["lives": lives]
6698:                 )
6699:                 if let index = scoreThresholdsForExtraLives.firstIndex(of: threshold) {
6700:                     scoreThresholdsForExtraLives.remove(at: index)
6701:                 }
6702:                 break
6703:             }
6704:         }
6705:     }
6706:     // MARK: - State Management
6707:     /// Resetea todas las métricas y estados de la partida.
6708:     private func resetGameState() {
6709:         score = 0
6710:         combo = 0
6711:         isShowingError = false
6712:         isInSuccessState = false
6713:         noteState = .waiting
6714:         gameStartTime = nil
6715:         notesHitInGame = 0
6716:         bestStreakInGame = 0
6717:         totalAccuracyInGame = 0.0
6718:         accuracyMeasurements = 0
6719:         blockHitsByStyle.removeAll()
6720:         print("🔄 Estado del juego reseteado.")
6721:     }
6722:     // MARK: - Block Monitoring
6723:     /// Comprueba si algún bloque ha alcanzado la zona límite (danger zone).
6724:     func checkBlocksPosition() {
6725:         if blockManager?.hasBlocksBelowLimit() == true {
6726:             print("🔥 Game Over: Bloques han alcanzado la zona de peligro.")
6727:             endGame(reason: .blocksOverflow)
6728:         }
6729:     }
6730:     /// Retorna el progreso del objetivo actual.
6731:     func getLevelProgress() -> Double {
6732:         return objectiveTracker?.getProgress() ?? 0
6733:     }
6734:     /// Devuelve el resumen de bloques acertados por estilo.
6735:     func getBlockHitsByStyle() -> [String: Int] {
6736:         return blockHitsByStyle
6737:     }
6738: }
6739: // MARK: - AudioControllerDelegate
6740: extension GameEngine: AudioControllerDelegate {
6741:     /// Recibe la nota detectada y la procesa.
6742:     func audioController(_ controller: AudioController, didDetectNote note: String, frequency: Float, amplitude: Float, deviation: Double) {
6743:         print("AudioControllerDelegate - Nota detectada: \(note), Frecuencia: \(frequency)")
6744:         self.checkNote(currentNote: note, deviation: deviation, isActive: true)
6745:     }
6746:     /// Se invoca cuando se detecta silencio.
6747:     func audioControllerDidDetectSilence(_ controller: AudioController) {
6748:         print("AudioControllerDelegate - Silencio detectado.")
6749:         self.checkNote(currentNote: "-", deviation: 0, isActive: false)
6750:     }
6751:     /// Devuelve el tiempo requerido para mantener la nota, consultando el bloque actual.
6752:     func audioControllerRequiredHoldTime(_ controller: AudioController) -> TimeInterval {
6753:         if let currentBlock = blockManager?.getCurrentBlock() {
6754:             print("AudioControllerDelegate - Required hold time para el bloque actual: \(currentBlock.config.requiredTime) segundos")
6755:             return currentBlock.config.requiredTime
6756:         }
6757:         print("AudioControllerDelegate - No hay bloque activo, se retorna 1.0 segundo por defecto")
6758:         return 1.0
6759:     }
6760: }
6761: </file>
6762: <file path="MusicBlocks/GameLevelProcessor.swift">
6763: //
6764: //  GameLevelProcessor.swift
6765: //  MusicBlocks
6766: //
6767: //  Created by Jose R. García on 28/2/25.
6768: //
6769: import Foundation
6770: // Estructuras para almacenar la configuración del juego
6771: struct GameConfig: Codable {
6772:     let gameVersion: String
6773:     let objectiveTypes: ObjectiveTypes
6774:     let accuracyThresholds: AccuracyThresholds
6775:     let levels: [GameLevel]
6776:     let medals: Medals
6777:     enum CodingKeys: String, CodingKey {
6778:         case gameVersion = "game_version"
6779:         case objectiveTypes = "objective_types"
6780:         case accuracyThresholds = "accuracy_thresholds"
6781:         case levels
6782:         case medals
6783:     }
6784: }
6785: struct ObjectiveTypes: Codable {
6786:     let score: ObjectiveTypeDefinition
6787:     let totalNotes: ObjectiveTypeDefinition
6788:     let noteAccuracy: ObjectiveTypeDefinition
6789:     let blockDestruction: ObjectiveTypeDefinition
6790:     let totalBlocks: ObjectiveTypeDefinition
6791:     enum CodingKeys: String, CodingKey {
6792:         case score
6793:         case totalNotes = "total_notes"
6794:         case noteAccuracy = "note_accuracy"
6795:         case blockDestruction = "block_destruction"
6796:         case totalBlocks = "total_blocks"
6797:     }
6798: }
6799: struct ObjectiveTypeDefinition: Codable {
6800:     let type: String?
6801:     let description: String
6802:     let params: ObjectiveParams
6803: }
6804: struct ObjectiveParams: Codable {
6805:     let target: Int?
6806:     let timeLimit: Int?
6807:     let minimumAccuracy: Double?
6808:     let details: [String: Int]?
6809:     enum CodingKeys: String, CodingKey {
6810:         case target
6811:         case timeLimit = "time_limit"
6812:         case minimumAccuracy = "minimum_accuracy"
6813:         case details
6814:     }
6815: }
6816: struct AccuracyThresholds: Codable {
6817:     let perfect: AccuracyLevel
6818:     let excellent: AccuracyLevel
6819:     let good: AccuracyLevel
6820: }
6821: struct AccuracyLevel: Codable {
6822:     let threshold: Double
6823:     let multiplier: Double
6824: }
6825: struct GameLevel: Codable {
6826:     let levelId: Int
6827:     let name: String
6828:     let maxScore: Int
6829:     let allowedStyles: [String]
6830:     let fallingSpeed: FallingSpeed
6831:     let lives: Lives
6832:     let objectives: Objectives
6833:     let blocks: [String: Block]
6834:     var requiredScore: Int {
6835:             // Si el objetivo primario es de tipo "score", usar ese valor
6836:             if objectives.primary.type == "score" {
6837:                 return objectives.primary.target ?? 0
6838:             }
6839:             // Si no, usar un valor por defecto basado en los bloques
6840:             return blocks.values.reduce(0) { $0 + ($1.basePoints * 10) }
6841:         }
6842:     enum CodingKeys: String, CodingKey {
6843:         case levelId = "level_id"
6844:         case name
6845:         case maxScore = "max_score"
6846:         case allowedStyles = "allowed_styles"
6847:         case fallingSpeed = "falling_speed"
6848:         case lives
6849:         case objectives
6850:         case blocks
6851:     }
6852: }
6853: struct FallingSpeed: Codable {
6854:     let initial: Double
6855:     let increment: Double
6856: }
6857: struct Lives: Codable {
6858:     let initial: Int
6859:     let extraLives: ExtraLives
6860:     enum CodingKeys: String, CodingKey {
6861:         case initial
6862:         case extraLives = "extra_lives"
6863:     }
6864: }
6865: struct ExtraLives: Codable {
6866:     let scoreThresholds: [Int]
6867:     let maxExtra: Int
6868:     enum CodingKeys: String, CodingKey {
6869:         case scoreThresholds = "score_thresholds"
6870:         case maxExtra = "max_extra"
6871:     }
6872: }
6873: struct Objectives: Codable {
6874:     let primary: Objective
6875: }
6876: struct Objective: Codable {
6877:     let type: String
6878:     let target: Int?
6879:     let timeLimit: Int?
6880:     let minimumAccuracy: Double?
6881:     let details: [String: Int]?
6882:     enum CodingKeys: String, CodingKey {
6883:         case type
6884:         case target
6885:         case timeLimit = "time_limit"
6886:         case minimumAccuracy = "minimum_accuracy"
6887:         case details
6888:     }
6889: }
6890: struct Block: Codable {
6891:     let notes: [String]
6892:     let requiredHits: Int
6893:     let requiredTime: Double
6894:     let style: String
6895:     let weight: Double
6896:     let basePoints: Int
6897:     enum CodingKeys: String, CodingKey {
6898:         case notes
6899:         case requiredHits
6900:         case requiredTime
6901:         case style
6902:         case weight
6903:         case basePoints = "base_points"
6904:     }
6905: }
6906: struct Medals: Codable {
6907:     let notesHit: [Medal]
6908:     let playTime: [Medal]
6909:     let streaks: [Medal]
6910:     let perfectTuning: [Medal]
6911:     enum CodingKeys: String, CodingKey {
6912:         case notesHit = "notes_hit"
6913:         case playTime = "play_time"
6914:         case streaks
6915:         case perfectTuning = "perfect_tuning"
6916:     }
6917: }
6918: struct Medal: Codable {
6919:     let name: String
6920:     let requirement: String
6921:     let image: String
6922:     let objective: MedalObjective
6923: }
6924: struct MedalObjective: Codable {
6925:     let type: String
6926:     let target: Int
6927:     let lifetime: Bool?
6928:     let resetOnFail: Bool?
6929:     let accuracy: Double?
6930:     enum CodingKeys: String, CodingKey {
6931:         case type
6932:         case target
6933:         case lifetime
6934:         case resetOnFail = "reset_on_fail"
6935:         case accuracy
6936:     }
6937: }
6938: class GameLevelProcessor {
6939:     /// Procesa el JSON que contiene comentarios y convierte los datos para su uso en la app
6940:     /// - Parameter jsonString: String con el JSON que puede contener comentarios
6941:     /// - Returns: Objeto GameConfig con la configuración del juego o nil si hay error
6942:     static func processGameLevelsJSON(_ jsonString: String) -> GameConfig? {
6943:         // Paso 1: Eliminar los comentarios multilinea /* ... */
6944:         var cleanedJSON = removeMultilineComments(from: jsonString)
6945:         // Paso 2: Eliminar los comentarios de una sola línea // ...
6946:         cleanedJSON = removeSingleLineComments(from: cleanedJSON)
6947:         // Paso 3: Parsear el JSON limpio
6948:         if let jsonData = cleanedJSON.data(using: .utf8) {
6949:             do {
6950:                 let decoder = JSONDecoder()
6951:                 let gameConfig = try decoder.decode(GameConfig.self, from: jsonData)
6952:                 return gameConfig
6953:             } catch {
6954:                 print("Error decoding JSON: \(error)")
6955:                 print("Problema en: \(error.localizedDescription)")
6956:                 if let decodingError = error as? DecodingError {
6957:                     switch decodingError {
6958:                     case .dataCorrupted(let context):
6959:                         print("Data corrupted: \(context)")
6960:                     case .keyNotFound(let key, let context):
6961:                         print("Key not found: \(key) in \(context)")
6962:                     case .typeMismatch(let type, let context):
6963:                         print("Type mismatch: \(type) in \(context)")
6964:                     case .valueNotFound(let type, let context):
6965:                         print("Value not found: \(type) in \(context)")
6966:                     @unknown default:
6967:                         print("Unknown decoding error")
6968:                     }
6969:                 }
6970:                 // Imprime el JSON limpio para facilitar la depuración
6971:                 print("JSON limpio que causó el error:")
6972:                 print(cleanedJSON)
6973:             }
6974:         }
6975:         return nil
6976:     }
6977:     /// Carga el archivo game_levels.json y procesa sus datos
6978:     /// - Returns: Objeto GameConfig con los datos del juego
6979:     static func loadGameLevelsFromFile() -> GameConfig? {
6980:         guard let path = Bundle.main.path(forResource: "game_levels", ofType: "json") else {
6981:             print("No se pudo encontrar el archivo game_levels.json")
6982:             return nil
6983:         }
6984:         do {
6985:             let jsonString = try String(contentsOfFile: path, encoding: .utf8)
6986:             return processGameLevelsJSON(jsonString)
6987:         } catch {
6988:             print("Error al leer el archivo game_levels.json: \(error)")
6989:             return nil
6990:         }
6991:     }
6992:     /// Guarda la configuración del juego en un archivo JSON
6993:     /// - Parameters:
6994:     ///   - gameConfig: Configuración del juego a guardar
6995:     ///   - fileName: Nombre del archivo sin extensión
6996:     /// - Returns: Verdadero si la operación fue exitosa, falso en caso contrario
6997:     static func saveGameConfigToFile(_ gameConfig: GameConfig, fileName: String = "game_levels") -> Bool {
6998:         do {
6999:             let encoder = JSONEncoder()
7000:             encoder.outputFormatting = .prettyPrinted
7001:             let jsonData = try encoder.encode(gameConfig)
7002:             if let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {
7003:                 let fileURL = documentsDirectory.appendingPathComponent("\(fileName).json")
7004:                 try jsonData.write(to: fileURL)
7005:                 return true
7006:             }
7007:         } catch {
7008:             print("Error al guardar la configuración: \(error)")
7009:         }
7010:         return false
7011:     }
7012:     // MARK: - Métodos privados para procesar el JSON
7013:     private static func removeMultilineComments(from input: String) -> String {
7014:         var result = ""
7015:         var inMultilineComment = false
7016:         var i = input.startIndex
7017:         while i < input.endIndex {
7018:             // Detectar inicio de comentario multilínea
7019:             if i < input.index(before: input.endIndex) &&
7020:                input[i] == "/" && input[input.index(after: i)] == "*" {
7021:                 inMultilineComment = true
7022:                 i = input.index(after: i)  // Saltar el "/"
7023:             }
7024:             // Detectar fin de comentario multilínea
7025:             else if inMultilineComment && i < input.index(before: input.endIndex) &&
7026:                     input[i] == "*" && input[input.index(after: i)] == "/" {
7027:                 inMultilineComment = false
7028:                 i = input.index(i, offsetBy: 2)  // Saltar "*/"
7029:                 continue
7030:             }
7031:             // Si no estamos en un comentario, añadir el caracter al resultado
7032:             if !inMultilineComment {
7033:                 result.append(input[i])
7034:             }
7035:             i = input.index(after: i)
7036:         }
7037:         return result
7038:     }
7039:     private static func removeSingleLineComments(from input: String) -> String {
7040:         var result = ""
7041:         var inString = false
7042:         var inSingleLineComment = false
7043:         var i = input.startIndex
7044:         while i < input.endIndex {
7045:             let currentChar = input[i]
7046:             // Manejar inicio/fin de cadenas de texto
7047:             if currentChar == "\"" {
7048:                 // Verificar que la comilla no esté escapada
7049:                 if i > input.startIndex && input[input.index(before: i)] != "\\" {
7050:                     inString = !inString
7051:                 }
7052:             }
7053:             // Detectar inicio de comentario de una línea (solo fuera de cadenas de texto)
7054:             if !inString && i < input.index(before: input.endIndex) &&
7055:                currentChar == "/" && input[input.index(after: i)] == "/" {
7056:                 inSingleLineComment = true
7057:             }
7058:             // Fin de línea termina un comentario de una línea
7059:             if inSingleLineComment && (currentChar == "\n" || currentChar == "\r") {
7060:                 inSingleLineComment = false
7061:                 // Preservamos los saltos de línea para mantener la estructura del documento
7062:                 result.append(currentChar)
7063:             }
7064:             // Si no estamos en un comentario, añadir el caracter al resultado
7065:             else if !inSingleLineComment {
7066:                 result.append(currentChar)
7067:             }
7068:             i = input.index(after: i)
7069:         }
7070:         return result
7071:     }
7072:     // MARK: - Métodos de acceso para usar los datos en la aplicación
7073:     /// Obtiene los niveles disponibles en el juego
7074:     /// - Parameter gameConfig: Configuración del juego
7075:     /// - Returns: Array de niveles
7076:     static func getLevels(from gameConfig: GameConfig) -> [GameLevel] {
7077:         return gameConfig.levels
7078:     }
7079:     /// Obtiene los tipos de objetivos disponibles en el juego
7080:     /// - Parameter gameConfig: Configuración del juego
7081:     /// - Returns: Tipos de objetivos
7082:     static func getObjectiveTypes(from gameConfig: GameConfig) -> ObjectiveTypes {
7083:         return gameConfig.objectiveTypes
7084:     }
7085:     /// Obtiene los umbrales de precisión para las calificaciones
7086:     /// - Parameter gameConfig: Configuración del juego
7087:     /// - Returns: Umbrales de precisión
7088:     static func getAccuracyThresholds(from gameConfig: GameConfig) -> AccuracyThresholds {
7089:         return gameConfig.accuracyThresholds
7090:     }
7091:     /// Obtiene las medallas disponibles en el juego
7092:     /// - Parameter gameConfig: Configuración del juego
7093:     /// - Returns: Configuración de medallas
7094:     static func getMedals(from gameConfig: GameConfig) -> Medals {
7095:         return gameConfig.medals
7096:     }
7097:     /// Obtiene un nivel específico por su ID
7098:     /// - Parameters:
7099:     ///   - gameConfig: Configuración del juego
7100:     ///   - id: ID del nivel
7101:     /// - Returns: El nivel solicitado o nil si no existe
7102:     static func getLevel(from gameConfig: GameConfig, withId id: Int) -> GameLevel? {
7103:         if let level = gameConfig.levels.first(where: { $0.levelId == id }) {
7104:             print("Nivel \(id) encontrado:")
7105:             print("- Estilos permitidos: \(level.allowedStyles)")
7106:             print("- Bloques configurados:")
7107:             for (style, block) in level.blocks {
7108:                 print("  • \(style):")
7109:                 print("    - Notas: \(block.notes)")
7110:                 print("    - Estilo: \(block.style)")
7111:                 print("    - Peso: \(block.weight)")
7112:             }
7113:             return level
7114:         }
7115:         return nil
7116:     }
7117:     /// Obtiene los bloques disponibles en un nivel específico
7118:     /// - Parameter level: Nivel del juego
7119:     /// - Returns: Diccionario con los bloques disponibles
7120:     static func getBlocks(from level: GameLevel) -> [String: Block] {
7121:         return level.blocks
7122:     }
7123:     /// Corrige una versión JSON existente para adaptarla a los cambios de estructura
7124:     /// - Parameter jsonString: Contenido del archivo JSON a corregir
7125:     /// - Returns: JSON corregido o nil si hay error
7126:     static func fixJSONStructure(_ jsonString: String) -> String? {
7127:         // Primero limpiamos los comentarios
7128:         var cleanedJSON = removeMultilineComments(from: jsonString)
7129:         cleanedJSON = removeSingleLineComments(from: cleanedJSON)
7130:         return cleanedJSON
7131:     }
7132: }
7133: </file>
7134: <file path="MusicBlocks/GameManager.swift">
7135: //
7136: //  GameManager.swift
7137: //  MusicBlocks
7138: //
7139: //  Created by Jose R. García on 7/3/25.
7140: //
7141: import Foundation
7142: class GameManager {
7143:     // MARK: - Singleton
7144:     static let shared = GameManager()
7145:     // MARK: - Properties
7146:     private(set) var gameConfig: GameConfig?
7147:     private(set) var currentLevel: GameLevel?
7148:     private var userProfile: UserProfile
7149:     // MARK: - Game Statistics
7150:     private(set) var totalGamesPlayed: Int = 0
7151:     private(set) var highScores: [Int: Int] = [:] // [levelId: highScore]
7152:     private(set) var lastPlayedLevel: Int = 0
7153:     // MARK: - Constants
7154:     private struct Constants {
7155:         static let maxUnlockedLevel = 10
7156:         static let tutorialLevelId = 0
7157:         static let defaultLives = 3
7158:     }
7159:     // MARK: - Initialization
7160:     private init() {
7161:         userProfile = UserProfile.load()
7162:         loadGameConfig()
7163:         loadStatistics()
7164:     }
7165:     // MARK: - Configuration Loading
7166:     private func loadGameConfig() {
7167:         if let config = GameLevelProcessor.loadGameLevelsFromFile() {
7168:             print("✅ Configuración del juego cargada")
7169:             print("📊 Número de niveles: \(config.levels.count)")
7170:             gameConfig = config
7171:         } else {
7172:             print("❌ Error al cargar la configuración del juego")
7173:         }
7174:     }
7175:     private func loadStatistics() {
7176:         totalGamesPlayed = userProfile.statistics.totalGamesPlayed
7177:         lastPlayedLevel = userProfile.statistics.currentLevel
7178:     }
7179:     // MARK: - Level Management
7180:     func loadLevel(_ levelId: Int) -> Bool {
7181:         guard let config = gameConfig else {
7182:             print("❌ Error: No se pudo cargar la configuración del juego")
7183:             return false
7184:         }
7185:         // Verificar si el nivel está desbloqueado
7186:         if !isLevelUnlocked(levelId) {
7187:             print("🔒 Nivel \(levelId) bloqueado")
7188:             return false
7189:         }
7190:         // Intentar cargar el nivel solicitado
7191:         if let level = GameLevelProcessor.getLevel(from: config, withId: levelId) {
7192:             currentLevel = level
7193:             lastPlayedLevel = levelId
7194:             userProfile.statistics.currentLevel = levelId
7195:             userProfile.save()
7196:             print("✅ Nivel \(levelId) cargado: \(level.name)")
7197:             return true
7198:         }
7199:         // Si falla, intentar cargar el tutorial
7200:         if let tutorialLevel = GameLevelProcessor.getLevel(from: config, withId: Constants.tutorialLevelId) {
7201:             currentLevel = tutorialLevel
7202:             print("ℹ️ Cargando tutorial por defecto")
7203:             return true
7204:         }
7205:         print("❌ Error: No se pudo cargar ningún nivel")
7206:         return false
7207:     }
7208:     func isLevelUnlocked(_ levelId: Int) -> Bool {
7209:         // El tutorial siempre está desbloqueado
7210:         if levelId == Constants.tutorialLevelId { return true }
7211:         // Verificar progreso del usuario
7212:         let previousLevelCompleted = highScores[levelId - 1] != nil
7213:         return levelId <= Constants.maxUnlockedLevel && previousLevelCompleted
7214:     }
7215:     // MARK: - Game Progress
7216:     func updateGameStatistics(levelId: Int, score: Int, completed: Bool) {
7217:         // Actualizar estadísticas locales
7218:         totalGamesPlayed += 1
7219:         // Actualizar high score si es necesario
7220:         if let currentHighScore = highScores[levelId] {
7221:             if score > currentHighScore {
7222:                 highScores[levelId] = score
7223:                 print("🏆 Nuevo récord en nivel \(levelId): \(score)")
7224:             }
7225:         } else {
7226:             highScores[levelId] = score
7227:             print("🎮 Primera puntuación en nivel \(levelId): \(score)")
7228:         }
7229:         // Actualizar perfil de usuario
7230:         userProfile.updateStatistics(
7231:             score: score,
7232:             accuracy: calculateAccuracyForLevel(score),
7233:             levelCompleted: completed,
7234:             isPerfect: isLevelPerfect(score),
7235:             playTime: calculatePlayTime()
7236:         )
7237:         // Si completó el nivel, actualizar progreso
7238:         if completed {
7239:             if levelId >= userProfile.statistics.currentLevel {
7240:                 userProfile.statistics.currentLevel = levelId + 1
7241:             }
7242:         }
7243:         userProfile.save()
7244:     }
7245:     // MARK: - Helper Methods
7246:     private func calculateAccuracyForLevel(_ score: Int) -> Double {
7247:         guard let level = currentLevel, level.requiredScore > 0 else { return 0.0 }
7248:         return Double(score) / Double(level.requiredScore)
7249:     }
7250:     private func isLevelPerfect(_ score: Int) -> Bool {
7251:         guard let level = currentLevel else { return false }
7252:         let perfectThreshold = level.requiredScore * 3 / 2 // 150% del score requerido
7253:         return score >= perfectThreshold
7254:     }
7255:     private func calculatePlayTime() -> TimeInterval {
7256:         // Implementar lógica para calcular el tiempo de juego de la sesión actual
7257:         return 60.0 // Por ahora retornamos un valor fijo de 1 minuto
7258:     }
7259:     // MARK: - Level Information
7260:     func getLevelInfo(_ levelId: Int) -> (name: String, highScore: Int)? {
7261:         guard let level = gameConfig?.levels.first(where: { level in
7262:             level.levelId == levelId
7263:         }) else {
7264:             return nil
7265:         }
7266:         return (level.name, highScores[levelId] ?? 0)
7267:     }
7268:     func getNextUnlockedLevel() -> Int? {
7269:         // El nivel actual siempre está desbloqueado
7270:         let currentLevel = userProfile.statistics.currentLevel
7271:         if !hasCompletedLevel(currentLevel) {
7272:             return currentLevel
7273:         }
7274:         return nil
7275:     }
7276:     func hasCompletedLevel(_ levelId: Int) -> Bool {
7277:         guard let level = gameConfig?.levels.first(where: { level in
7278:             level.levelId == levelId
7279:         }) else {
7280:             return false
7281:         }
7282:         let currentScore = highScores[levelId] ?? 0
7283:         return currentScore >= level.requiredScore
7284:     }
7285:     // MARK: - Level Configuration Access
7286:     var accuracyThresholds: AccuracyThresholds? {
7287:         gameConfig?.accuracyThresholds
7288:     }
7289:     var availableLevels: [GameLevel] {
7290:         gameConfig?.levels ?? []
7291:     }
7292:     var currentLevelBlocks: [String: Block]? {
7293:         currentLevel?.blocks
7294:     }
7295:     var currentLevelSpeed: FallingSpeed? {
7296:         currentLevel?.fallingSpeed
7297:     }
7298:     var currentLevelStyles: [String]? {
7299:         currentLevel?.allowedStyles
7300:     }
7301:     // MARK: - Game State Validation
7302:     func isValidStyle(_ style: String) -> Bool {
7303:         currentLevel?.allowedStyles.contains(style) ?? false
7304:     }
7305:     func getBlockConfig(for style: String) -> Block? {
7306:         currentLevel?.blocks[style]
7307:     }
7308:     // MARK: - User Progress
7309:     func resetProgress() {
7310:         userProfile = UserProfile()
7311:         userProfile.save()
7312:         loadStatistics()
7313:     }
7314:     func getProgressSummary() -> String {
7315:         """
7316:         🎮 Partidas jugadas: \(totalGamesPlayed)
7317:         🏆 Niveles completados: \(highScores.count)
7318:         📊 Último nivel jugado: \(lastPlayedLevel)
7319:         """
7320:     }
7321: }
7322: </file>
7323: <file path="MusicBlocks/GameTypes.swift">
7324: //
7325: //  GameTypes.swift
7326: //  MusicBlocks
7327: //
7328: //  Created by Jose R. García on 7/3/25.
7329: //
7330: import Foundation
7331: import SpriteKit
7332: // MARK: - Block Types
7333: struct BlockInfo {
7334:     let node: SKNode
7335:     let note: String
7336:     let style: String
7337:     let config: Block
7338:     let requiredHits: Int
7339:     let requiredTime: TimeInterval
7340:     var currentHits: Int = 0
7341:     var holdStartTime: Date?
7342: }
7343: // MARK: - Game States
7344: enum GameState {
7345:     case countdown
7346:     case playing
7347:     case paused
7348:     case gameOver(reason: GameOverReason)
7349: }
7350: enum GameOverReason: String {
7351:     case noLives = "noLives"
7352:     case blocksOverflow = "blocksOverflow"
7353:     case victory = "victory"
7354:     var message: String {
7355:         switch self {
7356:         case .noLives:
7357:             return "¡Te has quedado sin vidas!"
7358:         case .blocksOverflow:
7359:             return "¡Los bloques han llegado demasiado abajo!"
7360:         case .victory:
7361:             return "¡Nivel completado!"
7362:         }
7363:     }
7364:     var isVictory: Bool {
7365:         if case .victory = self {
7366:             return true
7367:         }
7368:         return false
7369:     }
7370: }
7371: // En GameTypes.swift
7372: enum NoteStateType: String {
7373:     case waiting = "waiting"
7374:     case correct = "correct"
7375:     case wrong = "wrong"
7376:     case success = "success"
7377: }
7378: enum NoteState: Equatable {
7379:     case waiting
7380:     case correct(deviation: Double)
7381:     case wrong
7382:     case success(multiplier: Int, message: String)
7383: }
7384: </file>
7385: <file path="MusicBlocks/GameUIManager.swift">
7386: //
7387: //  GameUIManager.swift
7388: //  MusicBlocks
7389: //
7390: //  Created by Jose R. García on 7/3/25.
7391: //
7392: import SpriteKit
7393: import UIKit
7394: class GameUIManager {
7395:     // MARK: - Properties
7396:     private weak var scene: SKScene?
7397:     private weak var mainAreaNode: SKNode?
7398:     private var backgroundPattern: BackgroundPatternNode!
7399:     var leftTopBarNode: TopBar?
7400:     var rightTopBarNode: TopBar?
7401:     private var currentOverlay: GameOverlayNode?
7402:     private var objectiveTracker: LevelObjectiveTracker?
7403:     // Indicadores
7404:     var stabilityIndicatorNode: StabilityIndicatorNode!
7405:     var stabilityCounterNode: StabilityCounterNode!
7406:     var tuningIndicatorNode: TuningIndicatorNode!
7407:     var detectedNoteCounterNode: DetectedNoteCounterNode!
7408:     // Dimensiones
7409:     private var mainAreaHeight: CGFloat = 0
7410:     private var mainAreaWidth: CGFloat = 0
7411:     // MARK: - Layout Configuration
7412:     private struct Layout {
7413:         static let margins = UIEdgeInsets(
7414:             top: 6,
7415:             left: 6,
7416:             bottom: UIScreen.main.bounds.height * 0.05,
7417:             right: 6
7418:         )
7419:         static let cornerRadius: CGFloat = 15
7420:         static let verticalSpacing: CGFloat = 5
7421:         // Proporciones de las áreas principales
7422:         static let topBarHeightRatio: CGFloat = 0.08
7423:         static let mainAreaHeightRatio: CGFloat = 0.74
7424:         static let sideBarWidthRatio: CGFloat = 0.07
7425:         static let mainAreaWidthRatio: CGFloat = 0.75
7426:         static let sideBarHeightRatio: CGFloat = 0.4
7427:         // TopBars específicas
7428:         static let topBarWidthRatio: CGFloat = 0.490  // Aumentado de 0.47 para que sean más anchas
7429:         static let topBarSpacing: CGFloat = 4         // Reducido de 8 para que estén más juntas
7430:         // Efectos visuales
7431:         static let shadowRadius: CGFloat = 8.0
7432:         static let shadowOpacity: Float = 0.8
7433:         static let shadowOffset = CGPoint(x: 0, y: -2)
7434:         static let containerAlpha: CGFloat = 0.95
7435:     }
7436:     // MARK: - Initialization
7437:     init(scene: SKScene) {
7438:         self.scene = scene
7439:         setupUI()
7440:     }
7441:     // MARK: - Public Methods
7442:     func setupUI() {
7443:         setupBackground()
7444:         setupLayout()
7445:     }
7446:     func updateUI(score: Int, lives: Int) {
7447:         leftTopBarNode?.updateScore(score)
7448:         leftTopBarNode?.updateLives(lives)
7449:         // Crear un objeto ObjectiveProgress con los datos actuales
7450:         if let tracker = objectiveTracker {
7451:             tracker.updateProgress(score: score)
7452:             // Obtener el progreso actual directamente
7453:             let progress = tracker.getCurrentProgress()
7454:             // Actualizar el panel de objetivos con estos datos
7455:             rightTopBarNode?.updateObjectiveInfo(with: progress)
7456:         }
7457:     }
7458:     // MARK: - Setup Methods
7459:     private func setupBackground() {
7460:         guard let scene = scene else { return }
7461:         backgroundPattern = BackgroundPatternNode(size: scene.size)
7462:         backgroundPattern.zPosition = -10
7463:         scene.addChild(backgroundPattern)
7464:     }
7465:     private func setupLayout() {
7466:         guard let scene = scene else { return }
7467:         let safeWidth = scene.size.width - Layout.margins.left - Layout.margins.right
7468:         let safeHeight = scene.size.height - Layout.margins.top - Layout.margins.bottom
7469:         let topBarHeight = safeHeight * Layout.topBarHeightRatio
7470:         let mainAreaHeight = safeHeight * Layout.mainAreaHeightRatio
7471:         let mainAreaWidth = safeWidth * Layout.mainAreaWidthRatio
7472:         let sideBarWidth = safeWidth * Layout.sideBarWidthRatio
7473:         let sideBarHeight = safeHeight * Layout.sideBarHeightRatio
7474:         setupTopBars(width: safeWidth, height: topBarHeight)
7475:         setupMainArea(width: mainAreaWidth, height: mainAreaHeight, topBarHeight: topBarHeight)
7476:         setupSideBars(width: sideBarWidth, height: sideBarHeight, topBarHeight: topBarHeight)
7477:     }
7478:     private func setupTopBars(width: CGFloat, height: CGFloat) {
7479:         guard let scene = scene else { return }
7480:         let safeAreaTop = (scene.view?.safeAreaInsets.top ?? 0)
7481:         // Calcular dimensiones
7482:         let topBarWidth = width * Layout.topBarWidthRatio
7483:         let yPosition = scene.size.height - safeAreaTop - height / 2
7484:         // Calcular posiciones X
7485:         // Ajustamos las posiciones para que estén más cerca de los bordes
7486:         let leftXPosition = Layout.margins.left + topBarWidth/2
7487:         let rightXPosition = scene.size.width - Layout.margins.right - topBarWidth/2
7488:         // Crear TopBars
7489:         leftTopBarNode = TopBar.create(
7490:             width: topBarWidth,
7491:             height: height,
7492:             position: CGPoint(x: leftXPosition, y: yPosition),
7493:             type: .main
7494:         )
7495:         rightTopBarNode = TopBar.create(
7496:             width: topBarWidth,
7497:             height: height,
7498:             position: CGPoint(x: rightXPosition, y: yPosition),
7499:             type: .objectives
7500:         )
7501:         if let leftBar = leftTopBarNode, let rightBar = rightTopBarNode {
7502:             leftBar.zPosition = 100
7503:             rightBar.zPosition = 100
7504:             // Configurar las barras
7505:             if let currentLevel = GameManager.shared.currentLevel {
7506:                 objectiveTracker = LevelObjectiveTracker(level: currentLevel)
7507:                 if let tracker = objectiveTracker {
7508:                     leftBar.configure(withLevel: currentLevel, objectiveTracker: tracker)
7509:                     rightBar.configure(withLevel: currentLevel, objectiveTracker: tracker)
7510:                     leftBar.updateLives(currentLevel.lives.initial)
7511:                     leftBar.updateScore(0)
7512:                 }
7513:             }
7514:             // Añadir a la escena
7515:             scene.addChild(leftBar)
7516:             scene.addChild(rightBar)
7517:             // Debug de posiciones
7518:             //            print("Left TopBar position: \(leftXPosition)")
7519:             //            print("Right TopBar position: \(rightXPosition)")
7520:             //            print("TopBar width: \(topBarWidth)")
7521:             //            print("Scene width: \(scene.size.width)")
7522:         }
7523:     }
7524:     private func setupMainArea(width: CGFloat, height: CGFloat, topBarHeight: CGFloat) {
7525:         guard let scene = scene else { return }
7526:         mainAreaWidth = width
7527:         mainAreaHeight = height
7528:         // Crear el contenedor principal sin fondo ni bordes
7529:         let containerNode = SKNode()
7530:         containerNode.position = CGPoint(
7531:             x: scene.size.width/2,
7532:             y: scene.size.height/2 - Layout.verticalSpacing
7533:         )
7534:         containerNode.zPosition = 1
7535:         // Añadir línea límite con efecto de "danger zone"
7536:         addDangerZone(to: containerNode, width: width, height: height)
7537:         // Contenido principal (bloques)
7538:         let mainContent = SKNode()
7539:         mainContent.zPosition = 2
7540:         containerNode.addChild(mainContent)
7541:         mainAreaNode = mainContent
7542:         scene.addChild(containerNode)
7543:         //  print("MainArea configurada - Tamaño: \(width)x\(height)")
7544:     }
7545:     private func addDangerZone(to container: SKNode, width: CGFloat, height: CGFloat) {
7546:         guard let scene = scene else { return }
7547:         let dangerZone = SKNode()
7548:         dangerZone.zPosition = 1
7549:         // Calcular la posición del límite (en la parte inferior)
7550:         let bottomLimit = -(height/2)
7551:         // Crear el área de advertencia usando el ancho total de la pantalla y extendiendo hasta el fondo
7552:         let warningArea = SKShapeNode(rect: CGRect(
7553:             x: -scene.size.width/2,
7554:             y: bottomLimit - scene.size.height, // Extender hacia abajo
7555:             width: scene.size.width,
7556:             height: scene.size.height // Usar toda la altura restante de la pantalla
7557:         ))
7558:         warningArea.fillColor = UIColor.red
7559:         warningArea.strokeColor = UIColor.clear
7560:         warningArea.alpha = 0.15
7561:         // La línea límite permanece en la misma posición
7562:         let limitLine = SKShapeNode(rect: CGRect(
7563:             x: -scene.size.width/2,
7564:             y: bottomLimit,
7565:             width: scene.size.width,
7566:             height: 2
7567:         ))
7568:         limitLine.fillColor = UIColor.red
7569:         limitLine.strokeColor = UIColor.clear
7570:         limitLine.alpha = 0.8
7571:         // Animación de parpadeo solo para la línea
7572:         let fadeSequence = SKAction.sequence([
7573:             SKAction.fadeAlpha(to: 0.3, duration: 0.5),
7574:             SKAction.fadeAlpha(to: 0.8, duration: 0.5)
7575:         ])
7576:         limitLine.run(SKAction.repeatForever(fadeSequence))
7577:         dangerZone.addChild(warningArea)
7578:         dangerZone.addChild(limitLine)
7579:         container.addChild(dangerZone)
7580:     }
7581:     private func createDangerMarker(size: CGSize) -> SKShapeNode {
7582:         let path = CGMutablePath()
7583:         path.move(to: CGPoint(x: 0, y: 0))
7584:         path.addLine(to: CGPoint(x: size.width, y: 0))
7585:         path.addLine(to: CGPoint(x: size.width, y: -size.height))
7586:         path.addLine(to: CGPoint(x: 0, y: -size.height))
7587:         path.closeSubpath()
7588:         let marker = SKShapeNode(path: path)
7589:         marker.fillColor = UIColor.red
7590:         marker.strokeColor = UIColor.clear
7591:         marker.alpha = 0.8
7592:         // Añadir efecto de parpadeo
7593:         let fadeSequence = SKAction.sequence([
7594:             SKAction.fadeAlpha(to: 0.3, duration: 0.5),
7595:             SKAction.fadeAlpha(to: 0.8, duration: 0.5)
7596:         ])
7597:         marker.run(SKAction.repeatForever(fadeSequence))
7598:         return marker
7599:     }
7600:     private func setupSideBars(width: CGFloat, height: CGFloat, topBarHeight: CGFloat) {
7601:         setupLeftSideBar(width: width, height: height)
7602:         setupRightSideBar(width: width, height: height)
7603:     }
7604:     private func setupLeftSideBar(width: CGFloat, height: CGFloat) {
7605:         guard let scene = scene else { return }
7606:         let position = CGPoint(
7607:             x: Layout.margins.left + width/2 + 10,
7608:             y: scene.size.height/2 - (Layout.verticalSpacing/2)
7609:         )
7610:         // Crear el contenedor y aplicar el estilo directamente
7611:         let leftBar = SKNode()
7612:         leftBar.position = position
7613:         leftBar.zPosition = 1
7614:         leftBar.applyContainerStyle(size: CGSize(width: width, height: height))
7615:         scene.addChild(leftBar)
7616:         setupStabilityIndicators(in: leftBar, at: position, width: width, height: height)
7617:     }
7618:     private func setupRightSideBar(width: CGFloat, height: CGFloat) {
7619:         guard let scene = scene else { return }
7620:         let position = CGPoint(
7621:             x: scene.size.width - Layout.margins.right - width/2 - 10,
7622:             y: scene.size.height/2 - (Layout.verticalSpacing/2)
7623:         )
7624:         // Crear el contenedor y aplicar el estilo directamente
7625:         let rightBar = SKNode()
7626:         rightBar.position = position
7627:         rightBar.zPosition = 1
7628:         rightBar.applyContainerStyle(size: CGSize(width: width, height: height))
7629:         scene.addChild(rightBar)
7630:         setupTuningIndicators(in: rightBar, at: position, width: width, height: height)
7631:     }
7632:     // MARK: - Indicator Setup
7633:     private func setupStabilityIndicators(in container: SKNode, at position: CGPoint, width: CGFloat, height: CGFloat) {
7634:         guard let scene = scene else { return }
7635:         stabilityIndicatorNode = StabilityIndicatorNode(size: CGSize(width: width * 0.6, height: height * 0.9))
7636:         stabilityIndicatorNode.position = .zero
7637:         stabilityIndicatorNode.zPosition = 10
7638:         container.addChild(stabilityIndicatorNode)
7639:         let counterYPosition = position.y - height/2 - 30
7640:         stabilityCounterNode = StabilityCounterNode(size: CGSize(width: width * 2.0, height: 30))
7641:         stabilityCounterNode.position = CGPoint(x: position.x, y: counterYPosition)
7642:         stabilityCounterNode.zPosition = 10
7643:         scene.addChild(stabilityCounterNode)
7644:     }
7645:     private func setupTuningIndicators(in container: SKNode, at position: CGPoint, width: CGFloat, height: CGFloat) {
7646:         guard let scene = scene else { return }
7647:         tuningIndicatorNode = TuningIndicatorNode(size: CGSize(width: width * 0.6, height: height * 0.9))
7648:         tuningIndicatorNode.position = .zero
7649:         tuningIndicatorNode.zPosition = 10
7650:         container.addChild(tuningIndicatorNode)
7651:         let counterYPosition = position.y - height/2 - 30
7652:         detectedNoteCounterNode = DetectedNoteCounterNode(size: CGSize(width: width * 2.0, height: 30))
7653:         detectedNoteCounterNode.position = CGPoint(x: position.x, y: counterYPosition)
7654:         detectedNoteCounterNode.zPosition = 10
7655:         scene.addChild(detectedNoteCounterNode)
7656:     }
7657:     // MARK: - Overlay Methods
7658:     func showLevelStartOverlay(for level: GameLevel, completion: @escaping () -> Void) {
7659:         guard let scene = scene else { return }
7660:         currentOverlay?.removeFromParent()
7661:         // Actualizar las vidas en la TopBar antes de mostrar el overlay
7662:         updateUI(score: 0, lives: level.lives.initial)
7663:         let overlaySize = CGSize(width: scene.size.width * 0.7, height: scene.size.height * 0.45)
7664:         let overlay = LevelStartOverlayNode(
7665:             size: overlaySize,
7666:             levelId: level.levelId,
7667:             levelName: level.name,
7668:             startAction: completion
7669:         )
7670:         scene.addChild(overlay)
7671:         currentOverlay = overlay
7672:         overlay.show(in: scene, overlayPosition: .center)
7673:     }
7674:     func showSuccessOverlay(multiplier: Int, message: String) {
7675:         guard let scene = scene else { return }
7676:         currentOverlay?.removeFromParent()
7677:         let overlaySize = CGSize(width: 350, height: 60)
7678:         let overlay = SuccessOverlayNode(
7679:             size: overlaySize,
7680:             multiplier: multiplier,
7681:             message: message
7682:         )
7683:         scene.addChild(overlay)
7684:         currentOverlay = overlay
7685:         overlay.show(in: scene, overlayPosition: .bottom)
7686:         DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak overlay] in
7687:             overlay?.hide()
7688:         }
7689:     }
7690:     func showFailureOverlay() {
7691:         guard let scene = scene else { return }
7692:         currentOverlay?.removeFromParent()
7693:         let overlaySize = CGSize(width: 350, height: 60)
7694:         let overlay = FailureOverlayNode(size: overlaySize)
7695:         scene.addChild(overlay)
7696:         currentOverlay = overlay
7697:         overlay.show(in: scene, overlayPosition: .bottom)
7698:         DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak overlay] in
7699:             overlay?.hide()
7700:         }
7701:     }
7702:     func showGameOverOverlay(score: Int, message: String, isVictory: Bool, onRestart: @escaping () -> Void) {
7703:         guard let scene = scene else { return }
7704:         currentOverlay?.removeFromParent()
7705:         let overlaySize = CGSize(width: 400, height: 300)
7706:         let overlay = GameOverOverlayNode(
7707:             size: overlaySize,
7708:             score: score,
7709:             message: message,
7710:             isVictory: isVictory,
7711:             restartAction: onRestart
7712:         )
7713:         scene.addChild(overlay)
7714:         currentOverlay = overlay
7715:         overlay.show(in: scene, overlayPosition: .center)
7716:     }
7717:     // MARK: - Public Accessors
7718:     func getMainAreaNode() -> SKNode? {
7719:         return mainAreaNode
7720:     }
7721:     func getMainAreaDimensions() -> (width: CGFloat, height: CGFloat) {
7722:         return (mainAreaWidth, mainAreaHeight)
7723:     }
7724:     // Método adicional para actualizar el progreso del objetivo
7725:     func updateObjectiveProgress(
7726:         score: Int? = nil,
7727:         noteHit: Bool? = nil,
7728:         accuracy: Double? = nil,
7729:         blockDestroyed: String? = nil,
7730:         deltaTime: TimeInterval? = nil
7731:     ) {
7732:         objectiveTracker?.updateProgress(
7733:             score: score,
7734:             noteHit: noteHit,
7735:             accuracy: accuracy,
7736:             blockDestroyed: blockDestroyed,
7737:             deltaTime: deltaTime
7738:         )
7739:     }
7740:     public func configureTopBars(withLevel level: GameLevel, objectiveTracker: LevelObjectiveTracker) {
7741:         leftTopBarNode?.configure(withLevel: level, objectiveTracker: objectiveTracker)
7742:         rightTopBarNode?.configure(withLevel: level, objectiveTracker: objectiveTracker)
7743:     }
7744: }
7745: </file>
7746: <file path="MusicBlocks/LevelObjectiveTracker.swift">
7747: //
7748: //  LevelObjectiveTracker.swift
7749: //  MusicBlocks
7750: //
7751: //  Created by Jose R. García on 8/3/25.
7752: //
7753: import Foundation
7754: class LevelObjectiveTracker {
7755:     private let primaryObjective: Objective
7756:     private var currentProgress: ObjectiveProgress
7757:     init(level: GameLevel) {
7758:         self.primaryObjective = level.objectives.primary
7759:         self.currentProgress = ObjectiveProgress()
7760:         // Inicializar contadores para cada estilo permitido en el nivel
7761:         for style in level.allowedStyles {
7762:             currentProgress.blocksByType[style] = 0
7763:         }
7764:     }
7765:     func getPrimaryObjective() -> Objective {
7766:         return primaryObjective
7767:     }
7768:     // MARK: - Progress Updates
7769:     func updateProgress(score: Int? = nil,
7770:                        noteHit: Bool? = nil,
7771:                        accuracy: Double? = nil,
7772:                        blockDestroyed: String? = nil,
7773:                        deltaTime: TimeInterval? = nil) {
7774:         // Actualizar score - Para objetivos tipo "score"
7775:         if let score = score {
7776:             currentProgress.score = score
7777:         }
7778:         // Actualizar notas acertadas - Para objetivos tipo "total_notes"
7779:         if let noteHit = noteHit, noteHit {
7780:             currentProgress.notesHit += 1
7781:         }
7782:         // Actualizar precisión - Para objetivos tipo "note_accuracy"
7783:         if let accuracy = accuracy {
7784:             currentProgress.accuracySum += accuracy
7785:             currentProgress.accuracyCount += 1
7786:         }
7787:         // Actualizar bloques destruidos - Para objetivos tipo "block_destruction" y "total_blocks"
7788:         if let blockType = blockDestroyed {
7789:             currentProgress.blocksByType[blockType, default: 0] += 1
7790:             currentProgress.totalBlocksDestroyed += 1
7791:         }
7792:         // Actualizar tiempo
7793:         if let deltaTime = deltaTime {
7794:             currentProgress.timeElapsed += deltaTime
7795:         }
7796:         // Al final, después de todas las actualizaciones, notificar el cambio
7797:             NotificationCenter.default.post(
7798:                 name: NSNotification.Name("GameDataUpdated"),
7799:                 object: nil,
7800:                 userInfo: [:]  // No necesitamos pasar datos, solo forzar la actualización
7801:             )
7802:     }
7803:     // MARK: - Objective Checking
7804:     func checkObjectives() -> Bool {
7805:             return checkObjective(primaryObjective)
7806:         }
7807:         private func checkObjective(_ objective: Objective) -> Bool {
7808:             switch objective.type {
7809:             case "score":
7810:                 return currentProgress.score >= (objective.target ?? 0)
7811:             case "total_notes":
7812:                 return currentProgress.notesHit >= (objective.target ?? 0)
7813:             case "note_accuracy":
7814:                 return currentProgress.notesHit >= (objective.target ?? 0) &&
7815:                        currentProgress.averageAccuracy >= (objective.minimumAccuracy ?? 0)
7816:             case "block_destruction":
7817:                 guard let details = objective.details else { return false }
7818:                 // All blocks must reach their target
7819:                 return details.allSatisfy { blockType, required in
7820:                     currentProgress.blocksByType[blockType, default: 0] >= required
7821:                 }
7822:             case "total_blocks":
7823:                 return currentProgress.totalBlocksDestroyed >= (objective.target ?? 0)
7824:             default:
7825:                 return false
7826:             }
7827:         }
7828:     // MARK: - Progress Information
7829:     func getProgress() -> Double {
7830:             return calculateProgress(for: primaryObjective)
7831:         }
7832:         func getCurrentProgress() -> ObjectiveProgress {
7833:             return currentProgress
7834:         }
7835:         private func calculateProgress(for objective: Objective) -> Double {
7836:             switch objective.type {
7837:             case "score":
7838:                 let target = Double(objective.target ?? 1)
7839:                 return min(Double(currentProgress.score) / target, 1.0)
7840:             case "total_notes":
7841:                 let target = Double(objective.target ?? 1)
7842:                 return min(Double(currentProgress.notesHit) / target, 1.0)
7843:             case "note_accuracy":
7844:                 let noteProgress = Double(currentProgress.notesHit) / Double(objective.target ?? 1)
7845:                 let accuracyProgress = currentProgress.averageAccuracy / (objective.minimumAccuracy ?? 1.0)
7846:                 return min(min(noteProgress, accuracyProgress), 1.0)
7847:             case "block_destruction":
7848:                 guard let details = objective.details else { return 0 }
7849:                 let progressByType = details.map { blockType, required in
7850:                     Double(currentProgress.blocksByType[blockType, default: 0]) / Double(required)
7851:                 }
7852:                 // Always use min since we now require all blocks to be destroyed
7853:                 return min(progressByType.min() ?? 0, 1.0)
7854:             case "total_blocks":
7855:                 let target = Double(objective.target ?? 1)
7856:                 return min(Double(currentProgress.totalBlocksDestroyed) / target, 1.0)
7857:             default:
7858:                 return 0
7859:             }
7860:         }
7861:     }
7862: </file>
7863: <file path="MusicBlocks/MusicBlocksScene.swift">
7864: //
7865: //  MusicBlocksScene.swift
7866: //  MusicBlocks
7867: //
7868: //  Created by Jose R. García on 14/3/25.
7869: //
7870: import SpriteKit
7871: import UIKit
7872: import SwiftUI
7873: class MusicBlocksScene: SKScene {
7874:     @Environment(\.screenSize) var screenSize
7875:     // MARK: - Managers
7876:     private let audioController = AudioController.sharedInstance
7877:     private let gameManager = GameManager.shared
7878:     private var gameEngine: GameEngine!
7879:     private var blocksManager: BlocksManager!
7880:     private var uiManager: GameUIManager!
7881:     private var objectiveTracker: LevelObjectiveTracker?
7882:     // MARK: - Game State
7883:     private var lastUpdateTime: TimeInterval = 0
7884:     private var lastTimeUpdate: TimeInterval = 0
7885:     private let timeUpdateInterval: TimeInterval = 1.0 // Actualizar cada segundo
7886:     // MARK: - Lifecycle Methods
7887:     override func didMove(to view: SKView) {
7888:         super.didMove(to: view)
7889:         print("🎬 Scene did move to view")
7890:         setupManagers()
7891:         setupGame()
7892:         // Añadir observador para actualizaciones de todos los datos del juego
7893:         NotificationCenter.default.addObserver(
7894:             self,
7895:             selector: #selector(handleGameDataUpdate(_:)),
7896:             name: NSNotification.Name("GameDataUpdated"),
7897:             object: nil
7898:         )
7899:     }
7900:     override func willMove(from view: SKView) {
7901:         super.willMove(from: view)
7902:         print("⏹️ Deteniendo juego")
7903:         audioController.stop()
7904:         blocksManager.stopBlockGeneration()
7905:         // Eliminar observador al salir de la escena
7906:         NotificationCenter.default.removeObserver(self)
7907:     }
7908:     // MARK: - Score Update Handler
7909:     @objc func handleGameDataUpdate(_ notification: Notification) {
7910:         let userData = notification.userInfo ?? [:]
7911:         let score = userData["score"] as? Int ?? gameEngine.score
7912:         let lives = userData["lives"] as? Int ?? gameEngine.lives
7913:         // Actualizar la UI principal
7914:         uiManager.updateUI(score: score, lives: lives)
7915:         // Manejar overlays según información en la notificación
7916:         if userData["noteState"] as? String == "success" {
7917:             let multiplier = userData["multiplier"] as? Int ?? 1
7918:             let message = userData["message"] as? String ?? "¡Bien!"
7919:             uiManager.showSuccessOverlay(multiplier: multiplier, message: message)
7920:         } else if userData["noteState"] as? String == "wrong" {
7921:             uiManager.showFailureOverlay()
7922:         }
7923:         // Manejar game over
7924:         if let gameOver = userData["gameOver"] as? Bool, gameOver {
7925:             let isVictory = userData["isVictory"] as? Bool ?? false
7926:             let reasonMessage = userData["reasonMessage"] as? String ?? (isVictory ? "¡Victoria!" : "Fin del juego")
7927:             uiManager.showGameOverOverlay(
7928:                 score: score,
7929:                 message: reasonMessage,
7930:                 isVictory: isVictory
7931:             ) { [weak self] in
7932:                 self?.setupGame()
7933:             }
7934:         }
7935:     }
7936:     // MARK: - Setup Methods
7937:         private func setupManagers() {
7938:             // Primero cargar el nivel inicial
7939:             let userProfile = UserProfile.load()
7940:             _ = gameManager.loadLevel(userProfile.statistics.currentLevel)
7941:             // Crear tracker para el nivel actual
7942:             if let currentLevel = gameManager.currentLevel {
7943:                 objectiveTracker = LevelObjectiveTracker(level: currentLevel)
7944:             }
7945:             // Inicializar UI Manager
7946:             uiManager = GameUIManager(scene: self)
7947:             // Obtener dimensiones del área principal
7948:             let (mainAreaWidth, mainAreaHeight) = uiManager.getMainAreaDimensions()
7949:             // Inicializar BlocksManager
7950:             blocksManager = BlocksManager(
7951:                 blockSize: CGSize(
7952:                     width: mainAreaWidth * 0.9,
7953:                     height: mainAreaHeight * 0.15
7954:                 ),
7955:                 blockSpacing: mainAreaHeight * 0.02,
7956:                 mainAreaNode: uiManager.getMainAreaNode(),
7957:                 mainAreaHeight: mainAreaHeight
7958:             )
7959:             // Inicializar GameEngine
7960:             gameEngine = GameEngine(blockManager: blocksManager)
7961:             // Asignar el tracker de objetivos al motor de juego
7962:             gameEngine.objectiveTracker = objectiveTracker
7963:             // Configurar el delegado de audio
7964:             guard let engine = gameEngine else {
7965:                 fatalError("GameEngine no se ha inicializado correctamente")
7966:             }
7967:             audioController.delegate = engine
7968:             // IMPORTANTE: Actualizar UI con las vidas iniciales después de que todo esté configurado
7969:             if let currentLevel = gameManager.currentLevel {
7970:                 uiManager.updateUI(score: 0, lives: currentLevel.lives.initial)
7971:             }
7972:         }
7973:     private func setupGame() {
7974:         // Cargar nivel desde el perfil del usuario
7975:         let userProfile = UserProfile.load()
7976:         print("Intentando cargar nivel \(userProfile.statistics.currentLevel)")
7977:         if gameManager.loadLevel(userProfile.statistics.currentLevel) {
7978:             if let currentLevel = gameManager.currentLevel {
7979:                 startLevel(currentLevel)
7980:             }
7981:         } else {
7982:             print("Error al cargar nivel, intentando cargar tutorial")
7983:             if gameManager.loadLevel(0) {
7984:                 if let tutorialLevel = gameManager.currentLevel {
7985:                     startLevel(tutorialLevel)
7986:                 }
7987:             }
7988:         }
7989:     }
7990:     private func startLevel(_ level: GameLevel) {
7991:         print("Iniciando nivel \(level.levelId): \(level.name)")
7992:         // Detener audio y limpiar bloques
7993:         audioController.stop()
7994:         blocksManager.clearBlocks()
7995:         // Configurar UI antes del overlay
7996:         if let tracker = objectiveTracker {
7997:             uiManager.configureTopBars(withLevel: level, objectiveTracker: tracker)
7998:         }
7999:         uiManager.updateUI(score: 0, lives: level.lives.initial)
8000:         // Mostrar overlay de inicio de nivel
8001:         uiManager.showLevelStartOverlay(for: level) { [weak self] in
8002:             self?.startGameplay()
8003:         }
8004:     }
8005:     private func startGameplay() {
8006:         print("Iniciando gameplay")
8007:         // Inicializar el motor del juego (esto ya configura las métricas y genera bloques)
8008:         gameEngine.startNewGame()
8009:         // Esperar un pequeño retraso para que el fade out de la música de fondo finalice antes de iniciar el audio.
8010:         DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
8011:             self.audioController.start()
8012:             print("✅ Motor de audio iniciado")
8013:             self.blocksManager.startBlockGeneration()
8014:             print("✅ Gameplay iniciado")
8015:         }
8016:     }
8017:     // MARK: - Update Methods
8018:     override func update(_ currentTime: TimeInterval) {
8019:         // Mantener la actualización original
8020:         lastUpdateTime = currentTime
8021:         // Si el juego está en curso, comprobar la posición de los bloques
8022:         if case .playing = gameEngine.gameState {
8023:             // Comprobar posición de bloques primero
8024:             gameEngine.checkBlocksPosition()
8025:             // Actualizar el tiempo si ha pasado el intervalo
8026:             if currentTime - lastTimeUpdate >= timeUpdateInterval {
8027:                 lastTimeUpdate = currentTime
8028:                 updateTimeDisplay()
8029:             }
8030:             // Luego actualizar el estado del juego
8031:             updateGameState()
8032:         }
8033:     }
8034:     // Añadir este método para actualizar la información del tiempo
8035:     private func updateTimeDisplay() {
8036:         if let tracker = objectiveTracker {
8037:             // Incrementar el tiempo transcurrido
8038:             tracker.updateProgress(deltaTime: timeUpdateInterval)
8039:             // Esto ya debería desencadenar una notificación que actualizará la UI
8040:             // Pero por si acaso, podemos forzar una actualización
8041:             let progress = tracker.getCurrentProgress()
8042:             uiManager.rightTopBarNode?.updateObjectiveInfo(with: progress)
8043:         }
8044:     }
8045:     private func updateGameState() {
8046:         // Actualizar indicadores de estabilidad
8047:         uiManager.stabilityIndicatorNode.duration = audioController.stabilityDuration
8048:         uiManager.stabilityCounterNode.duration = audioController.stabilityDuration
8049:         // Actualizar UI según estado del juego
8050:         updateGameUI()
8051:     }
8052:     private func updateGameUI() {
8053:         uiManager.updateUI(score: gameEngine.score, lives: gameEngine.lives)
8054:         switch gameEngine.gameState {
8055:         case .playing:
8056:             handleGameplayState()
8057:         case .gameOver(let reason):
8058:             handleGameOver(reason: reason)
8059:         case .paused:
8060:             break // Manejar pausa si es necesario
8061:         case .countdown:
8062:             break // La cuenta atrás la maneja el overlay
8063:         }
8064:     }
8065:     // MARK: - Game State Handling
8066:     private func handleGameplayState() {
8067:         switch gameEngine.noteState {
8068:         case .success(let multiplier, let message):
8069:             uiManager.showSuccessOverlay(multiplier: multiplier, message: message)
8070:         case .wrong:
8071:             uiManager.showFailureOverlay()
8072:         default:
8073:             break
8074:         }
8075:     }
8076:     private func handleGameOver(reason: GameOverReason) {
8077:         audioController.stop()
8078:         blocksManager.stopBlockGeneration()
8079:         // Actualizar estadísticas del juego
8080:         if let currentLevel = gameManager.currentLevel {
8081:             // Actualizar con el estado de victoria
8082:             gameManager.updateGameStatistics(
8083:                 levelId: currentLevel.levelId,
8084:                 score: gameEngine.score,
8085:                 completed: reason == .victory
8086:             )
8087:         }
8088:         // Determinar el mensaje según la razón
8089:         let message = switch reason {
8090:         case .blocksOverflow:
8091:             "¡Los bloques han alcanzado la zona de peligro!"
8092:         case .noLives:
8093:             "¡Te has quedado sin vidas!"
8094:         case .victory:
8095:             "¡Nivel completado!"
8096:         }
8097:         print("🔴 Game Over: \(message)")
8098:         // Mostrar overlay con el mensaje específico
8099:         uiManager.showGameOverOverlay(
8100:             score: gameEngine.score,
8101:             message: message,
8102:             isVictory: reason == .victory
8103:         ) { [weak self] in
8104:             self?.setupGame()
8105:         }
8106:     }
8107:     // MARK: - AudioControllerDelegate
8108:     func audioController(_ controller: AudioController, didDetectNote note: String, frequency: Float, amplitude: Float, deviation: Double) {
8109:         // Actualizar indicadores de nota
8110:         uiManager.detectedNoteCounterNode?.currentNote = note
8111:         uiManager.detectedNoteCounterNode?.isActive = true
8112:         uiManager.tuningIndicatorNode.deviation = deviation
8113:         uiManager.tuningIndicatorNode.isActive = true
8114:         // Procesar nota detectada
8115:         gameEngine.checkNote(
8116:             currentNote: note,
8117:             deviation: deviation,
8118:             isActive: true
8119:         )
8120:         // Actualizar la información del objetivo en la UI
8121:             if let progress = objectiveTracker?.getCurrentProgress() {
8122:                 uiManager.rightTopBarNode?.updateObjectiveInfo(with: progress)
8123:             }
8124:     }
8125:     func audioControllerDidDetectSilence(_ controller: AudioController) {
8126:         // Actualizar indicadores visuales
8127:         uiManager.detectedNoteCounterNode?.isActive = false
8128:         uiManager.tuningIndicatorNode.isActive = false
8129:         // Procesar silencio
8130:         gameEngine.checkNote(
8131:             currentNote: "-",
8132:             deviation: 0,
8133:             isActive: false
8134:         )
8135:     }
8136: }
8137: // MARK: - Environment Values
8138: private struct ScreenSizeKey: EnvironmentKey {
8139:     static let defaultValue: CGSize = UIScreen.main.bounds.size
8140: }
8141: extension EnvironmentValues {
8142:     var screenSize: CGSize {
8143:         get { self[ScreenSizeKey.self] }
8144:         set { self[ScreenSizeKey.self] = newValue }
8145:     }
8146: }
8147: // MARK: - SwiftUI Representative
8148: struct SpriteViewRepresentable: UIViewRepresentable {
8149:     let size: CGSize
8150:     func makeUIView(context: Context) -> SKView {
8151:         let view = SKView(frame: .zero)
8152:         view.preferredFramesPerSecond = 60
8153:         view.ignoresSiblingOrder = true
8154:         let scene = MusicBlocksScene()
8155:         scene.scaleMode = .resizeFill
8156:         scene.size = size
8157:         view.presentScene(scene)
8158:         return view
8159:     }
8160:     func updateUIView(_ uiView: SKView, context: Context) {
8161:         if let scene = uiView.scene {
8162:             scene.size = size
8163:         }
8164:     }
8165: }
8166: struct MusicBlocksSceneView: View {
8167:     var body: some View {
8168:         GeometryReader { geometry in
8169:             SpriteView(scene: MusicBlocksScene(size: geometry.size))
8170:                 .ignoresSafeArea()
8171:                 .frame(maxWidth: .infinity, maxHeight: .infinity)
8172:                 .navigationBarHidden(true)
8173:         }
8174:     }
8175: }
8176: #if DEBUG
8177: import SwiftUI
8178: struct MusicBlocksScene_Previews: PreviewProvider {
8179:     static var previews: some View {
8180:         MusicBlocksSceneView()
8181:             .previewDevice("iPhone 16")
8182:     }
8183: }
8184: #endif
8185: </file>
8186: </files>
</file>

<file path="MusicBlocks/Preview Content/Preview Assets.xcassets/Contents.json">
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
</file>

<file path="MusicBlocks/BackgroundPatternNode.swift">
  1: import SpriteKit
  2: class BackgroundPatternNode: SKNode {
  3:     let pastelColors: [UIColor]
  4:     private let contrastColor: UIColor
  5:     private let opacity: CGFloat
  6:     private let colors: [UIColor] = []
  7:     private let numberOfWaves = 8
  8:     private let numberOfLines = 12
  9:     private let numberOfCircles = 6
 10:     private let numberOfDiagonals = 15
 11:     private let numberOfNotes = 10
 12:     private let notesSizeRange: ClosedRange<CGFloat> = 20...50
 13:     private let notesRotationRange: ClosedRange<CGFloat> = -45...45
 14:     private let musicImages = [
 15:         "MusicalSymbol_01", "MusicalSymbol_02", "MusicalSymbol_03", "MusicalSymbol_04", "MusicalSymbol_05",
 16:         "MusicalSymbol_06", "MusicalSymbol_07", "MusicalSymbol_08", "MusicalSymbol_09", "MusicalSymbol_10",
 17:         "MusicalSymbol_11", "MusicalSymbol_12", "MusicalSymbol_13", "MusicalSymbol_14", "MusicalSymbol_15",
 18:         "MusicalSymbol_16", "MusicalSymbol_17", "MusicalSymbol_18", "MusicalSymbol_19", "MusicalSymbol_20",
 19:         "MusicalSymbol_21", "MusicalSymbol_22", "MusicalSymbol_23"
 20:     ]
 21:     init(size: CGSize) {
 22:         self.pastelColors = Self.generatePastelColors()
 23:         self.contrastColor = Self.contrastingColor(for: pastelColors.first ?? .white)
 24:         self.opacity = CGFloat.random(in: 0.1...0.2)
 25:         super.init()
 26:         addGradientBackground(size: size, colors: pastelColors)
 27:         setupLayers(size: size)
 28:     }
 29:     required init?(coder aDecoder: NSCoder) {
 30:         fatalError("init(coder:) has not been implementado")
 31:     }
 32:     private func addGradientBackground(size: CGSize, colors: [UIColor]) {
 33:         let texture = gradientTexture(size: size, colors: colors)
 34:         let backgroundNode = SKSpriteNode(texture: texture)
 35:         backgroundNode.anchorPoint = CGPoint(x: 0, y: 0)
 36:         backgroundNode.position = .zero
 37:         backgroundNode.size = size
 38:         backgroundNode.zPosition = -1
 39:         addChild(backgroundNode)
 40:     }
 41:     private func setupLayers(size: CGSize) {
 42:         addWavesLayer(size: size)
 43:         addLinesLayer(size: size)
 44:         addCirclesLayer(size: size)
 45:         addDiagonalBarsLayer(size: size)
 46:         addNotesLayer(size: size)
 47:     }
 48:     private func addWavesLayer(size: CGSize) {
 49:         let path = CGMutablePath()
 50:         for i in 0...numberOfWaves {
 51:             let x = CGFloat(i) * size.width / CGFloat(numberOfWaves)
 52:             path.move(to: CGPoint(x: x, y: 0))
 53:             path.addCurve(
 54:                 to: CGPoint(x: x, y: size.height),
 55:                 control1: CGPoint(x: x + 60 * sin(CGFloat(i)), y: size.height * 0.3),
 56:                 control2: CGPoint(x: x - 60 * cos(CGFloat(i)), y: size.height * 0.7)
 57:             )
 58:         }
 59:         let shapeNode = SKShapeNode(path: path)
 60:         shapeNode.strokeColor = contrastColor
 61:         shapeNode.lineWidth = 1.5
 62:         shapeNode.alpha = opacity * 0.7
 63:         addChild(shapeNode)
 64:     }
 65:     private func addLinesLayer(size: CGSize) {
 66:         let path = CGMutablePath()
 67:         for _ in 0..<numberOfLines {
 68:             let start = CGPoint(
 69:                 x: .random(in: 0...size.width),
 70:                 y: .random(in: 0...size.height)
 71:             )
 72:             let end = CGPoint(
 73:                 x: .random(in: 0...size.width),
 74:                 y: .random(in: 0...size.height)
 75:             )
 76:             path.move(to: start)
 77:             path.addLine(to: end)
 78:         }
 79:         let shapeNode = SKShapeNode(path: path)
 80:         shapeNode.strokeColor = contrastColor
 81:         shapeNode.lineWidth = 1.0
 82:         shapeNode.alpha = opacity * 0.6
 83:         addChild(shapeNode)
 84:     }
 85:     private func addCirclesLayer(size: CGSize) {
 86:         for _ in 0..<numberOfCircles {
 87:             let diameter = CGFloat.random(in: 40...180)
 88:             let circle = SKShapeNode(circleOfRadius: diameter / 2)
 89:             circle.position = CGPoint(
 90:                 x: .random(in: 0...size.width),
 91:                 y: .random(in: 0...size.height)
 92:             )
 93:             circle.strokeColor = contrastColor
 94:             circle.lineWidth = 1.5
 95:             circle.alpha = opacity * 0.5
 96:             addChild(circle)
 97:         }
 98:     }
 99:     private func addDiagonalBarsLayer(size: CGSize) {
100:         let path = CGMutablePath()
101:         let spacing: CGFloat = 50
102:         let rotationAngle: CGFloat = .pi / 4
103:         for x in stride(from: -size.width, through: size.width * 2, by: spacing) {
104:             let transform = CGAffineTransform(rotationAngle: rotationAngle)
105:             let start = CGPoint(x: x, y: 0).applying(transform)
106:             let end = CGPoint(x: x, y: size.height).applying(transform)
107:             path.move(to: start)
108:             path.addLine(to: end)
109:         }
110:         let shapeNode = SKShapeNode(path: path)
111:         shapeNode.strokeColor = contrastColor
112:         shapeNode.lineWidth = 1.0
113:         shapeNode.alpha = opacity * 0.4
114:         addChild(shapeNode)
115:     }
116:     private func addNotesLayer(size: CGSize) {
117:         for _ in 0..<numberOfNotes {
118:             guard let imageName = musicImages.randomElement() else { continue }
119:             let noteSize = CGFloat.random(in: notesSizeRange)
120:             let texture = SKTexture(imageNamed: imageName)
121:             let noteNode = SKSpriteNode(texture: texture)
122:             noteNode.size = CGSize(width: noteSize, height: noteSize)
123:             noteNode.position = CGPoint(
124:                 x: .random(in: 0...size.width),
125:                 y: .random(in: 0...size.height)
126:             )
127:             noteNode.zRotation = CGFloat.random(in: notesRotationRange) * .pi / 180
128:             noteNode.alpha = opacity * 0.8
129:             noteNode.color = contrastColor
130:             noteNode.colorBlendFactor = 1.0
131:             addChild(noteNode)
132:         }
133:     }
134:     private static func generatePastelColors() -> [UIColor] {
135:         let baseHues = [
136:             CGFloat.random(in: 0...1),
137:             CGFloat.random(in: 0...1)
138:         ]
139:         return baseHues.map { hue in
140:             UIColor(
141:                 hue: hue,
142:                 saturation: CGFloat.random(in: 0.3...0.4),
143:                 brightness: CGFloat.random(in: 0.9...1.0),
144:                 alpha: 1.0
145:             )
146:         }
147:     }
148:     private static func contrastingColor(for color: UIColor) -> UIColor {
149:         var hue: CGFloat = 0, saturation: CGFloat = 0, brightness: CGFloat = 0, alpha: CGFloat = 0
150:         if color.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: &alpha) {
151:             let complementaryHue = (hue + 0.5).truncatingRemainder(dividingBy: 1.0)
152:             return UIColor(
153:                 hue: complementaryHue,
154:                 saturation: max(saturation, 0.7),
155:                 brightness: max(brightness - 0.5, 0.3),
156:                 alpha: 1.0
157:             )
158:         }
159:         return .black
160:     }
161:     private func gradientTexture(size: CGSize, colors: [UIColor]) -> SKTexture {
162:         let gradientLayer = CAGradientLayer()
163:         gradientLayer.frame = CGRect(origin: .zero, size: size)
164:         gradientLayer.colors = colors.map { $0.cgColor }
165:         gradientLayer.startPoint = CGPoint(x: 0, y: 0)
166:         gradientLayer.endPoint = CGPoint(x: 1, y: 1)
167:         UIGraphicsBeginImageContext(gradientLayer.frame.size)
168:         guard let context = UIGraphicsGetCurrentContext() else {
169:             return SKTexture()
170:         }
171:         gradientLayer.render(in: context)
172:         let image = UIGraphicsGetImageFromCurrentImageContext() ?? UIImage()
173:         UIGraphicsEndImageContext()
174:         return SKTexture(image: image)
175:     }
176: }
177: #if DEBUG
178: import SwiftUI
179: import SpriteKit
180: struct BackgroundPatternNodePreview: UIViewRepresentable {
181:     let sceneSize: CGSize
182:     func makeUIView(context: Context) -> SKView {
183:         let skView = SKView(frame: CGRect(origin: .zero, size: sceneSize))
184:         let scene = SKScene(size: sceneSize)
185:         scene.scaleMode = .resizeFill
186:         scene.backgroundColor = .white
187:         let patternNode = BackgroundPatternNode(size: sceneSize)
188:         patternNode.position = CGPoint(x: sceneSize.width / 2, y: sceneSize.height / 2)
189:         scene.addChild(patternNode)
190:         skView.presentScene(scene)
191:         return skView
192:     }
193:     func updateUIView(_ uiView: SKView, context: Context) {
194:         if let scene = uiView.scene {
195:             scene.size = uiView.bounds.size
196:         }
197:     }
198: }
199: struct BackgroundPatternNode_Previews: PreviewProvider {
200:     static var previews: some View {
201:         GeometryReader { geometry in
202:             BackgroundPatternNodePreview(sceneSize: geometry.size)
203:         }
204:         .ignoresSafeArea()
205:         .previewDevice("iPhone 16 Pro")
206:     }
207: }
208: #endif
</file>

<file path="MusicBlocks/game_levels.json">
  1: {
  2:     /*
  3:     Configuración principal del juego MusicBlocks
  4:     Última actualización: 29-02-2025
  5:     */
  6:     "game_version": "0.7",
  7:     /*
  8:     Tipos de objetivos soportados:
  9:     score: Alcanzar una puntuación específica en un tiempo límite
 10:     total_notes: Acertar un número de notas específico
 11:     note_accuracy: Acertar un número determinado de notas con cierta precisión de afinación
 12:     block_destruction: Destruir un número específico de bloques de ciertos tipos
 13:     total_blocks: Destruir un número total de bloques sin importar el tipo
 14:     */
 15:     "objective_types": {
 16:         // El tipo de objetivo score, total_notes, note_accuracy, block_destruction, total_blocks
 17:         "score": {
 18:             "type": "score",
 19:             "description": "Alcanzar una puntuación específica en un tiempo límite",
 20:             "params": {
 21:                 "target": 100, // La puntuación a alcanzar
 22:                 "time_limit": 180 // Límite de tiempo (0 para sin límite)
 23:             }
 24:         },
 25:         "total_notes": {
 26:             "type": "total_notes",
 27:             "description": "Acertar un número de notas específico",
 28:             "params": {
 29:                 "target": 50, // El número de notas a acertar
 30:                 "time_limit": 90 // Límite de tiempo (0 para sin límite)
 31:             }
 32:         },
 33:         "note_accuracy": {
 34:             "type": "note_accuracy",
 35:             "description": "Acertar un número de notas con cierta precisión",
 36:             "params": {
 37:                 "target": 10, // El número de notas a acertar
 38:                 "minimum_accuracy": 0.8, // Precisión mínima requerida
 39:                 "time_limit": 90 // Límite de tiempo (0 para sin límite)
 40:             }
 41:         },
 42:         "block_destruction": {
 43:             "type": "block_destruction",
 44:             "description": "Destruir bloques específicos",
 45:             "params": {
 46:                 "details": {
 47:                     "ghostBlock": 2, // El tipo de bloque y el número de bloques a acertar
 48:                     "hardIceBlock": 3,
 49:                     "defaultBlock": 6
 50:                 },
 51:                 "time_limit": 90, // Límite de tiempo (0 para sin límite)
 52:             }
 53:         },
 54:         "total_blocks": {
 55:             "type": "total_blocks",
 56:             "description": "Destruir un número total de bloques",
 57:             "params": {
 58:                 "target": 15, // El número de bloques a destruir
 59:                 "time_limit": 240 // Límite de tiempo (0 para sin límite)
 60:             }
 61:         }
 62:     },
 63:     "accuracy_thresholds": {
 64:         "perfect": {
 65:             "threshold": 0.95,
 66:             "multiplier": 2.0
 67:         },
 68:         "excellent": {
 69:             "threshold": 0.80,
 70:             "multiplier": 1.5
 71:         },
 72:         "good": {
 73:             "threshold": 0.60,
 74:             "multiplier": 1.0
 75:         }
 76:     },
 77:     "levels": [
 78:         {
 79:             "level_id": 0,
 80:             "name": "Tutorial",
 81:             "max_score": 500,
 82:             "allowed_styles": ["defaultBlock"], // Estilos de bloque en el nivel
 83:             "falling_speed": {
 84:                 "initial": 8.0,  // Velocidad de caida inicial 8.0 segundos
 85:                 "increment": 0.0 // Incremento de velocidad de caida. Quitar 0.0 segundos en cada bloque
 86:             },
 87:             "lives": {
 88:                 "initial": 3,  // Número de vidas al inicio del nivel
 89:                 "extra_lives": {
 90:                     "score_thresholds": [500, 1000],  // Puntuaciones necesarias para ganar vidas extra
 91:                     "max_extra": 1  // Máximo de vidas extra en el nivel
 92:                 }
 93:             },
 94:             "objectives": {
 95:                 "primary": {
 96:                     "type": "score",
 97:                     "target": 100,
 98:                     "time_limit": 180
 99:                 }
100:             },
101:             "blocks": {
102:                 "defaultBlock": {
103:                     "notes": [      // Notas disponibles del bloque
104:                         "SOL4",
105:                         "LA4",
106:                         "SI4"
107:                     ],
108:                     "requiredHits": 1, // Aciertos necesarios para destruir bloque
109:                     "requiredTime": 0.8, // Tiempo necesarios aguantando la nota para destruir bloque
110:                     "style": "default",  // Nombre del estilo del bloque
111:                     "weight": 1, // Peso para probabilidad en generarse el bloque
112:                     "base_points": 5  // Puntos base al destruirlo
113:                 }
114:             }
115:         },
116:         {
117:             "level_id": 1,
118:             "name": "¡Comienza la aventura!",
119:             "max_score": 600,
120:             "allowed_styles": ["defaultBlock", "iceBlock"],
121:             "falling_speed": {
122:                 "initial": 7.0,  // Velocidad de caida inicial
123:                 "increment": 0.1 // Incremento de velocidad de caida
124:             },
125:             "lives": {
126:                 "initial": 3,  // Número de vidas al inicio del nivel
127:                 "extra_lives": {
128:                     "score_thresholds": [500, 1000],  // Puntuaciones necesarias para ganar vidas extra
129:                     "max_extra": 2  // Máximo de vidas extra en el nivel
130:                 }
131:             },
132:             "objectives": {
133:                 "primary": {
134:                     "type": "note_accuracy",
135:                     "target": 10,  // número de notas a acertar
136:                     "minimum_accuracy": 0.8,  // 80% de precisión mínima
137:                     "time_limit": 0  // 0 significa sin límite de tiempo
138:                 }
139: 
140:             },
141:             "blocks": {
142:                 "defaultBlock": {
143:                     "notes": [
144:                         "SOL4",
145:                         "LA4",
146:                         "SI4"
147:                     ],
148:                     "requiredHits": 1,
149:                     "requiredTime": 0.8,
150:                     "style": "defaultBlock",
151:                     "weight": 0.8,
152:                     "base_points": 5
153:                 },
154:                 "iceBlock": {
155:                     "notes": [
156:                         "FA#4",
157:                         "DO5"
158:                     ],
159:                     "requiredHits": 2,
160:                     "requiredTime": 1.2,
161:                     "style": "iceBlock",
162:                     "weight": 0.2,
163:                     "base_points": 10
164:                 }
165:             }
166:         },
167:         {
168:             "level_id": 2,
169:             "name": "Más bloques...!",
170:             "max_score": 700,
171:             "allowed_styles": ["defaultBlock", "hardIceBlock", "ghostBlock"],
172:             "falling_speed": {
173:                 "initial": 6.0,  // Velocidad de caida inicial
174:                 "increment": 0.2 // Incremento de velocidad de caida
175:             },
176:             "lives": {
177:                 "initial": 3,  // Número de vidas al inicio del nivel
178:                 "extra_lives": {
179:                     "score_thresholds": [500, 1000],  // Puntuaciones necesarias para ganar vidas extra
180:                     "max_extra": 2  // Máximo de vidas extra en el nivel
181:                 }
182:             },
183:             "objectives": {
184:                 "primary": { // El objetivo principal que debe cumplirse para completar el nivel
185:                     "type": "total_blocks",
186:                     "target": 15,  // destruir 15 bloques en total
187:                     "time_limit": 240
188:                 }
189:             },
190:             "blocks": {
191:                 "defaultBlock": {
192:                     "notes": [
193:                         "SOL4",
194:                         "LA4",
195:                         "SI4"
196:                     ],
197:                     "requiredHits": 1,
198:                     "requiredTime": 0.8,
199:                     "style": "defaultBlock",
200:                     "weight": 0.4,
201:                     "base_points": 10
202:                 },
203:                 "hardIceBlock": {
204:                     "notes": [
205:                         "DO6",
206:                         "LA5",
207:                         "SI5"
208:                     ],
209:                     "requiredHits": 3,
210:                     "requiredTime": 1.6,
211:                     "style": "hardIceBlock",
212:                     "weight": 0.3,
213:                     "base_points": 20
214:                 },
215:                 "ghostBlock": {
216:                     "notes": [
217:                         "SOL5",
218:                         "FA5",
219:                         "MI4"
220:                     ],
221:                     "requiredHits": 1,
222:                     "requiredTime": 1,
223:                     "style": "ghostBlock",
224:                     "weight": 0.3,
225:                     "base_points": 25
226:                 }
227:             }
228:         }
229:     ],
230:     "medals": {
231:         "notes_hit": [
232:             {
233:                 "name": "Aprendiz del Pentagrama",
234:                 "requirement": "50 notas acertadas",
235:                 "image": "Badge-azul-1",
236:                 "objective": {
237:                     "type": "notes_hit",
238:                     "target": 50,
239:                     "lifetime": true
240:                 }
241:             },
242:             {
243:                 "name": "Intérprete Prometedor",
244:                 "requirement": "250 notas acertadas",
245:                 "image": "Badge-azul-2",
246:                 "objective": {
247:                     "type": "notes_hit",
248:                     "target": 250,
249:                     "lifetime": true
250:                 }
251:             },
252:             {
253:                 "name": "Virtuoso del Ritmo",
254:                 "requirement": "500 notas acertadas",
255:                 "image": "Badge-azul-3",
256:                 "objective": {
257:                     "type": "notes_hit",
258:                     "target": 500,
259:                     "lifetime": true
260:                 }
261:             },
262:             {
263:                 "name": "Maestro Melódico",
264:                 "requirement": "1000 notas acertadas",
265:                 "image": "Badge-azul-4",
266:                 "objective": {
267:                     "type": "notes_hit",
268:                     "target": 1000,
269:                     "lifetime": true
270:                 }
271:             },
272:             {
273:                 "name": "Leyenda Musical",
274:                 "requirement": "5000 notas acertadas",
275:                 "image": "Badge-azul-5",
276:                 "objective": {
277:                     "type": "notes_hit",
278:                     "target": 5000,
279:                     "lifetime": true
280:                 }
281:             }
282:         ],
283:         "play_time": [
284:             {
285:                 "name": "Toca y Aprende",
286:                 "requirement": "30 minutos jugados",
287:                 "image": "Badge-rojo-1",
288:                 "objective": {
289:                     "type": "play_time",
290:                     "target": 1800,  // 30 minutos en segundos
291:                     "lifetime": true
292:                 }
293:             },
294:             {
295:                 "name": "Sesión de Ensayo",
296:                 "requirement": "2 horas jugadas",
297:                 "image": "Badge-rojo-2",
298:                 "objective": {
299:                     "type": "play_time",
300:                     "target": 7200,  // 2 horas en segundos
301:                     "lifetime": true
302:                 }
303:             },
304:             {
305:                 "name": "Músico Apasionado",
306:                 "requirement": "10 horas jugadas",
307:                 "image": "Badge-rojo-3",
308:                 "objective": {
309:                     "type": "play_time",
310:                     "target": 36000,  // 10 horas en segundos
311:                     "lifetime": true
312:                 }
313:             },
314:             {
315:                 "name": "Compositor Dedicado",
316:                 "requirement": "25 horas jugadas",
317:                 "image": "Badge-rojo-4",
318:                 "objective": {
319:                     "type": "play_time",
320:                     "target": 90000,  // 25 horas en segundos
321:                     "lifetime": true
322:                 }
323:             },
324:             {
325:                 "name": "Eterno Virtuoso",
326:                 "requirement": "50 horas jugadas",
327:                 "image": "Badge-rojo-5",
328:                 "objective": {
329:                     "type": "play_time",
330:                     "target": 180000,  // 50 horas en segundos
331:                     "lifetime": true
332:                 }
333:             }
334:         ],
335:         "streaks": [
336:             {
337:                 "name": "Afinado",
338:                 "requirement": "10 notas seguidas sin errores",
339:                 "image": "Badge-oro-1",
340:                 "objective": {
341:                     "type": "streak",
342:                     "target": 10,
343:                     "reset_on_fail": true
344:                 }
345:             },
346:             {
347:                 "name": "Cuerda Perfecta",
348:                 "requirement": "50 notas seguidas sin errores",
349:                 "image": "Badge-oro-2",
350:                 "objective": {
351:                     "type": "streak",
352:                     "target": 50,
353:                     "reset_on_fail": true
354:                 }
355:             },
356:             {
357:                 "name": "Ejecutante de Concierto",
358:                 "requirement": "100 notas seguidas sin errores",
359:                 "image": "Badge-oro-3",
360:                 "objective": {
361:                     "type": "streak",
362:                     "target": 100,
363:                     "reset_on_fail": true
364:                 }
365:             },
366:             {
367:                 "name": "Prodigio Preciso",
368:                 "requirement": "250 notas seguidas sin errores",
369:                 "image": "Badge-oro-4",
370:                 "objective": {
371:                     "type": "streak",
372:                     "target": 250,
373:                     "reset_on_fail": true
374:                 }
375:             },
376:             {
377:                 "name": "Músico Impecable",
378:                 "requirement": "500 notas seguidas sin errores",
379:                 "image": "Badge-oro-5",
380:                 "objective": {
381:                     "type": "streak",
382:                     "target": 500,
383:                     "reset_on_fail": true
384:                 }
385:             }
386:         ],
387:         "perfect_tuning": [
388:             {
389:                 "name": "Afinación Perfecta",
390:                 "requirement": "Completa un nivel con 100% de precisión",
391:                 "image": "Badge-multi-1",
392:                 "objective": {
393:                     "type": "perfect_tuning",
394:                     "target": 1,
395:                     "accuracy": 1.0,
396:                     "lifetime": true
397:                 }
398:             },
399:             {
400:                 "name": "Maestro de la Afinación",
401:                 "requirement": "Completa 5 niveles con 100% de precisión",
402:                 "image": "Badge-multi-2",
403:                 "objective": {
404:                     "type": "perfect_tuning",
405:                     "target": 5,
406:                     "accuracy": 1.0,
407:                     "lifetime": true
408:                 }
409:             },
410:             {
411:                 "name": "Ejecutor Infalible",
412:                 "requirement": "Completa 10 niveles con 100% de precisión",
413:                 "image": "Badge-multi-3",
414:                 "objective": {
415:                     "type": "perfect_tuning",
416:                     "target": 10,
417:                     "accuracy": 1.0,
418:                     "lifetime": true
419:                 }
420:             },
421:             {
422:                 "name": "Perfección Sonora",
423:                 "requirement": "Completa 25 niveles con 100% de precisión",
424:                 "image": "Badge-multi-4",
425:                 "objective": {
426:                     "type": "perfect_tuning",
427:                     "target": 25,
428:                     "accuracy": 1.0,
429:                     "lifetime": true
430:                 }
431:             },
432:             {
433:                 "name": "Leyenda de la Precisión",
434:                 "requirement": "Completa 50 niveles con 100% de precisión",
435:                 "image": "Badge-multi-5",
436:                 "objective": {
437:                     "type": "perfect_tuning",
438:                     "target": 50,
439:                     "accuracy": 1.0,
440:                     "lifetime": true
441:                 }
442:             }
443:         ]
444:     }
445: }
</file>

<file path="MusicBlocks/GameEngine.swift">
  1: import Foundation
  2: import SpriteKit
  3: class GameEngine: ObservableObject {
  4:     @Published var score: Int = 0
  5:     @Published var lives: Int = 0
  6:     @Published var gameState: GameState = .countdown
  7:     @Published var noteState: NoteState = .waiting
  8:     @Published var combo: Int = 0
  9:     private let tunerEngine: TunerEngine
 10:     private let gameManager = GameManager.shared
 11:     private weak var blockManager: BlocksManager?
 12:     var objectiveTracker: LevelObjectiveTracker?
 13:     private var maxExtraLives: Int = 0
 14:     private var scoreThresholdsForExtraLives: [Int] = []
 15:     private struct TimeConstants {
 16:         static let errorDisplayTime: TimeInterval = 2.0
 17:         static let silenceThreshold: TimeInterval = 0.3
 18:         static let minimalNoteDetectionTime: TimeInterval = 0.5
 19:         static let acceptableDeviation: Double = 10.0
 20:     }
 21:     private var isShowingError: Bool = false
 22:     private var isInSuccessState: Bool = false
 23:     private var gamesWon: Int = 0
 24:     private var gamesLost: Int = 0
 25:     private var gameStartTime: Date?
 26:     private var notesHitInGame: Int = 0
 27:     private var bestStreakInGame: Int = 0
 28:     private var totalAccuracyInGame: Double = 0.0
 29:     private var accuracyMeasurements: Int = 0
 30:     private var blockHitsByStyle: [String: Int] = [:]
 31:     init(tunerEngine: TunerEngine = .shared, blockManager: BlocksManager?) {
 32:         self.tunerEngine = tunerEngine
 33:         self.blockManager = blockManager
 34:         gameState = .countdown
 35:         print("GameEngine inicializado. Estado inicial: \(gameState)")
 36:     }
 37:     func startNewGame() {
 38:         guard let currentLevel = gameManager.currentLevel else {
 39:             print("No se pudo iniciar el juego: no hay nivel actual")
 40:             return
 41:         }
 42:         print("Iniciando nueva partida para el nivel \(currentLevel.levelId)")
 43:         resetGameState()
 44:         blockHitsByStyle.removeAll()
 45:         for style in currentLevel.allowedStyles {
 46:             blockHitsByStyle[style] = 0
 47:         }
 48:         gameStartTime = Date()
 49:         notesHitInGame = 0
 50:         bestStreakInGame = 0
 51:         totalAccuracyInGame = 0.0
 52:         accuracyMeasurements = 0
 53:         objectiveTracker = LevelObjectiveTracker(level: currentLevel)
 54:             lives = currentLevel.lives.initial
 55:             maxExtraLives = currentLevel.lives.extraLives.maxExtra
 56:             scoreThresholdsForExtraLives = currentLevel.lives.extraLives.scoreThresholds
 57:             NotificationCenter.default.post(
 58:                 name: NSNotification.Name("GameDataUpdated"),
 59:                 object: nil,
 60:                 userInfo: [
 61:                     "score": score,
 62:                     "lives": lives,
 63:                     "resetObjectives": true
 64:                 ]
 65:             )
 66:         blockManager?.startBlockGeneration()
 67:         gameState = .playing
 68:         print("🎮 Nuevo juego iniciado - Nivel: \(currentLevel.levelId)")
 69:     }
 70:     func pauseGame() {
 71:         guard case .playing = gameState else { return }
 72:         gameState = .paused
 73:         blockManager?.stopBlockGeneration()
 74:         print("Juego pausado")
 75:     }
 76:     func resumeGame() {
 77:         guard case .paused = gameState else { return }
 78:         gameState = .playing
 79:         blockManager?.startBlockGeneration()
 80:         print("Juego reanudado")
 81:     }
 82:     func endGame(reason: GameOverReason) {
 83:         gameState = .gameOver(reason: reason)
 84:         blockManager?.stopBlockGeneration()
 85:            NotificationCenter.default.post(
 86:                name: NSNotification.Name("GameDataUpdated"),
 87:                object: nil,
 88:                userInfo: [
 89:                    "score": score,
 90:                    "lives": lives,
 91:                    "gameOver": true,
 92:                    "reason": reason.rawValue
 93:                ]
 94:            )
 95:         let playTime = gameStartTime.map { Date().timeIntervalSince($0) } ?? 0
 96:         let averageAccuracy = accuracyMeasurements > 0 ? totalAccuracyInGame / Double(accuracyMeasurements) : 0.0
 97:         let requiredScore = gameManager.currentLevel?.requiredScore ?? 0
 98:         let isGameWon = reason != .blocksOverflow && score >= requiredScore
 99:         if isGameWon {
100:             gamesWon += 1
101:         } else {
102:             gamesLost += 1
103:         }
104:         let userProfile = UserProfile.load()
105:         var updatedProfile = userProfile
106:         updatedProfile.updateStatistics(
107:             score: score,
108:             noteHit: false,
109:             accuracy: averageAccuracy,
110:             levelCompleted: isGameWon,
111:             isPerfect: averageAccuracy >= 0.95,
112:             playTime: playTime,
113:             gamesWon: gamesWon,
114:             gamesLost: gamesLost
115:         )
116:         print("📊 Estadísticas finales:")
117:         print("Tiempo jugado: \(Int(playTime))s, Notas acertadas: \(notesHitInGame), Mejor racha: \(bestStreakInGame), Precisión: \(Int(averageAccuracy * 100))%")
118:         print("Estado: \(isGameWon ? "Victoria" : "Derrota")")
119:         print("Total partidas - Ganadas: \(gamesWon), Perdidas: \(gamesLost)")
120:         let totalBlocksAcertados = blockHitsByStyle.values.reduce(0, +)
121:         print("Bloques acertados: \(totalBlocksAcertados)")
122:         for (style, count) in blockHitsByStyle {
123:             print("• \(style): \(count)")
124:         }
125:         resetGameState()
126:     }
127:     // MARK: - Note Processing
128:     /// Compara la nota detectada con el objetivo y delega el manejo correcto o incorrecto.
129:     func checkNote(currentNote: String, deviation: Double, isActive: Bool) {
130:         guard case .playing = gameState, !isInSuccessState, !isShowingError else {
131:             return
132:         }
133:         guard let currentBlock = blockManager?.getCurrentBlock(), isActive else {
134:             print("No se procesará nota: no hay bloque activo o no está activa")
135:             return
136:         }
137:         print("🎯 Comparando nota detectada (\(currentNote)) con objetivo (\(currentBlock.note)), desviación: \(deviation)")
138:         if currentNote == currentBlock.note {
139:             handleCorrectNote(deviation: deviation, block: currentBlock)
140:         } else {
141:             handleWrongNote()
142:         }
143:     }
144:     private func handleCorrectNote(deviation: Double, block: BlockInfo) {
145:         if blockManager?.updateCurrentBlockProgress(hitTime: Date()) == true {
146:             handleSuccess(deviation: deviation, blockConfig: block.config)
147:         } else {
148:             noteState = .correct(deviation: deviation)
149:         }
150:         combo += 1
151:     }
152:     private func handleWrongNote() {
153:         guard !isShowingError else { return }
154:         isShowingError = true
155:         lives -= 1
156:         combo = 0
157:         noteState = .wrong
158:         blockManager?.resetCurrentBlockProgress()
159:         NotificationCenter.default.post(
160:             name: NSNotification.Name("GameDataUpdated"),
161:             object: nil,
162:             userInfo: ["lives": lives, "combo": combo]
163:         )
164:         if lives <= 0 {
165:             endGame(reason: .noLives)
166:             return
167:         }
168:         DispatchQueue.main.asyncAfter(deadline: .now() + TimeConstants.errorDisplayTime) { [weak self] in
169:             self?.isShowingError = false
170:             self?.noteState = .waiting
171:         }
172:     }
173:     private func handleSuccess(deviation: Double, blockConfig: Block) {
174:         isInSuccessState = true
175:         if let currentBlock = blockManager?.getCurrentBlock() {
176:             blockHitsByStyle[currentBlock.style] = (blockHitsByStyle[currentBlock.style] ?? 0) + 1
177:             print("📊 Bloques acertados actualizados:")
178:             for (style, count) in blockHitsByStyle {
179:                 print("• \(style): \(count)")
180:             }
181:         }
182:         let accuracy = calculateAccuracy(deviation: deviation)
183:         let (baseScore, message) = calculateScore(accuracy: accuracy, blockConfig: blockConfig)
184:         let comboBonus = calculateComboBonus(baseScore: baseScore)
185:         let finalScore = baseScore + comboBonus
186:         score += finalScore
187:         checkForExtraLife(currentScore: score)
188:         let blockStyle = blockManager?.getCurrentBlock()?.style ?? "defaultBlock"
189:             objectiveTracker?.updateProgress(
190:                 score: score,
191:                 noteHit: true,
192:                 accuracy: accuracy,
193:                 blockDestroyed: blockStyle
194:             )
195:         NotificationCenter.default.post(
196:             name: NSNotification.Name("GameDataUpdated"),
197:             object: nil,
198:             userInfo: [
199:                 "lives": lives,
200:                 "combo": combo,
201:                 "noteState": "wrong"
202:             ]
203:         )
204:         NotificationCenter.default.post(
205:             name: NSNotification.Name("GameDataUpdated"),
206:             object: nil,
207:             userInfo: [
208:                 "score": score,
209:                 "lives": lives,
210:                 "combo": combo,
211:                 "noteState": "success",
212:                 "multiplier": finalScore / blockConfig.basePoints,
213:                 "message": "\(message) (\(combo)x Combo!)",
214:                 "blockDestroyed": blockStyle,
215:                 "accuracy": accuracy
216:             ]
217:         )
218:         if let primaryComplete = objectiveTracker?.checkObjectives(), primaryComplete {
219:             endGame(reason: .victory)
220:         }
221:         noteState = .success(
222:             multiplier: finalScore / blockConfig.basePoints,
223:             message: "\(message) (\(combo)x Combo!)"
224:         )
225:         DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
226:             self?.isInSuccessState = false
227:             self?.noteState = .waiting
228:         }
229:     }
230:     private func calculateAccuracy(deviation: Double) -> Double {
231:         let absDeviation = abs(deviation)
232:         if absDeviation > TimeConstants.acceptableDeviation { return 0.0 }
233:         return 1.0 - (absDeviation / TimeConstants.acceptableDeviation)
234:     }
235:     private func calculateScore(accuracy: Double, blockConfig: Block) -> (score: Int, message: String) {
236:         guard let thresholds = gameManager.gameConfig?.accuracyThresholds else {
237:             return (blockConfig.basePoints, "¡Bien!")
238:         }
239:         if accuracy >= thresholds.perfect.threshold {
240:             return (Int(Double(blockConfig.basePoints) * thresholds.perfect.multiplier), "¡Perfecto!")
241:         } else if accuracy >= thresholds.excellent.threshold {
242:             return (Int(Double(blockConfig.basePoints) * thresholds.excellent.multiplier), "¡Excelente!")
243:         } else if accuracy >= thresholds.good.threshold {
244:             return (Int(Double(blockConfig.basePoints) * thresholds.good.multiplier), "¡Bien!")
245:         }
246:         return (0, "Fallo")
247:     }
248:     private func calculateComboBonus(baseScore: Int) -> Int {
249:         let comboMultiplier = min(combo, 10)
250:         return baseScore * (comboMultiplier - 1) / 2
251:     }
252:     private func checkForExtraLife(currentScore: Int) {
253:         for threshold in scoreThresholdsForExtraLives {
254:             if currentScore >= threshold && lives < (gameManager.currentLevel?.lives.initial ?? 3) + maxExtraLives {
255:                 lives += 1
256:                 print("🎉 Vida extra ganada. Vidas actuales: \(lives)")
257:                 NotificationCenter.default.post(
258:                     name: NSNotification.Name("GameDataUpdated"),
259:                     object: nil,
260:                     userInfo: ["lives": lives]
261:                 )
262:                 if let index = scoreThresholdsForExtraLives.firstIndex(of: threshold) {
263:                     scoreThresholdsForExtraLives.remove(at: index)
264:                 }
265:                 break
266:             }
267:         }
268:     }
269:     private func resetGameState() {
270:         score = 0
271:         combo = 0
272:         isShowingError = false
273:         isInSuccessState = false
274:         noteState = .waiting
275:         gameStartTime = nil
276:         notesHitInGame = 0
277:         bestStreakInGame = 0
278:         totalAccuracyInGame = 0.0
279:         accuracyMeasurements = 0
280:         blockHitsByStyle.removeAll()
281:         print("🔄 Estado del juego reseteado.")
282:     }
283:     func checkBlocksPosition() {
284:         if blockManager?.hasBlocksBelowLimit() == true {
285:             print("🔥 Game Over: Bloques han alcanzado la zona de peligro.")
286:             endGame(reason: .blocksOverflow)
287:         }
288:     }
289:     func getLevelProgress() -> Double {
290:         return objectiveTracker?.getProgress() ?? 0
291:     }
292:     func getBlockHitsByStyle() -> [String: Int] {
293:         return blockHitsByStyle
294:     }
295: }
296: extension GameEngine: AudioControllerDelegate {
297:     func audioController(_ controller: AudioController, didDetectNote note: String, frequency: Float, amplitude: Float, deviation: Double) {
298:         print("AudioControllerDelegate - Nota detectada: \(note), Frecuencia: \(frequency)")
299:         self.checkNote(currentNote: note, deviation: deviation, isActive: true)
300:     }
301:     func audioControllerDidDetectSilence(_ controller: AudioController) {
302:         print("AudioControllerDelegate - Silencio detectado.")
303:         self.checkNote(currentNote: "-", deviation: 0, isActive: false)
304:     }
305:     func audioControllerRequiredHoldTime(_ controller: AudioController) -> TimeInterval {
306:         if let currentBlock = blockManager?.getCurrentBlock() {
307:             print("AudioControllerDelegate - Required hold time para el bloque actual: \(currentBlock.config.requiredTime) segundos")
308:             return currentBlock.config.requiredTime
309:         }
310:         print("AudioControllerDelegate - No hay bloque activo, se retorna 1.0 segundo por defecto")
311:         return 1.0
312:     }
313: }
</file>

<file path="MusicBlocks/GameLevelProcessor.swift">
  1: import Foundation
  2: struct GameConfig: Codable {
  3:     let gameVersion: String
  4:     let objectiveTypes: ObjectiveTypes
  5:     let accuracyThresholds: AccuracyThresholds
  6:     let levels: [GameLevel]
  7:     let medals: Medals
  8:     enum CodingKeys: String, CodingKey {
  9:         case gameVersion = "game_version"
 10:         case objectiveTypes = "objective_types"
 11:         case accuracyThresholds = "accuracy_thresholds"
 12:         case levels
 13:         case medals
 14:     }
 15: }
 16: struct ObjectiveTypes: Codable {
 17:     let score: ObjectiveTypeDefinition
 18:     let totalNotes: ObjectiveTypeDefinition
 19:     let noteAccuracy: ObjectiveTypeDefinition
 20:     let blockDestruction: ObjectiveTypeDefinition
 21:     let totalBlocks: ObjectiveTypeDefinition
 22:     enum CodingKeys: String, CodingKey {
 23:         case score
 24:         case totalNotes = "total_notes"
 25:         case noteAccuracy = "note_accuracy"
 26:         case blockDestruction = "block_destruction"
 27:         case totalBlocks = "total_blocks"
 28:     }
 29: }
 30: struct ObjectiveTypeDefinition: Codable {
 31:     let type: String?
 32:     let description: String
 33:     let params: ObjectiveParams
 34: }
 35: struct ObjectiveParams: Codable {
 36:     let target: Int?
 37:     let timeLimit: Int?
 38:     let minimumAccuracy: Double?
 39:     let details: [String: Int]?
 40:     enum CodingKeys: String, CodingKey {
 41:         case target
 42:         case timeLimit = "time_limit"
 43:         case minimumAccuracy = "minimum_accuracy"
 44:         case details
 45:     }
 46: }
 47: struct AccuracyThresholds: Codable {
 48:     let perfect: AccuracyLevel
 49:     let excellent: AccuracyLevel
 50:     let good: AccuracyLevel
 51: }
 52: struct AccuracyLevel: Codable {
 53:     let threshold: Double
 54:     let multiplier: Double
 55: }
 56: struct GameLevel: Codable {
 57:     let levelId: Int
 58:     let name: String
 59:     let maxScore: Int
 60:     let allowedStyles: [String]
 61:     let fallingSpeed: FallingSpeed
 62:     let lives: Lives
 63:     let objectives: Objectives
 64:     let blocks: [String: Block]
 65:     var requiredScore: Int {
 66:             if objectives.primary.type == "score" {
 67:                 return objectives.primary.target ?? 0
 68:             }
 69:             return blocks.values.reduce(0) { $0 + ($1.basePoints * 10) }
 70:         }
 71:     enum CodingKeys: String, CodingKey {
 72:         case levelId = "level_id"
 73:         case name
 74:         case maxScore = "max_score"
 75:         case allowedStyles = "allowed_styles"
 76:         case fallingSpeed = "falling_speed"
 77:         case lives
 78:         case objectives
 79:         case blocks
 80:     }
 81: }
 82: struct FallingSpeed: Codable {
 83:     let initial: Double
 84:     let increment: Double
 85: }
 86: struct Lives: Codable {
 87:     let initial: Int
 88:     let extraLives: ExtraLives
 89:     enum CodingKeys: String, CodingKey {
 90:         case initial
 91:         case extraLives = "extra_lives"
 92:     }
 93: }
 94: struct ExtraLives: Codable {
 95:     let scoreThresholds: [Int]
 96:     let maxExtra: Int
 97:     enum CodingKeys: String, CodingKey {
 98:         case scoreThresholds = "score_thresholds"
 99:         case maxExtra = "max_extra"
100:     }
101: }
102: struct Objectives: Codable {
103:     let primary: Objective
104: }
105: struct Objective: Codable {
106:     let type: String
107:     let target: Int?
108:     let timeLimit: Int?
109:     let minimumAccuracy: Double?
110:     let details: [String: Int]?
111:     enum CodingKeys: String, CodingKey {
112:         case type
113:         case target
114:         case timeLimit = "time_limit"
115:         case minimumAccuracy = "minimum_accuracy"
116:         case details
117:     }
118: }
119: struct Block: Codable {
120:     let notes: [String]
121:     let requiredHits: Int
122:     let requiredTime: Double
123:     let style: String
124:     let weight: Double
125:     let basePoints: Int
126:     enum CodingKeys: String, CodingKey {
127:         case notes
128:         case requiredHits
129:         case requiredTime
130:         case style
131:         case weight
132:         case basePoints = "base_points"
133:     }
134: }
135: struct Medals: Codable {
136:     let notesHit: [Medal]
137:     let playTime: [Medal]
138:     let streaks: [Medal]
139:     let perfectTuning: [Medal]
140:     enum CodingKeys: String, CodingKey {
141:         case notesHit = "notes_hit"
142:         case playTime = "play_time"
143:         case streaks
144:         case perfectTuning = "perfect_tuning"
145:     }
146: }
147: struct Medal: Codable {
148:     let name: String
149:     let requirement: String
150:     let image: String
151:     let objective: MedalObjective
152: }
153: struct MedalObjective: Codable {
154:     let type: String
155:     let target: Int
156:     let lifetime: Bool?
157:     let resetOnFail: Bool?
158:     let accuracy: Double?
159:     enum CodingKeys: String, CodingKey {
160:         case type
161:         case target
162:         case lifetime
163:         case resetOnFail = "reset_on_fail"
164:         case accuracy
165:     }
166: }
167: class GameLevelProcessor {
168:     static func processGameLevelsJSON(_ jsonString: String) -> GameConfig? {
169:         var cleanedJSON = removeMultilineComments(from: jsonString)
170:         cleanedJSON = removeSingleLineComments(from: cleanedJSON)
171:         if let jsonData = cleanedJSON.data(using: .utf8) {
172:             do {
173:                 let decoder = JSONDecoder()
174:                 let gameConfig = try decoder.decode(GameConfig.self, from: jsonData)
175:                 return gameConfig
176:             } catch {
177:                 print("Error decoding JSON: \(error)")
178:                 print("Problema en: \(error.localizedDescription)")
179:                 if let decodingError = error as? DecodingError {
180:                     switch decodingError {
181:                     case .dataCorrupted(let context):
182:                         print("Data corrupted: \(context)")
183:                     case .keyNotFound(let key, let context):
184:                         print("Key not found: \(key) in \(context)")
185:                     case .typeMismatch(let type, let context):
186:                         print("Type mismatch: \(type) in \(context)")
187:                     case .valueNotFound(let type, let context):
188:                         print("Value not found: \(type) in \(context)")
189:                     @unknown default:
190:                         print("Unknown decoding error")
191:                     }
192:                 }
193:                 print("JSON limpio que causó el error:")
194:                 print(cleanedJSON)
195:             }
196:         }
197:         return nil
198:     }
199:     static func loadGameLevelsFromFile() -> GameConfig? {
200:         guard let path = Bundle.main.path(forResource: "game_levels", ofType: "json") else {
201:             print("No se pudo encontrar el archivo game_levels.json")
202:             return nil
203:         }
204:         do {
205:             let jsonString = try String(contentsOfFile: path, encoding: .utf8)
206:             return processGameLevelsJSON(jsonString)
207:         } catch {
208:             print("Error al leer el archivo game_levels.json: \(error)")
209:             return nil
210:         }
211:     }
212:     static func saveGameConfigToFile(_ gameConfig: GameConfig, fileName: String = "game_levels") -> Bool {
213:         do {
214:             let encoder = JSONEncoder()
215:             encoder.outputFormatting = .prettyPrinted
216:             let jsonData = try encoder.encode(gameConfig)
217:             if let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {
218:                 let fileURL = documentsDirectory.appendingPathComponent("\(fileName).json")
219:                 try jsonData.write(to: fileURL)
220:                 return true
221:             }
222:         } catch {
223:             print("Error al guardar la configuración: \(error)")
224:         }
225:         return false
226:     }
227:     private static func removeMultilineComments(from input: String) -> String {
228:         var result = ""
229:         var inMultilineComment = false
230:         var i = input.startIndex
231:         while i < input.endIndex {
232:             // Detectar inicio de comentario multilínea
233:             if i < input.index(before: input.endIndex) &&
234:                input[i] == "/" && input[input.index(after: i)] == "*" {
235:                 inMultilineComment = true
236:                 i = input.index(after: i)  // Saltar el "/"
237:             }
238:             // Detectar fin de comentario multilínea
239:             else if inMultilineComment && i < input.index(before: input.endIndex) &&
240:                     input[i] == "*" && input[input.index(after: i)] == "/" {
241:                 inMultilineComment = false
242:                 i = input.index(i, offsetBy: 2)  // Saltar "*/"
243:                 continue
244:             }
245:             // Si no estamos en un comentario, añadir el caracter al resultado
246:             if !inMultilineComment {
247:                 result.append(input[i])
248:             }
249:             i = input.index(after: i)
250:         }
251:         return result
252:     }
253:     private static func removeSingleLineComments(from input: String) -> String {
254:         var result = ""
255:         var inString = false
256:         var inSingleLineComment = false
257:         var i = input.startIndex
258:         while i < input.endIndex {
259:             let currentChar = input[i]
260:             // Manejar inicio/fin de cadenas de texto
261:             if currentChar == "\"" {
262:                 // Verificar que la comilla no esté escapada
263:                 if i > input.startIndex && input[input.index(before: i)] != "\\" {
264:                     inString = !inString
265:                 }
266:             }
267:             // Detectar inicio de comentario de una línea (solo fuera de cadenas de texto)
268:             if !inString && i < input.index(before: input.endIndex) &&
269:                currentChar == "/" && input[input.index(after: i)] == "/" {
270:                 inSingleLineComment = true
271:             }
272:             // Fin de línea termina un comentario de una línea
273:             if inSingleLineComment && (currentChar == "\n" || currentChar == "\r") {
274:                 inSingleLineComment = false
275:                 result.append(currentChar)
276:             }
277:             else if !inSingleLineComment {
278:                 result.append(currentChar)
279:             }
280:             i = input.index(after: i)
281:         }
282:         return result
283:     }
284:     static func getLevels(from gameConfig: GameConfig) -> [GameLevel] {
285:         return gameConfig.levels
286:     }
287:     static func getObjectiveTypes(from gameConfig: GameConfig) -> ObjectiveTypes {
288:         return gameConfig.objectiveTypes
289:     }
290:     static func getAccuracyThresholds(from gameConfig: GameConfig) -> AccuracyThresholds {
291:         return gameConfig.accuracyThresholds
292:     }
293:     static func getMedals(from gameConfig: GameConfig) -> Medals {
294:         return gameConfig.medals
295:     }
296:     static func getLevel(from gameConfig: GameConfig, withId id: Int) -> GameLevel? {
297:         if let level = gameConfig.levels.first(where: { $0.levelId == id }) {
298:             print("Nivel \(id) encontrado:")
299:             print("- Estilos permitidos: \(level.allowedStyles)")
300:             print("- Bloques configurados:")
301:             for (style, block) in level.blocks {
302:                 print("  • \(style):")
303:                 print("    - Notas: \(block.notes)")
304:                 print("    - Estilo: \(block.style)")
305:                 print("    - Peso: \(block.weight)")
306:             }
307:             return level
308:         }
309:         return nil
310:     }
311:     static func getBlocks(from level: GameLevel) -> [String: Block] {
312:         return level.blocks
313:     }
314:     static func fixJSONStructure(_ jsonString: String) -> String? {
315:         var cleanedJSON = removeMultilineComments(from: jsonString)
316:         cleanedJSON = removeSingleLineComments(from: cleanedJSON)
317:         return cleanedJSON
318:     }
319: }
</file>

<file path="MusicBlocks/GameManager.swift">
  1: import Foundation
  2: class GameManager {
  3:     static let shared = GameManager()
  4:     private(set) var gameConfig: GameConfig?
  5:     private(set) var currentLevel: GameLevel?
  6:     private var userProfile: UserProfile
  7:     private(set) var totalGamesPlayed: Int = 0
  8:     private(set) var highScores: [Int: Int] = [:]
  9:     private(set) var lastPlayedLevel: Int = 0
 10:     private struct Constants {
 11:         static let maxUnlockedLevel = 10
 12:         static let tutorialLevelId = 0
 13:         static let defaultLives = 3
 14:     }
 15:     private init() {
 16:         userProfile = UserProfile.load()
 17:         loadGameConfig()
 18:         loadStatistics()
 19:     }
 20:     private func loadGameConfig() {
 21:         if let config = GameLevelProcessor.loadGameLevelsFromFile() {
 22:             print("✅ Configuración del juego cargada")
 23:             print("📊 Número de niveles: \(config.levels.count)")
 24:             gameConfig = config
 25:         } else {
 26:             print("❌ Error al cargar la configuración del juego")
 27:         }
 28:     }
 29:     private func loadStatistics() {
 30:         totalGamesPlayed = userProfile.statistics.totalGamesPlayed
 31:         lastPlayedLevel = userProfile.statistics.currentLevel
 32:     }
 33:     func loadLevel(_ levelId: Int) -> Bool {
 34:         guard let config = gameConfig else {
 35:             print("❌ Error: No se pudo cargar la configuración del juego")
 36:             return false
 37:         }
 38:         if !isLevelUnlocked(levelId) {
 39:             print("🔒 Nivel \(levelId) bloqueado")
 40:             return false
 41:         }
 42:         if let level = GameLevelProcessor.getLevel(from: config, withId: levelId) {
 43:             currentLevel = level
 44:             lastPlayedLevel = levelId
 45:             userProfile.statistics.currentLevel = levelId
 46:             userProfile.save()
 47:             print("✅ Nivel \(levelId) cargado: \(level.name)")
 48:             return true
 49:         }
 50:         if let tutorialLevel = GameLevelProcessor.getLevel(from: config, withId: Constants.tutorialLevelId) {
 51:             currentLevel = tutorialLevel
 52:             print("ℹ️ Cargando tutorial por defecto")
 53:             return true
 54:         }
 55:         print("❌ Error: No se pudo cargar ningún nivel")
 56:         return false
 57:     }
 58:     func isLevelUnlocked(_ levelId: Int) -> Bool {
 59:         if levelId == Constants.tutorialLevelId { return true }
 60:         let previousLevelCompleted = highScores[levelId - 1] != nil
 61:         return levelId <= Constants.maxUnlockedLevel && previousLevelCompleted
 62:     }
 63:     func updateGameStatistics(levelId: Int, score: Int, completed: Bool) {
 64:         totalGamesPlayed += 1
 65:         if let currentHighScore = highScores[levelId] {
 66:             if score > currentHighScore {
 67:                 highScores[levelId] = score
 68:                 print("🏆 Nuevo récord en nivel \(levelId): \(score)")
 69:             }
 70:         } else {
 71:             highScores[levelId] = score
 72:             print("🎮 Primera puntuación en nivel \(levelId): \(score)")
 73:         }
 74:         userProfile.updateStatistics(
 75:             score: score,
 76:             accuracy: calculateAccuracyForLevel(score),
 77:             levelCompleted: completed,
 78:             isPerfect: isLevelPerfect(score),
 79:             playTime: calculatePlayTime()
 80:         )
 81:         if completed {
 82:             if levelId >= userProfile.statistics.currentLevel {
 83:                 userProfile.statistics.currentLevel = levelId + 1
 84:             }
 85:         }
 86:         userProfile.save()
 87:     }
 88:     private func calculateAccuracyForLevel(_ score: Int) -> Double {
 89:         guard let level = currentLevel, level.requiredScore > 0 else { return 0.0 }
 90:         return Double(score) / Double(level.requiredScore)
 91:     }
 92:     private func isLevelPerfect(_ score: Int) -> Bool {
 93:         guard let level = currentLevel else { return false }
 94:         let perfectThreshold = level.requiredScore * 3 / 2
 95:         return score >= perfectThreshold
 96:     }
 97:     private func calculatePlayTime() -> TimeInterval {
 98:         return 60.0
 99:     }
100:     func getLevelInfo(_ levelId: Int) -> (name: String, highScore: Int)? {
101:         guard let level = gameConfig?.levels.first(where: { level in
102:             level.levelId == levelId
103:         }) else {
104:             return nil
105:         }
106:         return (level.name, highScores[levelId] ?? 0)
107:     }
108:     func getNextUnlockedLevel() -> Int? {
109:         let currentLevel = userProfile.statistics.currentLevel
110:         if !hasCompletedLevel(currentLevel) {
111:             return currentLevel
112:         }
113:         return nil
114:     }
115:     func hasCompletedLevel(_ levelId: Int) -> Bool {
116:         guard let level = gameConfig?.levels.first(where: { level in
117:             level.levelId == levelId
118:         }) else {
119:             return false
120:         }
121:         let currentScore = highScores[levelId] ?? 0
122:         return currentScore >= level.requiredScore
123:     }
124:     var accuracyThresholds: AccuracyThresholds? {
125:         gameConfig?.accuracyThresholds
126:     }
127:     var availableLevels: [GameLevel] {
128:         gameConfig?.levels ?? []
129:     }
130:     var currentLevelBlocks: [String: Block]? {
131:         currentLevel?.blocks
132:     }
133:     var currentLevelSpeed: FallingSpeed? {
134:         currentLevel?.fallingSpeed
135:     }
136:     var currentLevelStyles: [String]? {
137:         currentLevel?.allowedStyles
138:     }
139:     func isValidStyle(_ style: String) -> Bool {
140:         currentLevel?.allowedStyles.contains(style) ?? false
141:     }
142:     func getBlockConfig(for style: String) -> Block? {
143:         currentLevel?.blocks[style]
144:     }
145:     func resetProgress() {
146:         userProfile = UserProfile()
147:         userProfile.save()
148:         loadStatistics()
149:     }
150:     func getProgressSummary() -> String {
151:         """
152:         🎮 Partidas jugadas: \(totalGamesPlayed)
153:         🏆 Niveles completados: \(highScores.count)
154:         📊 Último nivel jugado: \(lastPlayedLevel)
155:         """
156:     }
157: }
</file>

<file path="MusicBlocks/GameTypes.swift">
 1: import Foundation
 2: import SpriteKit
 3: struct BlockInfo {
 4:     let node: SKNode
 5:     let note: String
 6:     let style: String
 7:     let config: Block
 8:     let requiredHits: Int
 9:     let requiredTime: TimeInterval
10:     var currentHits: Int = 0
11:     var holdStartTime: Date?
12: }
13: enum GameState {
14:     case countdown
15:     case playing
16:     case paused
17:     case gameOver(reason: GameOverReason)
18: }
19: enum GameOverReason: String {
20:     case noLives = "noLives"
21:     case blocksOverflow = "blocksOverflow"
22:     case victory = "victory"
23:     var message: String {
24:         switch self {
25:         case .noLives:
26:             return "¡Te has quedado sin vidas!"
27:         case .blocksOverflow:
28:             return "¡Los bloques han llegado demasiado abajo!"
29:         case .victory:
30:             return "¡Nivel completado!"
31:         }
32:     }
33:     var isVictory: Bool {
34:         if case .victory = self {
35:             return true
36:         }
37:         return false
38:     }
39: }
40: enum NoteStateType: String {
41:     case waiting = "waiting"
42:     case correct = "correct"
43:     case wrong = "wrong"
44:     case success = "success"
45: }
46: enum NoteState: Equatable {
47:     case waiting
48:     case correct(deviation: Double)
49:     case wrong
50:     case success(multiplier: Int, message: String)
51: }
</file>

<file path="MusicBlocks/GameUIManager.swift">
  1: import SpriteKit
  2: import UIKit
  3: class GameUIManager {
  4:     private weak var scene: SKScene?
  5:     private weak var mainAreaNode: SKNode?
  6:     private var backgroundPattern: BackgroundPatternNode!
  7:     var leftTopBarNode: TopBar?
  8:     var rightTopBarNode: TopBar?
  9:     private var currentOverlay: GameOverlayNode?
 10:     private var objectiveTracker: LevelObjectiveTracker?
 11:     var stabilityIndicatorNode: StabilityIndicatorNode!
 12:     var stabilityCounterNode: StabilityCounterNode!
 13:     var tuningIndicatorNode: TuningIndicatorNode!
 14:     var detectedNoteCounterNode: DetectedNoteCounterNode!
 15:     private var mainAreaHeight: CGFloat = 0
 16:     private var mainAreaWidth: CGFloat = 0
 17:     private struct Layout {
 18:         static let margins = UIEdgeInsets(
 19:             top: 6,
 20:             left: 6,
 21:             bottom: UIScreen.main.bounds.height * 0.05,
 22:             right: 6
 23:         )
 24:         static let cornerRadius: CGFloat = 15
 25:         static let verticalSpacing: CGFloat = 5
 26:         static let topBarHeightRatio: CGFloat = 0.08
 27:         static let mainAreaHeightRatio: CGFloat = 0.74
 28:         static let sideBarWidthRatio: CGFloat = 0.07
 29:         static let mainAreaWidthRatio: CGFloat = 0.75
 30:         static let sideBarHeightRatio: CGFloat = 0.4
 31:         static let topBarWidthRatio: CGFloat = 0.490
 32:         static let topBarSpacing: CGFloat = 4
 33:         static let shadowRadius: CGFloat = 8.0
 34:         static let shadowOpacity: Float = 0.8
 35:         static let shadowOffset = CGPoint(x: 0, y: -2)
 36:         static let containerAlpha: CGFloat = 0.95
 37:     }
 38:     init(scene: SKScene) {
 39:         self.scene = scene
 40:         setupUI()
 41:     }
 42:     func setupUI() {
 43:         setupBackground()
 44:         setupLayout()
 45:     }
 46:     func updateUI(score: Int, lives: Int) {
 47:         leftTopBarNode?.updateScore(score)
 48:         leftTopBarNode?.updateLives(lives)
 49:         if let tracker = objectiveTracker {
 50:             tracker.updateProgress(score: score)
 51:             let progress = tracker.getCurrentProgress()
 52:             rightTopBarNode?.updateObjectiveInfo(with: progress)
 53:         }
 54:     }
 55:     private func setupBackground() {
 56:         guard let scene = scene else { return }
 57:         backgroundPattern = BackgroundPatternNode(size: scene.size)
 58:         backgroundPattern.zPosition = -10
 59:         scene.addChild(backgroundPattern)
 60:     }
 61:     private func setupLayout() {
 62:         guard let scene = scene else { return }
 63:         let safeWidth = scene.size.width - Layout.margins.left - Layout.margins.right
 64:         let safeHeight = scene.size.height - Layout.margins.top - Layout.margins.bottom
 65:         let topBarHeight = safeHeight * Layout.topBarHeightRatio
 66:         let mainAreaHeight = safeHeight * Layout.mainAreaHeightRatio
 67:         let mainAreaWidth = safeWidth * Layout.mainAreaWidthRatio
 68:         let sideBarWidth = safeWidth * Layout.sideBarWidthRatio
 69:         let sideBarHeight = safeHeight * Layout.sideBarHeightRatio
 70:         setupTopBars(width: safeWidth, height: topBarHeight)
 71:         setupMainArea(width: mainAreaWidth, height: mainAreaHeight, topBarHeight: topBarHeight)
 72:         setupSideBars(width: sideBarWidth, height: sideBarHeight, topBarHeight: topBarHeight)
 73:     }
 74:     private func setupTopBars(width: CGFloat, height: CGFloat) {
 75:         guard let scene = scene else { return }
 76:         let safeAreaTop = (scene.view?.safeAreaInsets.top ?? 0)
 77:         let topBarWidth = width * Layout.topBarWidthRatio
 78:         let yPosition = scene.size.height - safeAreaTop - height / 2
 79:         let leftXPosition = Layout.margins.left + topBarWidth/2
 80:         let rightXPosition = scene.size.width - Layout.margins.right - topBarWidth/2
 81:         leftTopBarNode = TopBar.create(
 82:             width: topBarWidth,
 83:             height: height,
 84:             position: CGPoint(x: leftXPosition, y: yPosition),
 85:             type: .main
 86:         )
 87:         rightTopBarNode = TopBar.create(
 88:             width: topBarWidth,
 89:             height: height,
 90:             position: CGPoint(x: rightXPosition, y: yPosition),
 91:             type: .objectives
 92:         )
 93:         if let leftBar = leftTopBarNode, let rightBar = rightTopBarNode {
 94:             leftBar.zPosition = 100
 95:             rightBar.zPosition = 100
 96:             if let currentLevel = GameManager.shared.currentLevel {
 97:                 objectiveTracker = LevelObjectiveTracker(level: currentLevel)
 98:                 if let tracker = objectiveTracker {
 99:                     leftBar.configure(withLevel: currentLevel, objectiveTracker: tracker)
100:                     rightBar.configure(withLevel: currentLevel, objectiveTracker: tracker)
101:                     leftBar.updateLives(currentLevel.lives.initial)
102:                     leftBar.updateScore(0)
103:                 }
104:             }
105:             scene.addChild(leftBar)
106:             scene.addChild(rightBar)
107:         }
108:     }
109:     private func setupMainArea(width: CGFloat, height: CGFloat, topBarHeight: CGFloat) {
110:         guard let scene = scene else { return }
111:         mainAreaWidth = width
112:         mainAreaHeight = height
113:         let containerNode = SKNode()
114:         containerNode.position = CGPoint(
115:             x: scene.size.width/2,
116:             y: scene.size.height/2 - Layout.verticalSpacing
117:         )
118:         containerNode.zPosition = 1
119:         addDangerZone(to: containerNode, width: width, height: height)
120:         let mainContent = SKNode()
121:         mainContent.zPosition = 2
122:         containerNode.addChild(mainContent)
123:         mainAreaNode = mainContent
124:         scene.addChild(containerNode)
125:     }
126:     private func addDangerZone(to container: SKNode, width: CGFloat, height: CGFloat) {
127:         guard let scene = scene else { return }
128:         let dangerZone = SKNode()
129:         dangerZone.zPosition = 1
130:         let bottomLimit = -(height/2)
131:         let warningArea = SKShapeNode(rect: CGRect(
132:             x: -scene.size.width/2,
133:             y: bottomLimit - scene.size.height,
134:             width: scene.size.width,
135:             height: scene.size.height
136:         ))
137:         warningArea.fillColor = UIColor.red
138:         warningArea.strokeColor = UIColor.clear
139:         warningArea.alpha = 0.15
140:         let limitLine = SKShapeNode(rect: CGRect(
141:             x: -scene.size.width/2,
142:             y: bottomLimit,
143:             width: scene.size.width,
144:             height: 2
145:         ))
146:         limitLine.fillColor = UIColor.red
147:         limitLine.strokeColor = UIColor.clear
148:         limitLine.alpha = 0.8
149:         let fadeSequence = SKAction.sequence([
150:             SKAction.fadeAlpha(to: 0.3, duration: 0.5),
151:             SKAction.fadeAlpha(to: 0.8, duration: 0.5)
152:         ])
153:         limitLine.run(SKAction.repeatForever(fadeSequence))
154:         dangerZone.addChild(warningArea)
155:         dangerZone.addChild(limitLine)
156:         container.addChild(dangerZone)
157:     }
158:     private func createDangerMarker(size: CGSize) -> SKShapeNode {
159:         let path = CGMutablePath()
160:         path.move(to: CGPoint(x: 0, y: 0))
161:         path.addLine(to: CGPoint(x: size.width, y: 0))
162:         path.addLine(to: CGPoint(x: size.width, y: -size.height))
163:         path.addLine(to: CGPoint(x: 0, y: -size.height))
164:         path.closeSubpath()
165:         let marker = SKShapeNode(path: path)
166:         marker.fillColor = UIColor.red
167:         marker.strokeColor = UIColor.clear
168:         marker.alpha = 0.8
169:         let fadeSequence = SKAction.sequence([
170:             SKAction.fadeAlpha(to: 0.3, duration: 0.5),
171:             SKAction.fadeAlpha(to: 0.8, duration: 0.5)
172:         ])
173:         marker.run(SKAction.repeatForever(fadeSequence))
174:         return marker
175:     }
176:     private func setupSideBars(width: CGFloat, height: CGFloat, topBarHeight: CGFloat) {
177:         setupLeftSideBar(width: width, height: height)
178:         setupRightSideBar(width: width, height: height)
179:     }
180:     private func setupLeftSideBar(width: CGFloat, height: CGFloat) {
181:         guard let scene = scene else { return }
182:         let position = CGPoint(
183:             x: Layout.margins.left + width/2 + 10,
184:             y: scene.size.height/2 - (Layout.verticalSpacing/2)
185:         )
186:         let leftBar = SKNode()
187:         leftBar.position = position
188:         leftBar.zPosition = 1
189:         leftBar.applyContainerStyle(size: CGSize(width: width, height: height))
190:         scene.addChild(leftBar)
191:         setupStabilityIndicators(in: leftBar, at: position, width: width, height: height)
192:     }
193:     private func setupRightSideBar(width: CGFloat, height: CGFloat) {
194:         guard let scene = scene else { return }
195:         let position = CGPoint(
196:             x: scene.size.width - Layout.margins.right - width/2 - 10,
197:             y: scene.size.height/2 - (Layout.verticalSpacing/2)
198:         )
199:         let rightBar = SKNode()
200:         rightBar.position = position
201:         rightBar.zPosition = 1
202:         rightBar.applyContainerStyle(size: CGSize(width: width, height: height))
203:         scene.addChild(rightBar)
204:         setupTuningIndicators(in: rightBar, at: position, width: width, height: height)
205:     }
206:     private func setupStabilityIndicators(in container: SKNode, at position: CGPoint, width: CGFloat, height: CGFloat) {
207:         guard let scene = scene else { return }
208:         stabilityIndicatorNode = StabilityIndicatorNode(size: CGSize(width: width * 0.6, height: height * 0.9))
209:         stabilityIndicatorNode.position = .zero
210:         stabilityIndicatorNode.zPosition = 10
211:         container.addChild(stabilityIndicatorNode)
212:         let counterYPosition = position.y - height/2 - 30
213:         stabilityCounterNode = StabilityCounterNode(size: CGSize(width: width * 2.0, height: 30))
214:         stabilityCounterNode.position = CGPoint(x: position.x, y: counterYPosition)
215:         stabilityCounterNode.zPosition = 10
216:         scene.addChild(stabilityCounterNode)
217:     }
218:     private func setupTuningIndicators(in container: SKNode, at position: CGPoint, width: CGFloat, height: CGFloat) {
219:         guard let scene = scene else { return }
220:         tuningIndicatorNode = TuningIndicatorNode(size: CGSize(width: width * 0.6, height: height * 0.9))
221:         tuningIndicatorNode.position = .zero
222:         tuningIndicatorNode.zPosition = 10
223:         container.addChild(tuningIndicatorNode)
224:         let counterYPosition = position.y - height/2 - 30
225:         detectedNoteCounterNode = DetectedNoteCounterNode(size: CGSize(width: width * 2.0, height: 30))
226:         detectedNoteCounterNode.position = CGPoint(x: position.x, y: counterYPosition)
227:         detectedNoteCounterNode.zPosition = 10
228:         scene.addChild(detectedNoteCounterNode)
229:     }
230:     func showLevelStartOverlay(for level: GameLevel, completion: @escaping () -> Void) {
231:         guard let scene = scene else { return }
232:         currentOverlay?.removeFromParent()
233:         updateUI(score: 0, lives: level.lives.initial)
234:         let overlaySize = CGSize(width: scene.size.width * 0.7, height: scene.size.height * 0.45)
235:         let overlay = LevelStartOverlayNode(
236:             size: overlaySize,
237:             levelId: level.levelId,
238:             levelName: level.name,
239:             startAction: completion
240:         )
241:         scene.addChild(overlay)
242:         currentOverlay = overlay
243:         overlay.show(in: scene, overlayPosition: .center)
244:     }
245:     func showSuccessOverlay(multiplier: Int, message: String) {
246:         guard let scene = scene else { return }
247:         currentOverlay?.removeFromParent()
248:         let overlaySize = CGSize(width: 350, height: 60)
249:         let overlay = SuccessOverlayNode(
250:             size: overlaySize,
251:             multiplier: multiplier,
252:             message: message
253:         )
254:         scene.addChild(overlay)
255:         currentOverlay = overlay
256:         overlay.show(in: scene, overlayPosition: .bottom)
257:         DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak overlay] in
258:             overlay?.hide()
259:         }
260:     }
261:     func showFailureOverlay() {
262:         guard let scene = scene else { return }
263:         currentOverlay?.removeFromParent()
264:         let overlaySize = CGSize(width: 350, height: 60)
265:         let overlay = FailureOverlayNode(size: overlaySize)
266:         scene.addChild(overlay)
267:         currentOverlay = overlay
268:         overlay.show(in: scene, overlayPosition: .bottom)
269:         DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak overlay] in
270:             overlay?.hide()
271:         }
272:     }
273:     func showGameOverOverlay(score: Int, message: String, isVictory: Bool, onRestart: @escaping () -> Void) {
274:         guard let scene = scene else { return }
275:         currentOverlay?.removeFromParent()
276:         let overlaySize = CGSize(width: 400, height: 300)
277:         let overlay = GameOverOverlayNode(
278:             size: overlaySize,
279:             score: score,
280:             message: message,
281:             isVictory: isVictory,
282:             restartAction: onRestart
283:         )
284:         scene.addChild(overlay)
285:         currentOverlay = overlay
286:         overlay.show(in: scene, overlayPosition: .center)
287:     }
288:     func getMainAreaNode() -> SKNode? {
289:         return mainAreaNode
290:     }
291:     func getMainAreaDimensions() -> (width: CGFloat, height: CGFloat) {
292:         return (mainAreaWidth, mainAreaHeight)
293:     }
294:     func updateObjectiveProgress(
295:         score: Int? = nil,
296:         noteHit: Bool? = nil,
297:         accuracy: Double? = nil,
298:         blockDestroyed: String? = nil,
299:         deltaTime: TimeInterval? = nil
300:     ) {
301:         objectiveTracker?.updateProgress(
302:             score: score,
303:             noteHit: noteHit,
304:             accuracy: accuracy,
305:             blockDestroyed: blockDestroyed,
306:             deltaTime: deltaTime
307:         )
308:     }
309:     public func configureTopBars(withLevel level: GameLevel, objectiveTracker: LevelObjectiveTracker) {
310:         leftTopBarNode?.configure(withLevel: level, objectiveTracker: objectiveTracker)
311:         rightTopBarNode?.configure(withLevel: level, objectiveTracker: objectiveTracker)
312:     }
313: }
</file>

<file path="MusicBlocks/LevelObjectiveTracker.swift">
 1: import Foundation
 2: class LevelObjectiveTracker {
 3:     private let primaryObjective: Objective
 4:     private var currentProgress: ObjectiveProgress
 5:     init(level: GameLevel) {
 6:         self.primaryObjective = level.objectives.primary
 7:         self.currentProgress = ObjectiveProgress()
 8:         for style in level.allowedStyles {
 9:             currentProgress.blocksByType[style] = 0
10:         }
11:     }
12:     func getPrimaryObjective() -> Objective {
13:         return primaryObjective
14:     }
15:     func updateProgress(score: Int? = nil,
16:                        noteHit: Bool? = nil,
17:                        accuracy: Double? = nil,
18:                        blockDestroyed: String? = nil,
19:                        deltaTime: TimeInterval? = nil) {
20:         if let score = score {
21:             currentProgress.score = score
22:         }
23:         if let noteHit = noteHit, noteHit {
24:             currentProgress.notesHit += 1
25:         }
26:         if let accuracy = accuracy {
27:             currentProgress.accuracySum += accuracy
28:             currentProgress.accuracyCount += 1
29:         }
30:         if let blockType = blockDestroyed {
31:             currentProgress.blocksByType[blockType, default: 0] += 1
32:             currentProgress.totalBlocksDestroyed += 1
33:         }
34:         if let deltaTime = deltaTime {
35:             currentProgress.timeElapsed += deltaTime
36:         }
37:             NotificationCenter.default.post(
38:                 name: NSNotification.Name("GameDataUpdated"),
39:                 object: nil,
40:                 userInfo: [:]
41:             )
42:     }
43:     func checkObjectives() -> Bool {
44:             return checkObjective(primaryObjective)
45:         }
46:         private func checkObjective(_ objective: Objective) -> Bool {
47:             switch objective.type {
48:             case "score":
49:                 return currentProgress.score >= (objective.target ?? 0)
50:             case "total_notes":
51:                 return currentProgress.notesHit >= (objective.target ?? 0)
52:             case "note_accuracy":
53:                 return currentProgress.notesHit >= (objective.target ?? 0) &&
54:                        currentProgress.averageAccuracy >= (objective.minimumAccuracy ?? 0)
55:             case "block_destruction":
56:                 guard let details = objective.details else { return false }
57:                 return details.allSatisfy { blockType, required in
58:                     currentProgress.blocksByType[blockType, default: 0] >= required
59:                 }
60:             case "total_blocks":
61:                 return currentProgress.totalBlocksDestroyed >= (objective.target ?? 0)
62:             default:
63:                 return false
64:             }
65:         }
66:     func getProgress() -> Double {
67:             return calculateProgress(for: primaryObjective)
68:         }
69:         func getCurrentProgress() -> ObjectiveProgress {
70:             return currentProgress
71:         }
72:         private func calculateProgress(for objective: Objective) -> Double {
73:             switch objective.type {
74:             case "score":
75:                 let target = Double(objective.target ?? 1)
76:                 return min(Double(currentProgress.score) / target, 1.0)
77:             case "total_notes":
78:                 let target = Double(objective.target ?? 1)
79:                 return min(Double(currentProgress.notesHit) / target, 1.0)
80:             case "note_accuracy":
81:                 let noteProgress = Double(currentProgress.notesHit) / Double(objective.target ?? 1)
82:                 let accuracyProgress = currentProgress.averageAccuracy / (objective.minimumAccuracy ?? 1.0)
83:                 return min(min(noteProgress, accuracyProgress), 1.0)
84:             case "block_destruction":
85:                 guard let details = objective.details else { return 0 }
86:                 let progressByType = details.map { blockType, required in
87:                     Double(currentProgress.blocksByType[blockType, default: 0]) / Double(required)
88:                 }
89:                 return min(progressByType.min() ?? 0, 1.0)
90:             case "total_blocks":
91:                 let target = Double(objective.target ?? 1)
92:                 return min(Double(currentProgress.totalBlocksDestroyed) / target, 1.0)
93:             default:
94:                 return 0
95:             }
96:         }
97:     }
</file>

<file path="MusicBlocks/MusicBlocksScene.swift">
  1: import SpriteKit
  2: import UIKit
  3: import SwiftUI
  4: class MusicBlocksScene: SKScene {
  5:     @Environment(\.screenSize) var screenSize
  6:     private let audioController = AudioController.sharedInstance
  7:     private let gameManager = GameManager.shared
  8:     private var gameEngine: GameEngine!
  9:     private var blocksManager: BlocksManager!
 10:     private var uiManager: GameUIManager!
 11:     private var objectiveTracker: LevelObjectiveTracker?
 12:     private var lastUpdateTime: TimeInterval = 0
 13:     private var lastTimeUpdate: TimeInterval = 0
 14:     private let timeUpdateInterval: TimeInterval = 1.0
 15:     override func didMove(to view: SKView) {
 16:         super.didMove(to: view)
 17:         print("🎬 Scene did move to view")
 18:         setupManagers()
 19:         setupGame()
 20:         NotificationCenter.default.addObserver(
 21:             self,
 22:             selector: #selector(handleGameDataUpdate(_:)),
 23:             name: NSNotification.Name("GameDataUpdated"),
 24:             object: nil
 25:         )
 26:     }
 27:     override func willMove(from view: SKView) {
 28:         super.willMove(from: view)
 29:         print("⏹️ Deteniendo juego")
 30:         audioController.stop()
 31:         blocksManager.stopBlockGeneration()
 32:         NotificationCenter.default.removeObserver(self)
 33:     }
 34:     @objc func handleGameDataUpdate(_ notification: Notification) {
 35:         let userData = notification.userInfo ?? [:]
 36:         let score = userData["score"] as? Int ?? gameEngine.score
 37:         let lives = userData["lives"] as? Int ?? gameEngine.lives
 38:         uiManager.updateUI(score: score, lives: lives)
 39:         if userData["noteState"] as? String == "success" {
 40:             let multiplier = userData["multiplier"] as? Int ?? 1
 41:             let message = userData["message"] as? String ?? "¡Bien!"
 42:             uiManager.showSuccessOverlay(multiplier: multiplier, message: message)
 43:         } else if userData["noteState"] as? String == "wrong" {
 44:             uiManager.showFailureOverlay()
 45:         }
 46:         if let gameOver = userData["gameOver"] as? Bool, gameOver {
 47:             let isVictory = userData["isVictory"] as? Bool ?? false
 48:             let reasonMessage = userData["reasonMessage"] as? String ?? (isVictory ? "¡Victoria!" : "Fin del juego")
 49:             uiManager.showGameOverOverlay(
 50:                 score: score,
 51:                 message: reasonMessage,
 52:                 isVictory: isVictory
 53:             ) { [weak self] in
 54:                 self?.setupGame()
 55:             }
 56:         }
 57:     }
 58:         private func setupManagers() {
 59:             let userProfile = UserProfile.load()
 60:             _ = gameManager.loadLevel(userProfile.statistics.currentLevel)
 61:             if let currentLevel = gameManager.currentLevel {
 62:                 objectiveTracker = LevelObjectiveTracker(level: currentLevel)
 63:             }
 64:             uiManager = GameUIManager(scene: self)
 65:             let (mainAreaWidth, mainAreaHeight) = uiManager.getMainAreaDimensions()
 66:             blocksManager = BlocksManager(
 67:                 blockSize: CGSize(
 68:                     width: mainAreaWidth * 0.9,
 69:                     height: mainAreaHeight * 0.15
 70:                 ),
 71:                 blockSpacing: mainAreaHeight * 0.02,
 72:                 mainAreaNode: uiManager.getMainAreaNode(),
 73:                 mainAreaHeight: mainAreaHeight
 74:             )
 75:             gameEngine = GameEngine(blockManager: blocksManager)
 76:             gameEngine.objectiveTracker = objectiveTracker
 77:             guard let engine = gameEngine else {
 78:                 fatalError("GameEngine no se ha inicializado correctamente")
 79:             }
 80:             audioController.delegate = engine
 81:             if let currentLevel = gameManager.currentLevel {
 82:                 uiManager.updateUI(score: 0, lives: currentLevel.lives.initial)
 83:             }
 84:         }
 85:     private func setupGame() {
 86:         let userProfile = UserProfile.load()
 87:         print("Intentando cargar nivel \(userProfile.statistics.currentLevel)")
 88:         if gameManager.loadLevel(userProfile.statistics.currentLevel) {
 89:             if let currentLevel = gameManager.currentLevel {
 90:                 startLevel(currentLevel)
 91:             }
 92:         } else {
 93:             print("Error al cargar nivel, intentando cargar tutorial")
 94:             if gameManager.loadLevel(0) {
 95:                 if let tutorialLevel = gameManager.currentLevel {
 96:                     startLevel(tutorialLevel)
 97:                 }
 98:             }
 99:         }
100:     }
101:     private func startLevel(_ level: GameLevel) {
102:         print("Iniciando nivel \(level.levelId): \(level.name)")
103:         audioController.stop()
104:         blocksManager.clearBlocks()
105:         if let tracker = objectiveTracker {
106:             uiManager.configureTopBars(withLevel: level, objectiveTracker: tracker)
107:         }
108:         uiManager.updateUI(score: 0, lives: level.lives.initial)
109:         uiManager.showLevelStartOverlay(for: level) { [weak self] in
110:             self?.startGameplay()
111:         }
112:     }
113:     private func startGameplay() {
114:         print("Iniciando gameplay")
115:         gameEngine.startNewGame()
116:         DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
117:             self.audioController.start()
118:             print("✅ Motor de audio iniciado")
119:             DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
120:                 self.blocksManager.startBlockGeneration()
121:                 print("✅ Gameplay iniciado")
122:             }
123:         }
124:     }
125:     override func update(_ currentTime: TimeInterval) {
126:         lastUpdateTime = currentTime
127:         if case .playing = gameEngine.gameState {
128:             gameEngine.checkBlocksPosition()
129:             if currentTime - lastTimeUpdate >= timeUpdateInterval {
130:                 lastTimeUpdate = currentTime
131:                 updateTimeDisplay()
132:             }
133:             updateGameState()
134:         }
135:     }
136:     private func updateTimeDisplay() {
137:         if let tracker = objectiveTracker {
138:             tracker.updateProgress(deltaTime: timeUpdateInterval)
139:             let progress = tracker.getCurrentProgress()
140:             uiManager.rightTopBarNode?.updateObjectiveInfo(with: progress)
141:         }
142:     }
143:     private func updateGameState() {
144:         uiManager.stabilityIndicatorNode.duration = audioController.stabilityDuration
145:         uiManager.stabilityCounterNode.duration = audioController.stabilityDuration
146:         updateGameUI()
147:     }
148:     private func updateGameUI() {
149:         uiManager.updateUI(score: gameEngine.score, lives: gameEngine.lives)
150:         switch gameEngine.gameState {
151:         case .playing:
152:             handleGameplayState()
153:         case .gameOver(let reason):
154:             handleGameOver(reason: reason)
155:         case .paused:
156:             break
157:         case .countdown:
158:             break
159:         }
160:     }
161:     private func handleGameplayState() {
162:         switch gameEngine.noteState {
163:         case .success(let multiplier, let message):
164:             uiManager.showSuccessOverlay(multiplier: multiplier, message: message)
165:         case .wrong:
166:             uiManager.showFailureOverlay()
167:         default:
168:             break
169:         }
170:     }
171:     private func handleGameOver(reason: GameOverReason) {
172:         audioController.stop()
173:         blocksManager.stopBlockGeneration()
174:         if let currentLevel = gameManager.currentLevel {
175:             gameManager.updateGameStatistics(
176:                 levelId: currentLevel.levelId,
177:                 score: gameEngine.score,
178:                 completed: reason == .victory
179:             )
180:         }
181:         let message = switch reason {
182:         case .blocksOverflow:
183:             "¡Los bloques han alcanzado la zona de peligro!"
184:         case .noLives:
185:             "¡Te has quedado sin vidas!"
186:         case .victory:
187:             "¡Nivel completado!"
188:         }
189:         print("🔴 Game Over: \(message)")
190:         uiManager.showGameOverOverlay(
191:             score: gameEngine.score,
192:             message: message,
193:             isVictory: reason == .victory
194:         ) { [weak self] in
195:             self?.setupGame()
196:         }
197:     }
198:     func audioController(_ controller: AudioController, didDetectNote note: String, frequency: Float, amplitude: Float, deviation: Double) {
199:         uiManager.detectedNoteCounterNode?.currentNote = note
200:         uiManager.detectedNoteCounterNode?.isActive = true
201:         uiManager.tuningIndicatorNode.deviation = deviation
202:         uiManager.tuningIndicatorNode.isActive = true
203:         gameEngine.checkNote(
204:             currentNote: note,
205:             deviation: deviation,
206:             isActive: true
207:         )
208:             if let progress = objectiveTracker?.getCurrentProgress() {
209:                 uiManager.rightTopBarNode?.updateObjectiveInfo(with: progress)
210:             }
211:     }
212:     func audioControllerDidDetectSilence(_ controller: AudioController) {
213:         uiManager.detectedNoteCounterNode?.isActive = false
214:         uiManager.tuningIndicatorNode.isActive = false
215:         gameEngine.checkNote(
216:             currentNote: "-",
217:             deviation: 0,
218:             isActive: false
219:         )
220:     }
221: }
222: private struct ScreenSizeKey: EnvironmentKey {
223:     static let defaultValue: CGSize = UIScreen.main.bounds.size
224: }
225: extension EnvironmentValues {
226:     var screenSize: CGSize {
227:         get { self[ScreenSizeKey.self] }
228:         set { self[ScreenSizeKey.self] = newValue }
229:     }
230: }
231: struct SpriteViewRepresentable: UIViewRepresentable {
232:     let size: CGSize
233:     func makeUIView(context: Context) -> SKView {
234:         let view = SKView(frame: .zero)
235:         view.preferredFramesPerSecond = 60
236:         view.ignoresSiblingOrder = true
237:         let scene = MusicBlocksScene()
238:         scene.scaleMode = .resizeFill
239:         scene.size = size
240:         view.presentScene(scene)
241:         return view
242:     }
243:     func updateUIView(_ uiView: SKView, context: Context) {
244:         if let scene = uiView.scene {
245:             scene.size = size
246:         }
247:     }
248: }
249: struct MusicBlocksSceneView: View {
250:     var body: some View {
251:         GeometryReader { geometry in
252:             SpriteView(scene: MusicBlocksScene(size: geometry.size))
253:                 .ignoresSafeArea()
254:                 .frame(maxWidth: .infinity, maxHeight: .infinity)
255:                 .navigationBarHidden(true)
256:         }
257:     }
258: }
259: #if DEBUG
260: import SwiftUI
261: struct MusicBlocksScene_Previews: PreviewProvider {
262:     static var previews: some View {
263:         MusicBlocksSceneView()
264:             .previewDevice("iPhone 16")
265:     }
266: }
267: #endif
</file>

<file path="MusicBlocks.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved">
 1: {
 2:   "originHash" : "a837f8bf89850bead33f45d5daae366332606889619596429a3c91b8a957e646",
 3:   "pins" : [
 4:     {
 5:       "identity" : "audiokit",
 6:       "kind" : "remoteSourceControl",
 7:       "location" : "https://github.com/AudioKit/AudioKit.git",
 8:       "state" : {
 9:         "revision" : "2ebd422855e4645d3169f83d1765d1c8196b4f46",
10:         "version" : "5.6.4"
11:       }
12:     },
13:     {
14:       "identity" : "audiokitex",
15:       "kind" : "remoteSourceControl",
16:       "location" : "https://github.com/AudioKit/AudioKitEX.git",
17:       "state" : {
18:         "revision" : "cb1a1276978ffc08e00d4774c0617aa8a58a17c4",
19:         "version" : "5.6.1"
20:       }
21:     },
22:     {
23:       "identity" : "kissfft",
24:       "kind" : "remoteSourceControl",
25:       "location" : "https://github.com/AudioKit/KissFFT",
26:       "state" : {
27:         "revision" : "dd0636e151724b8ba2e0908eba4d99a6ff24d00c",
28:         "version" : "1.0.0"
29:       }
30:     },
31:     {
32:       "identity" : "soundpipeaudiokit",
33:       "kind" : "remoteSourceControl",
34:       "location" : "https://github.com/AudioKit/SoundpipeAudioKit.git",
35:       "state" : {
36:         "revision" : "ee7d9542078ae48b24744a67c0350a12f9de354b",
37:         "version" : "5.6.1"
38:       }
39:     }
40:   ],
41:   "version" : 3
42: }
</file>

<file path="MusicBlocks.xcodeproj/project.xcworkspace/contents.xcworkspacedata">
1: <?xml version="1.0" encoding="UTF-8"?>
2: <Workspace
3:    version = "1.0">
4:    <FileRef
5:       location = "self:">
6:    </FileRef>
7: </Workspace>
</file>

<file path="MusicBlocks.xcodeproj/project.pbxproj">
  1: // !$*UTF8*$!
  2: {
  3: 	archiveVersion = 1;
  4: 	classes = {
  5: 	};
  6: 	objectVersion = 77;
  7: 	objects = {
  8: 
  9: /* Begin PBXBuildFile section */
 10: 		9E9E3E732D5FC90D001928B6 /* SoundpipeAudioKit in Frameworks */ = {isa = PBXBuildFile; productRef = 9E9E3E722D5FC90D001928B6 /* SoundpipeAudioKit */; };
 11: 		9E9E3E752D5FC912001928B6 /* AudioKitEX in Frameworks */ = {isa = PBXBuildFile; productRef = 9E9E3E742D5FC912001928B6 /* AudioKitEX */; };
 12: 		9E9E3E772D5FC916001928B6 /* AudioKit in Frameworks */ = {isa = PBXBuildFile; productRef = 9E9E3E762D5FC916001928B6 /* AudioKit */; };
 13: /* End PBXBuildFile section */
 14: 
 15: /* Begin PBXContainerItemProxy section */
 16: 		9E9E3DF12D5F6A93001928B6 /* PBXContainerItemProxy */ = {
 17: 			isa = PBXContainerItemProxy;
 18: 			containerPortal = 9E9E3DD82D5F6A92001928B6 /* Project object */;
 19: 			proxyType = 1;
 20: 			remoteGlobalIDString = 9E9E3DDF2D5F6A92001928B6;
 21: 			remoteInfo = MusicBlocks;
 22: 		};
 23: 		9E9E3DFB2D5F6A93001928B6 /* PBXContainerItemProxy */ = {
 24: 			isa = PBXContainerItemProxy;
 25: 			containerPortal = 9E9E3DD82D5F6A92001928B6 /* Project object */;
 26: 			proxyType = 1;
 27: 			remoteGlobalIDString = 9E9E3DDF2D5F6A92001928B6;
 28: 			remoteInfo = MusicBlocks;
 29: 		};
 30: /* End PBXContainerItemProxy section */
 31: 
 32: /* Begin PBXFileReference section */
 33: 		9E9E3DE02D5F6A92001928B6 /* MusicBlocks.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = MusicBlocks.app; sourceTree = BUILT_PRODUCTS_DIR; };
 34: 		9E9E3DF02D5F6A93001928B6 /* MusicBlocksTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = MusicBlocksTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
 35: 		9E9E3DFA2D5F6A93001928B6 /* MusicBlocksUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = MusicBlocksUITests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
 36: /* End PBXFileReference section */
 37: 
 38: /* Begin PBXFileSystemSynchronizedRootGroup section */
 39: 		9E9E3DE22D5F6A92001928B6 /* MusicBlocks */ = {
 40: 			isa = PBXFileSystemSynchronizedRootGroup;
 41: 			path = MusicBlocks;
 42: 			sourceTree = "<group>";
 43: 		};
 44: 		9E9E3DF32D5F6A93001928B6 /* MusicBlocksTests */ = {
 45: 			isa = PBXFileSystemSynchronizedRootGroup;
 46: 			path = MusicBlocksTests;
 47: 			sourceTree = "<group>";
 48: 		};
 49: 		9E9E3DFD2D5F6A93001928B6 /* MusicBlocksUITests */ = {
 50: 			isa = PBXFileSystemSynchronizedRootGroup;
 51: 			path = MusicBlocksUITests;
 52: 			sourceTree = "<group>";
 53: 		};
 54: /* End PBXFileSystemSynchronizedRootGroup section */
 55: 
 56: /* Begin PBXFrameworksBuildPhase section */
 57: 		9E9E3DDD2D5F6A92001928B6 /* Frameworks */ = {
 58: 			isa = PBXFrameworksBuildPhase;
 59: 			buildActionMask = 2147483647;
 60: 			files = (
 61: 				9E9E3E772D5FC916001928B6 /* AudioKit in Frameworks */,
 62: 				9E9E3E732D5FC90D001928B6 /* SoundpipeAudioKit in Frameworks */,
 63: 				9E9E3E752D5FC912001928B6 /* AudioKitEX in Frameworks */,
 64: 			);
 65: 			runOnlyForDeploymentPostprocessing = 0;
 66: 		};
 67: 		9E9E3DED2D5F6A93001928B6 /* Frameworks */ = {
 68: 			isa = PBXFrameworksBuildPhase;
 69: 			buildActionMask = 2147483647;
 70: 			files = (
 71: 			);
 72: 			runOnlyForDeploymentPostprocessing = 0;
 73: 		};
 74: 		9E9E3DF72D5F6A93001928B6 /* Frameworks */ = {
 75: 			isa = PBXFrameworksBuildPhase;
 76: 			buildActionMask = 2147483647;
 77: 			files = (
 78: 			);
 79: 			runOnlyForDeploymentPostprocessing = 0;
 80: 		};
 81: /* End PBXFrameworksBuildPhase section */
 82: 
 83: /* Begin PBXGroup section */
 84: 		9E9E3DD72D5F6A92001928B6 = {
 85: 			isa = PBXGroup;
 86: 			children = (
 87: 				9E9E3DE22D5F6A92001928B6 /* MusicBlocks */,
 88: 				9E9E3DF32D5F6A93001928B6 /* MusicBlocksTests */,
 89: 				9E9E3DFD2D5F6A93001928B6 /* MusicBlocksUITests */,
 90: 				9E9E3E712D5FC90D001928B6 /* Frameworks */,
 91: 				9E9E3DE12D5F6A92001928B6 /* Products */,
 92: 			);
 93: 			sourceTree = "<group>";
 94: 		};
 95: 		9E9E3DE12D5F6A92001928B6 /* Products */ = {
 96: 			isa = PBXGroup;
 97: 			children = (
 98: 				9E9E3DE02D5F6A92001928B6 /* MusicBlocks.app */,
 99: 				9E9E3DF02D5F6A93001928B6 /* MusicBlocksTests.xctest */,
100: 				9E9E3DFA2D5F6A93001928B6 /* MusicBlocksUITests.xctest */,
101: 			);
102: 			name = Products;
103: 			sourceTree = "<group>";
104: 		};
105: 		9E9E3E712D5FC90D001928B6 /* Frameworks */ = {
106: 			isa = PBXGroup;
107: 			children = (
108: 			);
109: 			name = Frameworks;
110: 			sourceTree = "<group>";
111: 		};
112: /* End PBXGroup section */
113: 
114: /* Begin PBXNativeTarget section */
115: 		9E9E3DDF2D5F6A92001928B6 /* MusicBlocks */ = {
116: 			isa = PBXNativeTarget;
117: 			buildConfigurationList = 9E9E3E042D5F6A93001928B6 /* Build configuration list for PBXNativeTarget "MusicBlocks" */;
118: 			buildPhases = (
119: 				9E9E3DDC2D5F6A92001928B6 /* Sources */,
120: 				9E9E3DDD2D5F6A92001928B6 /* Frameworks */,
121: 				9E9E3DDE2D5F6A92001928B6 /* Resources */,
122: 			);
123: 			buildRules = (
124: 			);
125: 			dependencies = (
126: 				9E9E3E6D2D5F6D86001928B6 /* PBXTargetDependency */,
127: 				9E9E3E6B2D5F6D80001928B6 /* PBXTargetDependency */,
128: 				9E9E3E672D5F6D67001928B6 /* PBXTargetDependency */,
129: 			);
130: 			fileSystemSynchronizedGroups = (
131: 				9E9E3DE22D5F6A92001928B6 /* MusicBlocks */,
132: 			);
133: 			name = MusicBlocks;
134: 			packageProductDependencies = (
135: 				9E9E3E722D5FC90D001928B6 /* SoundpipeAudioKit */,
136: 				9E9E3E742D5FC912001928B6 /* AudioKitEX */,
137: 				9E9E3E762D5FC916001928B6 /* AudioKit */,
138: 			);
139: 			productName = MusicBlocks;
140: 			productReference = 9E9E3DE02D5F6A92001928B6 /* MusicBlocks.app */;
141: 			productType = "com.apple.product-type.application";
142: 		};
143: 		9E9E3DEF2D5F6A93001928B6 /* MusicBlocksTests */ = {
144: 			isa = PBXNativeTarget;
145: 			buildConfigurationList = 9E9E3E072D5F6A93001928B6 /* Build configuration list for PBXNativeTarget "MusicBlocksTests" */;
146: 			buildPhases = (
147: 				9E9E3DEC2D5F6A93001928B6 /* Sources */,
148: 				9E9E3DED2D5F6A93001928B6 /* Frameworks */,
149: 				9E9E3DEE2D5F6A93001928B6 /* Resources */,
150: 			);
151: 			buildRules = (
152: 			);
153: 			dependencies = (
154: 				9E9E3DF22D5F6A93001928B6 /* PBXTargetDependency */,
155: 			);
156: 			fileSystemSynchronizedGroups = (
157: 				9E9E3DF32D5F6A93001928B6 /* MusicBlocksTests */,
158: 			);
159: 			name = MusicBlocksTests;
160: 			packageProductDependencies = (
161: 			);
162: 			productName = MusicBlocksTests;
163: 			productReference = 9E9E3DF02D5F6A93001928B6 /* MusicBlocksTests.xctest */;
164: 			productType = "com.apple.product-type.bundle.unit-test";
165: 		};
166: 		9E9E3DF92D5F6A93001928B6 /* MusicBlocksUITests */ = {
167: 			isa = PBXNativeTarget;
168: 			buildConfigurationList = 9E9E3E0A2D5F6A93001928B6 /* Build configuration list for PBXNativeTarget "MusicBlocksUITests" */;
169: 			buildPhases = (
170: 				9E9E3DF62D5F6A93001928B6 /* Sources */,
171: 				9E9E3DF72D5F6A93001928B6 /* Frameworks */,
172: 				9E9E3DF82D5F6A93001928B6 /* Resources */,
173: 			);
174: 			buildRules = (
175: 			);
176: 			dependencies = (
177: 				9E9E3DFC2D5F6A93001928B6 /* PBXTargetDependency */,
178: 			);
179: 			fileSystemSynchronizedGroups = (
180: 				9E9E3DFD2D5F6A93001928B6 /* MusicBlocksUITests */,
181: 			);
182: 			name = MusicBlocksUITests;
183: 			packageProductDependencies = (
184: 			);
185: 			productName = MusicBlocksUITests;
186: 			productReference = 9E9E3DFA2D5F6A93001928B6 /* MusicBlocksUITests.xctest */;
187: 			productType = "com.apple.product-type.bundle.ui-testing";
188: 		};
189: /* End PBXNativeTarget section */
190: 
191: /* Begin PBXProject section */
192: 		9E9E3DD82D5F6A92001928B6 /* Project object */ = {
193: 			isa = PBXProject;
194: 			attributes = {
195: 				BuildIndependentTargetsInParallel = 1;
196: 				LastSwiftUpdateCheck = 1620;
197: 				LastUpgradeCheck = 1620;
198: 				TargetAttributes = {
199: 					9E9E3DDF2D5F6A92001928B6 = {
200: 						CreatedOnToolsVersion = 16.2;
201: 					};
202: 					9E9E3DEF2D5F6A93001928B6 = {
203: 						CreatedOnToolsVersion = 16.2;
204: 						TestTargetID = 9E9E3DDF2D5F6A92001928B6;
205: 					};
206: 					9E9E3DF92D5F6A93001928B6 = {
207: 						CreatedOnToolsVersion = 16.2;
208: 						TestTargetID = 9E9E3DDF2D5F6A92001928B6;
209: 					};
210: 				};
211: 			};
212: 			buildConfigurationList = 9E9E3DDB2D5F6A92001928B6 /* Build configuration list for PBXProject "MusicBlocks" */;
213: 			developmentRegion = en;
214: 			hasScannedForEncodings = 0;
215: 			knownRegions = (
216: 				en,
217: 				Base,
218: 			);
219: 			mainGroup = 9E9E3DD72D5F6A92001928B6;
220: 			minimizedProjectReferenceProxies = 1;
221: 			packageReferences = (
222: 				9E9E3E652D5F6D55001928B6 /* XCRemoteSwiftPackageReference "SoundpipeAudioKit" */,
223: 				9E9E3E682D5F6D70001928B6 /* XCRemoteSwiftPackageReference "AudioKitEX" */,
224: 				9E9E3E692D5F6D78001928B6 /* XCRemoteSwiftPackageReference "AudioKit" */,
225: 			);
226: 			preferredProjectObjectVersion = 77;
227: 			productRefGroup = 9E9E3DE12D5F6A92001928B6 /* Products */;
228: 			projectDirPath = "";
229: 			projectRoot = "";
230: 			targets = (
231: 				9E9E3DDF2D5F6A92001928B6 /* MusicBlocks */,
232: 				9E9E3DEF2D5F6A93001928B6 /* MusicBlocksTests */,
233: 				9E9E3DF92D5F6A93001928B6 /* MusicBlocksUITests */,
234: 			);
235: 		};
236: /* End PBXProject section */
237: 
238: /* Begin PBXResourcesBuildPhase section */
239: 		9E9E3DDE2D5F6A92001928B6 /* Resources */ = {
240: 			isa = PBXResourcesBuildPhase;
241: 			buildActionMask = 2147483647;
242: 			files = (
243: 			);
244: 			runOnlyForDeploymentPostprocessing = 0;
245: 		};
246: 		9E9E3DEE2D5F6A93001928B6 /* Resources */ = {
247: 			isa = PBXResourcesBuildPhase;
248: 			buildActionMask = 2147483647;
249: 			files = (
250: 			);
251: 			runOnlyForDeploymentPostprocessing = 0;
252: 		};
253: 		9E9E3DF82D5F6A93001928B6 /* Resources */ = {
254: 			isa = PBXResourcesBuildPhase;
255: 			buildActionMask = 2147483647;
256: 			files = (
257: 			);
258: 			runOnlyForDeploymentPostprocessing = 0;
259: 		};
260: /* End PBXResourcesBuildPhase section */
261: 
262: /* Begin PBXSourcesBuildPhase section */
263: 		9E9E3DDC2D5F6A92001928B6 /* Sources */ = {
264: 			isa = PBXSourcesBuildPhase;
265: 			buildActionMask = 2147483647;
266: 			files = (
267: 			);
268: 			runOnlyForDeploymentPostprocessing = 0;
269: 		};
270: 		9E9E3DEC2D5F6A93001928B6 /* Sources */ = {
271: 			isa = PBXSourcesBuildPhase;
272: 			buildActionMask = 2147483647;
273: 			files = (
274: 			);
275: 			runOnlyForDeploymentPostprocessing = 0;
276: 		};
277: 		9E9E3DF62D5F6A93001928B6 /* Sources */ = {
278: 			isa = PBXSourcesBuildPhase;
279: 			buildActionMask = 2147483647;
280: 			files = (
281: 			);
282: 			runOnlyForDeploymentPostprocessing = 0;
283: 		};
284: /* End PBXSourcesBuildPhase section */
285: 
286: /* Begin PBXTargetDependency section */
287: 		9E9E3DF22D5F6A93001928B6 /* PBXTargetDependency */ = {
288: 			isa = PBXTargetDependency;
289: 			target = 9E9E3DDF2D5F6A92001928B6 /* MusicBlocks */;
290: 			targetProxy = 9E9E3DF12D5F6A93001928B6 /* PBXContainerItemProxy */;
291: 		};
292: 		9E9E3DFC2D5F6A93001928B6 /* PBXTargetDependency */ = {
293: 			isa = PBXTargetDependency;
294: 			target = 9E9E3DDF2D5F6A92001928B6 /* MusicBlocks */;
295: 			targetProxy = 9E9E3DFB2D5F6A93001928B6 /* PBXContainerItemProxy */;
296: 		};
297: 		9E9E3E672D5F6D67001928B6 /* PBXTargetDependency */ = {
298: 			isa = PBXTargetDependency;
299: 			productRef = 9E9E3E662D5F6D67001928B6 /* SoundpipeAudioKit */;
300: 		};
301: 		9E9E3E6B2D5F6D80001928B6 /* PBXTargetDependency */ = {
302: 			isa = PBXTargetDependency;
303: 			productRef = 9E9E3E6A2D5F6D80001928B6 /* AudioKitEX */;
304: 		};
305: 		9E9E3E6D2D5F6D86001928B6 /* PBXTargetDependency */ = {
306: 			isa = PBXTargetDependency;
307: 			productRef = 9E9E3E6C2D5F6D86001928B6 /* AudioKit */;
308: 		};
309: /* End PBXTargetDependency section */
310: 
311: /* Begin XCBuildConfiguration section */
312: 		9E9E3E022D5F6A93001928B6 /* Debug */ = {
313: 			isa = XCBuildConfiguration;
314: 			buildSettings = {
315: 				ALWAYS_SEARCH_USER_PATHS = NO;
316: 				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
317: 				CLANG_ANALYZER_NONNULL = YES;
318: 				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
319: 				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
320: 				CLANG_ENABLE_MODULES = YES;
321: 				CLANG_ENABLE_OBJC_ARC = YES;
322: 				CLANG_ENABLE_OBJC_WEAK = YES;
323: 				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
324: 				CLANG_WARN_BOOL_CONVERSION = YES;
325: 				CLANG_WARN_COMMA = YES;
326: 				CLANG_WARN_CONSTANT_CONVERSION = YES;
327: 				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
328: 				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
329: 				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
330: 				CLANG_WARN_EMPTY_BODY = YES;
331: 				CLANG_WARN_ENUM_CONVERSION = YES;
332: 				CLANG_WARN_INFINITE_RECURSION = YES;
333: 				CLANG_WARN_INT_CONVERSION = YES;
334: 				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
335: 				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
336: 				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
337: 				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
338: 				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
339: 				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
340: 				CLANG_WARN_STRICT_PROTOTYPES = YES;
341: 				CLANG_WARN_SUSPICIOUS_MOVE = YES;
342: 				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
343: 				CLANG_WARN_UNREACHABLE_CODE = YES;
344: 				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
345: 				COPY_PHASE_STRIP = NO;
346: 				DEBUG_INFORMATION_FORMAT = dwarf;
347: 				ENABLE_STRICT_OBJC_MSGSEND = YES;
348: 				ENABLE_TESTABILITY = YES;
349: 				ENABLE_USER_SCRIPT_SANDBOXING = YES;
350: 				GCC_C_LANGUAGE_STANDARD = gnu17;
351: 				GCC_DYNAMIC_NO_PIC = NO;
352: 				GCC_NO_COMMON_BLOCKS = YES;
353: 				GCC_OPTIMIZATION_LEVEL = 0;
354: 				GCC_PREPROCESSOR_DEFINITIONS = (
355: 					"DEBUG=1",
356: 					"$(inherited)",
357: 				);
358: 				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
359: 				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
360: 				GCC_WARN_UNDECLARED_SELECTOR = YES;
361: 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
362: 				GCC_WARN_UNUSED_FUNCTION = YES;
363: 				GCC_WARN_UNUSED_VARIABLE = YES;
364: 				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
365: 				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
366: 				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
367: 				MTL_FAST_MATH = YES;
368: 				ONLY_ACTIVE_ARCH = YES;
369: 				SDKROOT = iphoneos;
370: 				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
371: 				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
372: 			};
373: 			name = Debug;
374: 		};
375: 		9E9E3E032D5F6A93001928B6 /* Release */ = {
376: 			isa = XCBuildConfiguration;
377: 			buildSettings = {
378: 				ALWAYS_SEARCH_USER_PATHS = NO;
379: 				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
380: 				CLANG_ANALYZER_NONNULL = YES;
381: 				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
382: 				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
383: 				CLANG_ENABLE_MODULES = YES;
384: 				CLANG_ENABLE_OBJC_ARC = YES;
385: 				CLANG_ENABLE_OBJC_WEAK = YES;
386: 				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
387: 				CLANG_WARN_BOOL_CONVERSION = YES;
388: 				CLANG_WARN_COMMA = YES;
389: 				CLANG_WARN_CONSTANT_CONVERSION = YES;
390: 				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
391: 				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
392: 				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
393: 				CLANG_WARN_EMPTY_BODY = YES;
394: 				CLANG_WARN_ENUM_CONVERSION = YES;
395: 				CLANG_WARN_INFINITE_RECURSION = YES;
396: 				CLANG_WARN_INT_CONVERSION = YES;
397: 				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
398: 				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
399: 				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
400: 				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
401: 				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
402: 				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
403: 				CLANG_WARN_STRICT_PROTOTYPES = YES;
404: 				CLANG_WARN_SUSPICIOUS_MOVE = YES;
405: 				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
406: 				CLANG_WARN_UNREACHABLE_CODE = YES;
407: 				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
408: 				COPY_PHASE_STRIP = NO;
409: 				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
410: 				ENABLE_NS_ASSERTIONS = NO;
411: 				ENABLE_STRICT_OBJC_MSGSEND = YES;
412: 				ENABLE_USER_SCRIPT_SANDBOXING = YES;
413: 				GCC_C_LANGUAGE_STANDARD = gnu17;
414: 				GCC_NO_COMMON_BLOCKS = YES;
415: 				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
416: 				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
417: 				GCC_WARN_UNDECLARED_SELECTOR = YES;
418: 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
419: 				GCC_WARN_UNUSED_FUNCTION = YES;
420: 				GCC_WARN_UNUSED_VARIABLE = YES;
421: 				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
422: 				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
423: 				MTL_ENABLE_DEBUG_INFO = NO;
424: 				MTL_FAST_MATH = YES;
425: 				SDKROOT = iphoneos;
426: 				SWIFT_COMPILATION_MODE = wholemodule;
427: 				VALIDATE_PRODUCT = YES;
428: 			};
429: 			name = Release;
430: 		};
431: 		9E9E3E052D5F6A93001928B6 /* Debug */ = {
432: 			isa = XCBuildConfiguration;
433: 			buildSettings = {
434: 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
435: 				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
436: 				CODE_SIGN_STYLE = Automatic;
437: 				CURRENT_PROJECT_VERSION = 1;
438: 				DEVELOPMENT_ASSET_PATHS = "\"MusicBlocks/Preview Content\"";
439: 				DEVELOPMENT_TEAM = WDPKVDHVQC;
440: 				ENABLE_PREVIEWS = YES;
441: 				GENERATE_INFOPLIST_FILE = YES;
442: 				INFOPLIST_KEY_NSMicrophoneUsageDescription = "Necesitamos acceso al micrófono para poder afinar tu instrumento";
443: 				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
444: 				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
445: 				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
446: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
447: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
448: 				LD_RUNPATH_SEARCH_PATHS = (
449: 					"$(inherited)",
450: 					"@executable_path/Frameworks",
451: 				);
452: 				MARKETING_VERSION = 1.0;
453: 				PRODUCT_BUNDLE_IDENTIFIER = frikiteam.MusicBlocks;
454: 				PRODUCT_NAME = "$(TARGET_NAME)";
455: 				SWIFT_EMIT_LOC_STRINGS = YES;
456: 				SWIFT_VERSION = 5.0;
457: 				TARGETED_DEVICE_FAMILY = "1,2";
458: 			};
459: 			name = Debug;
460: 		};
461: 		9E9E3E062D5F6A93001928B6 /* Release */ = {
462: 			isa = XCBuildConfiguration;
463: 			buildSettings = {
464: 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
465: 				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
466: 				CODE_SIGN_STYLE = Automatic;
467: 				CURRENT_PROJECT_VERSION = 1;
468: 				DEVELOPMENT_ASSET_PATHS = "\"MusicBlocks/Preview Content\"";
469: 				DEVELOPMENT_TEAM = WDPKVDHVQC;
470: 				ENABLE_PREVIEWS = YES;
471: 				GENERATE_INFOPLIST_FILE = YES;
472: 				INFOPLIST_KEY_NSMicrophoneUsageDescription = "Necesitamos acceso al micrófono para poder afinar tu instrumento";
473: 				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
474: 				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
475: 				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
476: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
477: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
478: 				LD_RUNPATH_SEARCH_PATHS = (
479: 					"$(inherited)",
480: 					"@executable_path/Frameworks",
481: 				);
482: 				MARKETING_VERSION = 1.0;
483: 				PRODUCT_BUNDLE_IDENTIFIER = frikiteam.MusicBlocks;
484: 				PRODUCT_NAME = "$(TARGET_NAME)";
485: 				SWIFT_EMIT_LOC_STRINGS = YES;
486: 				SWIFT_VERSION = 5.0;
487: 				TARGETED_DEVICE_FAMILY = "1,2";
488: 			};
489: 			name = Release;
490: 		};
491: 		9E9E3E082D5F6A93001928B6 /* Debug */ = {
492: 			isa = XCBuildConfiguration;
493: 			buildSettings = {
494: 				BUNDLE_LOADER = "$(TEST_HOST)";
495: 				CODE_SIGN_STYLE = Automatic;
496: 				CURRENT_PROJECT_VERSION = 1;
497: 				DEVELOPMENT_TEAM = WDPKVDHVQC;
498: 				GENERATE_INFOPLIST_FILE = YES;
499: 				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
500: 				MARKETING_VERSION = 1.0;
501: 				PRODUCT_BUNDLE_IDENTIFIER = frikiteam.MusicBlocksTests;
502: 				PRODUCT_NAME = "$(TARGET_NAME)";
503: 				SWIFT_EMIT_LOC_STRINGS = NO;
504: 				SWIFT_VERSION = 5.0;
505: 				TARGETED_DEVICE_FAMILY = "1,2";
506: 				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/MusicBlocks.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/MusicBlocks";
507: 			};
508: 			name = Debug;
509: 		};
510: 		9E9E3E092D5F6A93001928B6 /* Release */ = {
511: 			isa = XCBuildConfiguration;
512: 			buildSettings = {
513: 				BUNDLE_LOADER = "$(TEST_HOST)";
514: 				CODE_SIGN_STYLE = Automatic;
515: 				CURRENT_PROJECT_VERSION = 1;
516: 				DEVELOPMENT_TEAM = WDPKVDHVQC;
517: 				GENERATE_INFOPLIST_FILE = YES;
518: 				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
519: 				MARKETING_VERSION = 1.0;
520: 				PRODUCT_BUNDLE_IDENTIFIER = frikiteam.MusicBlocksTests;
521: 				PRODUCT_NAME = "$(TARGET_NAME)";
522: 				SWIFT_EMIT_LOC_STRINGS = NO;
523: 				SWIFT_VERSION = 5.0;
524: 				TARGETED_DEVICE_FAMILY = "1,2";
525: 				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/MusicBlocks.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/MusicBlocks";
526: 			};
527: 			name = Release;
528: 		};
529: 		9E9E3E0B2D5F6A93001928B6 /* Debug */ = {
530: 			isa = XCBuildConfiguration;
531: 			buildSettings = {
532: 				CODE_SIGN_STYLE = Automatic;
533: 				CURRENT_PROJECT_VERSION = 1;
534: 				DEVELOPMENT_TEAM = WDPKVDHVQC;
535: 				GENERATE_INFOPLIST_FILE = YES;
536: 				MARKETING_VERSION = 1.0;
537: 				PRODUCT_BUNDLE_IDENTIFIER = frikiteam.MusicBlocksUITests;
538: 				PRODUCT_NAME = "$(TARGET_NAME)";
539: 				SWIFT_EMIT_LOC_STRINGS = NO;
540: 				SWIFT_VERSION = 5.0;
541: 				TARGETED_DEVICE_FAMILY = "1,2";
542: 				TEST_TARGET_NAME = MusicBlocks;
543: 			};
544: 			name = Debug;
545: 		};
546: 		9E9E3E0C2D5F6A93001928B6 /* Release */ = {
547: 			isa = XCBuildConfiguration;
548: 			buildSettings = {
549: 				CODE_SIGN_STYLE = Automatic;
550: 				CURRENT_PROJECT_VERSION = 1;
551: 				DEVELOPMENT_TEAM = WDPKVDHVQC;
552: 				GENERATE_INFOPLIST_FILE = YES;
553: 				MARKETING_VERSION = 1.0;
554: 				PRODUCT_BUNDLE_IDENTIFIER = frikiteam.MusicBlocksUITests;
555: 				PRODUCT_NAME = "$(TARGET_NAME)";
556: 				SWIFT_EMIT_LOC_STRINGS = NO;
557: 				SWIFT_VERSION = 5.0;
558: 				TARGETED_DEVICE_FAMILY = "1,2";
559: 				TEST_TARGET_NAME = MusicBlocks;
560: 			};
561: 			name = Release;
562: 		};
563: /* End XCBuildConfiguration section */
564: 
565: /* Begin XCConfigurationList section */
566: 		9E9E3DDB2D5F6A92001928B6 /* Build configuration list for PBXProject "MusicBlocks" */ = {
567: 			isa = XCConfigurationList;
568: 			buildConfigurations = (
569: 				9E9E3E022D5F6A93001928B6 /* Debug */,
570: 				9E9E3E032D5F6A93001928B6 /* Release */,
571: 			);
572: 			defaultConfigurationIsVisible = 0;
573: 			defaultConfigurationName = Release;
574: 		};
575: 		9E9E3E042D5F6A93001928B6 /* Build configuration list for PBXNativeTarget "MusicBlocks" */ = {
576: 			isa = XCConfigurationList;
577: 			buildConfigurations = (
578: 				9E9E3E052D5F6A93001928B6 /* Debug */,
579: 				9E9E3E062D5F6A93001928B6 /* Release */,
580: 			);
581: 			defaultConfigurationIsVisible = 0;
582: 			defaultConfigurationName = Release;
583: 		};
584: 		9E9E3E072D5F6A93001928B6 /* Build configuration list for PBXNativeTarget "MusicBlocksTests" */ = {
585: 			isa = XCConfigurationList;
586: 			buildConfigurations = (
587: 				9E9E3E082D5F6A93001928B6 /* Debug */,
588: 				9E9E3E092D5F6A93001928B6 /* Release */,
589: 			);
590: 			defaultConfigurationIsVisible = 0;
591: 			defaultConfigurationName = Release;
592: 		};
593: 		9E9E3E0A2D5F6A93001928B6 /* Build configuration list for PBXNativeTarget "MusicBlocksUITests" */ = {
594: 			isa = XCConfigurationList;
595: 			buildConfigurations = (
596: 				9E9E3E0B2D5F6A93001928B6 /* Debug */,
597: 				9E9E3E0C2D5F6A93001928B6 /* Release */,
598: 			);
599: 			defaultConfigurationIsVisible = 0;
600: 			defaultConfigurationName = Release;
601: 		};
602: /* End XCConfigurationList section */
603: 
604: /* Begin XCRemoteSwiftPackageReference section */
605: 		9E9E3E652D5F6D55001928B6 /* XCRemoteSwiftPackageReference "SoundpipeAudioKit" */ = {
606: 			isa = XCRemoteSwiftPackageReference;
607: 			repositoryURL = "https://github.com/AudioKit/SoundpipeAudioKit.git";
608: 			requirement = {
609: 				kind = upToNextMajorVersion;
610: 				minimumVersion = 5.6.1;
611: 			};
612: 		};
613: 		9E9E3E682D5F6D70001928B6 /* XCRemoteSwiftPackageReference "AudioKitEX" */ = {
614: 			isa = XCRemoteSwiftPackageReference;
615: 			repositoryURL = "https://github.com/AudioKit/AudioKitEX.git";
616: 			requirement = {
617: 				kind = upToNextMajorVersion;
618: 				minimumVersion = 5.6.1;
619: 			};
620: 		};
621: 		9E9E3E692D5F6D78001928B6 /* XCRemoteSwiftPackageReference "AudioKit" */ = {
622: 			isa = XCRemoteSwiftPackageReference;
623: 			repositoryURL = "https://github.com/AudioKit/AudioKit.git";
624: 			requirement = {
625: 				kind = upToNextMajorVersion;
626: 				minimumVersion = 5.6.4;
627: 			};
628: 		};
629: /* End XCRemoteSwiftPackageReference section */
630: 
631: /* Begin XCSwiftPackageProductDependency section */
632: 		9E9E3E662D5F6D67001928B6 /* SoundpipeAudioKit */ = {
633: 			isa = XCSwiftPackageProductDependency;
634: 			package = 9E9E3E652D5F6D55001928B6 /* XCRemoteSwiftPackageReference "SoundpipeAudioKit" */;
635: 			productName = SoundpipeAudioKit;
636: 		};
637: 		9E9E3E6A2D5F6D80001928B6 /* AudioKitEX */ = {
638: 			isa = XCSwiftPackageProductDependency;
639: 			package = 9E9E3E682D5F6D70001928B6 /* XCRemoteSwiftPackageReference "AudioKitEX" */;
640: 			productName = AudioKitEX;
641: 		};
642: 		9E9E3E6C2D5F6D86001928B6 /* AudioKit */ = {
643: 			isa = XCSwiftPackageProductDependency;
644: 			package = 9E9E3E692D5F6D78001928B6 /* XCRemoteSwiftPackageReference "AudioKit" */;
645: 			productName = AudioKit;
646: 		};
647: 		9E9E3E722D5FC90D001928B6 /* SoundpipeAudioKit */ = {
648: 			isa = XCSwiftPackageProductDependency;
649: 			package = 9E9E3E652D5F6D55001928B6 /* XCRemoteSwiftPackageReference "SoundpipeAudioKit" */;
650: 			productName = SoundpipeAudioKit;
651: 		};
652: 		9E9E3E742D5FC912001928B6 /* AudioKitEX */ = {
653: 			isa = XCSwiftPackageProductDependency;
654: 			package = 9E9E3E682D5F6D70001928B6 /* XCRemoteSwiftPackageReference "AudioKitEX" */;
655: 			productName = AudioKitEX;
656: 		};
657: 		9E9E3E762D5FC916001928B6 /* AudioKit */ = {
658: 			isa = XCSwiftPackageProductDependency;
659: 			package = 9E9E3E692D5F6D78001928B6 /* XCRemoteSwiftPackageReference "AudioKit" */;
660: 			productName = AudioKit;
661: 		};
662: /* End XCSwiftPackageProductDependency section */
663: 	};
664: 	rootObject = 9E9E3DD82D5F6A92001928B6 /* Project object */;
665: }
</file>

<file path="MusicBlocksTests/MusicBlocksTests.swift">
1: import Testing
2: @testable import MusicBlocks
3: struct MusicBlocksTests {
4:     @Test func example() async throws {
5:     }
6: }
</file>

<file path="MusicBlocksUITests/MusicBlocksUITests.swift">
 1: import XCTest
 2: final class MusicBlocksUITests: XCTestCase {
 3:     override func setUpWithError() throws {
 4:         continueAfterFailure = false
 5:     }
 6:     override func tearDownWithError() throws {
 7:     }
 8:     @MainActor
 9:     func testExample() throws {
10:         let app = XCUIApplication()
11:         app.launch()
12:     }
13:     @MainActor
14:     func testLaunchPerformance() throws {
15:         if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *) {
16:             measure(metrics: [XCTApplicationLaunchMetric()]) {
17:                 XCUIApplication().launch()
18:             }
19:         }
20:     }
21: }
</file>

<file path="MusicBlocksUITests/MusicBlocksUITestsLaunchTests.swift">
 1: import XCTest
 2: final class MusicBlocksUITestsLaunchTests: XCTestCase {
 3:     override class var runsForEachTargetApplicationUIConfiguration: Bool {
 4:         true
 5:     }
 6:     override func setUpWithError() throws {
 7:         continueAfterFailure = false
 8:     }
 9:     @MainActor
10:     func testLaunch() throws {
11:         let app = XCUIApplication()
12:         app.launch()
13:         let attachment = XCTAttachment(screenshot: app.screenshot())
14:         attachment.name = "Launch Screen"
15:         attachment.lifetime = .keepAlways
16:         add(attachment)
17:     }
18: }
</file>

<file path=".gitignore">
 1: # Xcode
 2: #
 3: # gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore
 4: 
 5: ## User settings
 6: xcuserdata/
 7: 
 8: ## Obj-C/Swift specific
 9: *.hmap
10: 
11: ## App packaging
12: *.ipa
13: *.dSYM.zip
14: *.dSYM
15: 
16: ## Playgrounds
17: timeline.xctimeline
18: playground.xcworkspace
19: 
20: # Swift Package Manager
21: #
22: # Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
23: # Packages/
24: # Package.pins
25: # Package.resolved
26: # *.xcodeproj
27: #
28: # Xcode automatically generates this directory with a .xcworkspacedata file and xcuserdata
29: # hence it is not needed unless you have added a package configuration file to your project
30: # .swiftpm
31: 
32: .build/
33: 
34: # CocoaPods
35: #
36: # We recommend against adding the Pods directory to your .gitignore. However
37: # you should judge for yourself, the pros and cons are mentioned at:
38: # https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
39: #
40: # Pods/
41: #
42: # Add this line if you want to avoid checking in source code from the Xcode workspace
43: # *.xcworkspace
44: 
45: # Carthage
46: #
47: # Add this line if you want to avoid checking in source code from Carthage dependencies.
48: # Carthage/Checkouts
49: 
50: Carthage/Build/
51: 
52: # fastlane
53: #
54: # It is recommended to not store the screenshots in the git repo.
55: # Instead, use fastlane to re-generate the screenshots whenever they are needed.
56: # For more information about the recommended setup visit:
57: # https://docs.fastlane.tools/best-practices/source-control/#source-control
58: 
59: fastlane/report.xml
60: fastlane/Preview.html
61: fastlane/screenshots/**/*.png
62: fastlane/test_output
</file>

</files>
