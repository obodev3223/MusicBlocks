This file is a merged representation of the entire codebase, combined into a single document by Repomix. The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
MusicBlocks/
  Audio/
    AudioController.swift
    TunerEngine.swift
  Bloques/
    BlockContentGenerator.swift
    BlocksManager.swift
    BlockStyle.swift
    MusicalNote.swift
  Inicio y Profile/
    AchievementBadge.swift
    AchievementsView.swift
    AvatarPickerViewController.swift
    ContentView.swift
    ExpandableSectionView.swift
    MusicBlocksApp.swift
    ProfileHeaderView.swift
    ProfileViewController.swift
    StatsView.swift
    UserProfile.swift
  Paneles/
    DetectedNoteCounterNode.swift
    GameOverlayNode.swift
    ScoreProgressNode.swift
    StabilityCounterNode.swift
    StabilityIndicatorNode.swift
    TopBar.swift
    TopBarComponents.swift
    TuningIndicatorNode.swift
    UIContainer.swift
  Preview Content/
    Preview Assets.xcassets/
      Contents.json
  BackgroundPatternNode.swift
  game_levels.json
  GameEngine.swift
  GameLevelProcessor.swift
  GameManager.swift
  GameTypes.swift
  GameUIManager.swift
  LevelObjectiveTracker.swift
  MusicBlocksScene.swift
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="MusicBlocks/Audio/AudioController.swift">
//
//  AudioController.swift
//  MusicBlocks
//
//  Created by Jose R. García on 13/3/25.
//  Actualizado para obtener dinámicamente el requiredHoldTime del bloque actual.
//

import AudioKit
import AudioKitEX
import AVFoundation
import SoundpipeAudioKit

protocol AudioControllerDelegate: AnyObject {
    func audioController(_ controller: AudioController, didDetectNote note: String, frequency: Float, amplitude: Float, deviation: Double)
    func audioControllerDidDetectSilence(_ controller: AudioController)
    // Nuevo método para obtener el tiempo requerido para mantener la nota (hold)
    func audioControllerRequiredHoldTime(_ controller: AudioController) -> TimeInterval
}

class AudioController: ObservableObject {
    static let sharedInstance = AudioController()
    weak var delegate: AudioControllerDelegate?
    
    @Published var tunerData: TunerEngine.TunerData = .inactive
    @Published var stabilityDuration: TimeInterval = 0
    
    private let tunerEngine = TunerEngine.shared
    
    let engine = AudioEngine()
    var pitchTap: PitchTap!
    var mic: AudioEngine.InputNode!
    var silence: Fader!
    
    // Umbrales y configuración
    private let minimumAmplitude: Float = 0.02
    private let minimumFrequency: Float = 20.0
    private let maximumFrequency: Float = 2000.0
    private let stabilityThreshold: Float = 3.0 // Variación máxima permitida en Hz
    private let amplitudeSmoothing: Float = 0.9 // Factor de suavizado para la amplitud
    
    // Variables de seguimiento
    private var lastStableFrequency: Float = 0
    private var stabilityStartTime: Date?
    private var smoothedAmplitude: Float = 0
    private var lastProcessedTime: Date = Date()
    private let minimumProcessingInterval: TimeInterval = 0.05 // 50ms entre procesamientos
    
    // MARK: - Nueva funcionalidad: Música de fondo y efectos de sonido
    private var backgroundMusicPlayer: AVAudioPlayer?
    
    /// Inicia la música de fondo en el menú.
    /// Asegúrate de haber añadido "backgroundMusic.mp3" al bundle de tu proyecto.
    ///
    func startBackgroundMusic() {
        // Si el reproductor ya existe y está reproduciendo, no hacemos nada
        if let player = backgroundMusicPlayer, player.isPlaying {
            print("La música de fondo ya se está reproduciendo")
            return
        }
        guard let url = Bundle.main.url(forResource: "backgroundMusic", withExtension: "mp3")
        else {
            print("No se encontró el archivo de música de fondo")
            return
        }
        do {
            backgroundMusicPlayer = try AVAudioPlayer(contentsOf: url)
            backgroundMusicPlayer?.numberOfLoops = -1
            // Loop infinito
            let targetVolume: Float = 0.5
            backgroundMusicPlayer?.volume = 0.3
            backgroundMusicPlayer?.prepareToPlay()
            backgroundMusicPlayer?.play()
            fadeInBackgroundMusic(to: targetVolume, duration: 1.0)
            print("Música de fondo iniciada con fade in")
        }   catch {
            print("Error al reproducir la música de fondo: (error)")
        }
    }
    
    
    /// Función privada para realizar el fade in de la música de fondo.
    private func fadeInBackgroundMusic(to targetVolume: Float, duration: TimeInterval) {
        guard let player = backgroundMusicPlayer else { return }
        let fadeSteps = 40
        let fadeStepDuration = duration / Double(fadeSteps)
        
        for step in 0...fadeSteps {
            DispatchQueue.main.asyncAfter(deadline: .now() + fadeStepDuration * Double(step)) {
                let fraction = Float(step) / Float(fadeSteps)
                player.volume = targetVolume * fraction
            }
        }
    }
    
    /// Detiene la música de fondo.
    func stopBackgroundMusic (duration: TimeInterval = 0.5) {
        guard let player = backgroundMusicPlayer, player.isPlaying else {
            return
        }
        
        let fadeSteps = 5
        let fadeStepDuration = duration / Double(fadeSteps)
        let originalVolume = player.volume
        
        for step in 0...fadeSteps {
            DispatchQueue.main.asyncAfter(deadline: .now() + fadeStepDuration * Double(step)) {
                let fraction = Float(step) / Float(fadeSteps)
                player.volume = originalVolume * (1 - fraction)
                if step == fadeSteps {
                    player.stop()
                }
            }
        }
        print("AudioController: Iniciando fade out de la música de fondo")
    }
    
    /// Reproduce un efecto de sonido para la pulsación de un botón.
    /// Asegúrate de haber añadido "buttonClick.mp3" al bundle.
    func playButtonSound() {
        guard let url = Bundle.main.url(forResource: "buttonClick", withExtension: "mp3") else {
            print("AudioController: No se encontró el efecto de sonido para botón")
            return
        }
        
        do {
            let buttonSoundPlayer = try AVAudioPlayer(contentsOf: url)
            buttonSoundPlayer.volume = 0.8
            buttonSoundPlayer.prepareToPlay()
            buttonSoundPlayer.play()
            print("AudioController: Efecto de sonido del botón reproducido")
            // Nota: Este reproductor se libera al salir del método.
        } catch {
            print("AudioController: Error al reproducir el efecto de sonido: \(error)")
        }
    }
    
    
    // MARK: - Funciones para detección de notas
    private func updateStability(frequency: Float) {
        if abs(frequency - lastStableFrequency) <= stabilityThreshold {
            if stabilityStartTime == nil {
                stabilityStartTime = Date()
            }
            stabilityDuration = Date().timeIntervalSince(stabilityStartTime ?? Date())
        } else {
            lastStableFrequency = frequency
            stabilityStartTime = nil
            stabilityDuration = 0
        }
    }
    
    private func processPitchData(frequency: Float, amplitude: Float) {
        self.smoothedAmplitude = (self.amplitudeSmoothing * self.smoothedAmplitude) + ((1 - self.amplitudeSmoothing) * amplitude)
        let currentTime = Date()
        guard currentTime.timeIntervalSince(lastProcessedTime) >= minimumProcessingInterval else {
            return
        }
        lastProcessedTime = currentTime
        
        if self.smoothedAmplitude > minimumAmplitude,
           frequency >= minimumFrequency && frequency <= maximumFrequency {
            
            let tunerData = tunerEngine.processPitch(frequency: frequency, amplitude: self.smoothedAmplitude)
            // Actualiza la UI en tiempo real sin esperar al hold:
            DispatchQueue.main.async {
                // Por ejemplo, podrías notificar al delegado o actualizar una propiedad publicada
                // Aquí actualizamos el tunerData para que los nodos que observan esa propiedad se actualicen:
                self.tunerData = tunerData
                // Si tienes otro mecanismo para actualizar la UI, hazlo aquí.
            }
            
            // Luego, si se cumple el hold, dispara el evento de acierto
            let requiredHoldTime = delegate?.audioControllerRequiredHoldTime(self) ?? 1.0
            if tunerEngine.updateHoldDetection(note: tunerData.note,
                                               currentTime: currentTime.timeIntervalSinceReferenceDate,
                                               requiredHoldTime: requiredHoldTime) {
                DispatchQueue.main.async {
                    print("🎵 Nota validada tras hold: \(tunerData.note) (requiredHoldTime: \(requiredHoldTime) s)")
                    self.delegate?.audioController(self, didDetectNote: tunerData.note, frequency: frequency, amplitude: self.smoothedAmplitude, deviation: tunerData.deviation)
                }
            }
            updateStability(frequency: frequency)
        } else {
            DispatchQueue.main.async {
                self.tunerData = .inactive
                self.stabilityDuration = 0
                self.delegate?.audioControllerDidDetectSilence(self)
            }
        }
    }
    
    private init() {
        do {
            try AVAudioSession.sharedInstance().setCategory(.playAndRecord,
                                                            options: [.defaultToSpeaker, .mixWithOthers])
            try AVAudioSession.sharedInstance().setActive(true)
            
            guard let input = engine.input else {
                print("Error: No se detectó entrada de audio")
                return
            }
            
            mic = input
            silence = Fader(mic, gain: 0)
            engine.output = silence
            
            pitchTap = PitchTap(mic) { [weak self] frequency, amplitude in
                guard let self = self else { return }
                self.processPitchData(frequency: frequency[0], amplitude: amplitude[0])
            }
            
            try engine.start()
            print("Motor de audio iniciado correctamente")
            
        } catch {
            print("Error en la inicialización del audio: \(error)")
        }
    }
    
    var microphonePermissionStatus: Bool {
        AVCaptureDevice.authorizationStatus(for: .audio) == .authorized
    }
    
    func start() {
        guard mic != nil else {
            print("Error: Input de audio no disponible")
            return
        }
        // Resetear valores al iniciar
        smoothedAmplitude = 0
        stabilityDuration = 0
        lastProcessedTime = Date()
        stabilityStartTime = nil
        lastStableFrequency = 0
        tunerData = .inactive
        
        pitchTap.start()
    }
    
    func stop() {
        pitchTap.stop()
        DispatchQueue.main.async {
            self.tunerData = .inactive
            self.stabilityDuration = 0
        }
    }
}
</file>

<file path="MusicBlocks/Audio/TunerEngine.swift">
//
//  TunerEngine.swift
//  MusicBlocks
//
//  Created by Jose R. García on 13/3/25.
//  Actualización: Se añade la lógica de acumulación para el hold de la nota.
//

import Foundation

class TunerEngine {
    static let shared = TunerEngine()
    
    // MARK: - Types
    struct TunerData {
        let note: String          // Nota con alteración y octava
        let frequency: Float      // Frecuencia en Hz
        let deviation: Double     // Desviación en cents
        let isActive: Bool        // Si hay suficiente amplitud para detectar
        
        static let inactive = TunerData(note: "-", frequency: 0, deviation: 0, isActive: false)
    }
    
    // MARK: - Properties
    private let concertPitch: Double = 442.0
    
    // Propiedades para la acumulación del hold
    private var noteHoldAccumulator: TimeInterval = 0
    private var lastDetectionTime: TimeInterval? = nil
    private var currentStableNote: String = "-"
    
    // MARK: - Public Methods
    /// Procesa una frecuencia y amplitud para obtener datos de afinación.
    /// Este método se mantiene sin modificaciones ya que su función es la conversión.
    func processPitch(frequency: Float, amplitude: Float) -> TunerData {
        let minAmplitude: Float = 0.05
        
        guard amplitude > minAmplitude else {
            return .inactive
        }
        
        let (note, deviation) = processFrequency(frequency)
        return TunerData(
            note: note,
            frequency: frequency,
            deviation: deviation,
            isActive: true
        )
    }
    
    /// Parsea una nota desde un string.
    func parseNote(_ noteString: String) -> MusicalNote? {
        return MusicalNote.parse(noteString)
    }
    
    /// Actualiza el acumulador de "hold" para la nota detectada.
    /// - Parameters:
    ///   - note: La nota detectada en este frame.
    ///   - currentTime: El timestamp actual.
    ///   - requiredHoldTime: El tiempo requerido (en segundos) para considerar que la nota se ha mantenido estable.
    /// - Returns: true si el acumulador alcanza o supera el tiempo requerido; false en caso contrario.
    func updateHoldDetection(note: String, currentTime: TimeInterval, requiredHoldTime: TimeInterval) -> Bool {
        if note == currentStableNote {
            if let lastTime = lastDetectionTime {
                noteHoldAccumulator += (currentTime - lastTime)
            }
        } else {
            currentStableNote = note
            noteHoldAccumulator = 0
        }
        lastDetectionTime = currentTime
        
        // Mensaje de debug para seguir el acumulador
        print("TunerEngine - Nota detectada: \(note), acumulador de hold: \(noteHoldAccumulator) segundos")
        
        // Solo se considera válida si la nota no es un silencio ("-")
        if note != "-" && noteHoldAccumulator >= requiredHoldTime {
            print("TunerEngine - Éxito: la nota \(note) se mantuvo estable por \(noteHoldAccumulator) segundos (requerido: \(requiredHoldTime) segundos)")
            noteHoldAccumulator = 0  // Reiniciar el acumulador al alcanzar el tiempo requerido
            return true
        }
        return false
    }
    
    // MARK: - Private Methods
    private func processFrequency(_ frequency: Float) -> (String, Double) {
        guard frequency > 0 else { return ("-", 0) }
        
        let actualFrequency = Double(frequency)
        let halfStepsFromA4 = 12 * log2(actualFrequency / concertPitch)
        let roundedHalfSteps = round(halfStepsFromA4)
        let deviation = 100 * (halfStepsFromA4 - roundedHalfSteps)
        
        let midiNoteNumber = Int(roundedHalfSteps) + 69
        let octave = (midiNoteNumber / 12) - 1
        let noteIndex = ((midiNoteNumber % 12) + 12) % 12
        
        let (noteName, alteration) = getNoteNameAndAlteration(forMIDINote: noteIndex)
        return ("\(noteName)\(alteration.rawValue)\(octave)", deviation)
    }
    
    private func getNoteNameAndAlteration(forMIDINote index: Int) -> (String, MusicalNote.Alteration) {
        switch index {
        case 0: return ("DO", .natural)
        case 1: return Bool.random() ? ("DO", .sharp) : ("RE", .flat)
        case 2: return ("RE", .natural)
        case 3: return Bool.random() ? ("RE", .sharp) : ("MI", .flat)
        case 4: return ("MI", .natural)
        case 5: return ("FA", .natural)
        case 6: return Bool.random() ? ("FA", .sharp) : ("SOL", .flat)
        case 7: return ("SOL", .natural)
        case 8: return Bool.random() ? ("SOL", .sharp) : ("LA", .flat)
        case 9: return ("LA", .natural)
        case 10: return Bool.random() ? ("LA", .sharp) : ("SI", .flat)
        case 11: return ("SI", .natural)
        default: return ("", .natural)
        }
    }
}
</file>

<file path="MusicBlocks/Bloques/BlockContentGenerator.swift">
//
//  BlockContentGenerator.swift
//  MusicBlocks
//
//  Created by Jose R. García on 3/3/25.
//

import SpriteKit

/// Este struct agrupa funciones para generar el contenido visual interno de un bloque,
/// es decir, el pentagrama, la clave de sol, la imagen de la nota, los accidentales y las ledger lines.
struct BlockContentGenerator {
    
    /// Genera el contenido visual de un bloque.
    static func generateBlockContent(
        with style: BlockStyle,
        blockSize: CGSize,
        desiredNote: MusicalNote,
        baseNoteX: CGFloat,
        baseNoteY: CGFloat,
        leftMargin: CGFloat = 30,
        rightMargin: CGFloat = 30
    ) -> SKNode {
        let contentNode = SKNode()
        
        // MARK: PENTAGRAMA
        let staffPath = CGMutablePath()
        let lineSpacing: CGFloat = 12
        for i in 0..<5 {
            let y = 24 - CGFloat(i) * lineSpacing
            staffPath.move(to: CGPoint(x: -blockSize.width/2 + leftMargin, y: y))
            staffPath.addLine(to: CGPoint(x: blockSize.width/2 - rightMargin, y: y))
        }
        let staffLines = SKShapeNode(path: staffPath)
        staffLines.strokeColor = .black
        staffLines.lineWidth = 2
        staffLines.zPosition = 1
        contentNode.addChild(staffLines)
        
        // MARK: CLAVE DE SOL
        let trebleClef = SKSpriteNode(imageNamed: "trebleClef")
        trebleClef.size = CGSize(width: 50, height: 95)
        trebleClef.position = CGPoint(x: -blockSize.width/2 + leftMargin + 25, y: -2)
        trebleClef.zPosition = 2
        contentNode.addChild(trebleClef)
        
        // MARK: NOTA
        let noteOffset = getNoteOffset(for: desiredNote)
        let notePosition = CGPoint(
            x: baseNoteX,
            y: baseNoteY + noteOffset.y
        )
        
        let noteImage = SKSpriteNode(imageNamed: "wholeNote")
        noteImage.size = CGSize(width: 23, height: 23)
        noteImage.position = notePosition
        noteImage.zPosition = 3
        contentNode.addChild(noteImage)
        
        // MARK: ALTERACIONES
        if desiredNote.alteration != .natural {
            let accidentalImage = SKSpriteNode(imageNamed: getAccidentalImageName(for: desiredNote.alteration))
            accidentalImage.size = CGSize(width: 45, height: 80)
            accidentalImage.position = CGPoint(x: notePosition.x - 23, y: notePosition.y)
            accidentalImage.zPosition = 3
            contentNode.addChild(accidentalImage)
        }
        
        // MARK: LÍNEAS ADICIONALES
        addLedgerLines(for: notePosition.y, in: contentNode, for: desiredNote)
        
        print("Contenido del bloque generado para nota: \(desiredNote.fullName)")
        return contentNode
    }
    
    private static func getNoteOffset(for note: MusicalNote) -> CGPoint {
           // Tabla que mapea la combinación de nombre de nota y octava a su offset vertical
           let baseOffsets: [String: CGFloat] = [
               "DO": -36,
               "RE": -30,
               "MI": -24,
               "FA": -18,
               "SOL": -12,
               "LA": -6,
               "SI": 0
           ]
           
           guard let baseOffset = baseOffsets[note.name] else {
               return .zero
           }
           
           // Ajustar el offset según la octava
           let octaveOffset = CGFloat(note.octave - 4) * 42
           return CGPoint(x: 0, y: baseOffset + octaveOffset)
       }
    
    private static func getAccidentalImageName(for alteration: MusicalNote.Alteration) -> String {
        switch alteration {
        case .sharp:
            return "sharp"
        case .flat:
            return "flat"
        case .natural:
            return ""  // No debería llegar aquí, pero por completitud
        }
    }
    
    /// Dibuja ledger lines (líneas adicionales) si la nota se sale del pentagrama.
    ///
    /// - Parameters:
    ///   - noteY: La posición Y de la nota.
    ///   - node: El nodo al que se añadirán las ledger lines.
    ///   - note: La nota (MusicalNote) para la cual se determinarán las líneas adicionales.
    private static func addLedgerLines(for noteY: CGFloat, in node: SKNode, for note: MusicalNote) {
        let staffTop: CGFloat = 30
        let staffBottom: CGFloat = -30
        let ledgerLineWidth: CGFloat = 30
        let ledgerLineThickness: CGFloat = 2.0
        
        func createLedgerLine(at ledgerY: CGFloat) {
            let path = CGMutablePath()
            path.move(to: CGPoint(x: -ledgerLineWidth / 2, y: ledgerY))
            path.addLine(to: CGPoint(x: ledgerLineWidth / 2, y: ledgerY))
            let ledgerLine = SKShapeNode(path: path)
            ledgerLine.strokeColor = .black
            ledgerLine.lineWidth = ledgerLineThickness
            ledgerLine.zPosition = 3.5
            node.addChild(ledgerLine)
        }
        
        // Para "Do6" y "La3", dibujamos dos ledger lines.
        let isHigh = note.name == "DO" && note.octave == 6
                let isLow = note.name == "LA" && note.octave == 3
                
                if isHigh {
                    createLedgerLine(at: staffTop + 6)
                    createLedgerLine(at: staffTop + 18)
                } else if isLow {
                    createLedgerLine(at: staffBottom - 6)
                    createLedgerLine(at: staffBottom - 18)
                } else {
                    if noteY > staffTop {
                        createLedgerLine(at: staffTop + 6)
                    } else if noteY < staffBottom {
                        createLedgerLine(at: staffBottom - 6)
                    }
                }
            }
        }

#if DEBUG
import SwiftUI

// Vista previa del contenido de un bloque
struct BlockPreview: PreviewProvider {
    static var previews: some View {
        BlockPreviewView()
            .frame(width: 300, height: 200)
            .previewLayout(.fixed(width: 300, height: 200))
            .preferredColorScheme(.light)
    }
}

// Vista del bloque para la preview
struct BlockPreviewView: View {
    var body: some View {
        SpriteView(scene: createPreviewScene())
    }
    
    private func createPreviewScene() -> SKScene {
        let scene = SKScene(size: CGSize(width: 300, height: 200))
        scene.backgroundColor = .white
        
        // Crear un bloque de ejemplo
        let blockSize = CGSize(width: 270, height: 110)
        let exampleNote = MusicalNote(name: "LA", alteration: .sharp, octave: 4)
        
        // Crear el contenedor del bloque
        let blockNode = SKNode()
        blockNode.position = CGPoint(x: scene.size.width/2, y: scene.size.height/2)
        
        // Crear el fondo del bloque
        let background = SKShapeNode(rectOf: blockSize, cornerRadius: 15)
        background.fillColor = .white
        background.strokeColor = .black
        background.lineWidth = 2
        blockNode.addChild(background)
        
        // Generar el contenido (pentagrama, nota, etc.)
        let content = BlockContentGenerator.generateBlockContent(
            with: .defaultBlock,
            blockSize: blockSize,
            desiredNote: exampleNote,
            baseNoteX: 0,
            baseNoteY: 0
        )
        blockNode.addChild(content)
        
        scene.addChild(blockNode)
        return scene
    }
}

// Vista previa de diferentes notas
struct BlockNotesPreview: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            Text("Ejemplos de Bloques Musicales")
                .font(.headline)
            
            VStack(spacing: 20) {
                BlockNoteView(note: MusicalNote(name: "DO", alteration: .natural, octave: 6))
                    .frame(width: 270, height: 110)
                BlockNoteView(note: MusicalNote(name: "FA", alteration: .sharp, octave: 4))
                    .frame(width: 270, height: 110)
            }
            
            VStack(spacing: 20) {
                BlockNoteView(note: MusicalNote(name: "LA", alteration: .flat, octave: 4))
                    .frame(width: 270, height: 110)
                BlockNoteView(note: MusicalNote(name: "LA", alteration: .natural, octave: 3))
                    .frame(width: 270, height: 110)
            }
        }
        .padding()
        .background(Color.white.opacity(0.1))
        .previewLayout(.fixed(width: 600, height: 400))
    }
}

// Vista individual de un bloque con una nota específica
struct BlockNoteView: View {
    let note: MusicalNote
    
    var body: some View {
        SpriteView(scene: createNoteScene())
            .border(Color.gray, width: 1)
    }
    
    private func createNoteScene() -> SKScene {
        let scene = SKScene(size: CGSize(width: 270, height: 110))
        scene.backgroundColor = .white
        
        let blockNode = SKNode()
        blockNode.position = CGPoint(x: scene.size.width/2, y: scene.size.height/2)
        
        let background = SKShapeNode(rectOf: scene.size, cornerRadius: 15)
        background.fillColor = .white
        background.strokeColor = .black
        background.lineWidth = 2
        blockNode.addChild(background)
        
        let content = BlockContentGenerator.generateBlockContent(
            with: .iceBlock,
            blockSize: scene.size,
            desiredNote: note,
            baseNoteX: 0,
            baseNoteY: 0
        )
        blockNode.addChild(content)
        
        scene.addChild(blockNode)
        return scene
    }
}
#endif
</file>

<file path="MusicBlocks/Bloques/BlocksManager.swift">
//
//  BlocksManager.swift
//  MusicBlocks
//
//  Creado por Jose R. García el 14/3/25.
//  Versión modificada: Se han añadido mensajes de debug para seguir el flujo de todas las funciones.
//

import SpriteKit

class BlocksManager {
    
    // MARK: - Properties
    private var blockInfos: [BlockInfo] = []
    private var blocks: [SKNode] = []
    private let blockSize: CGSize
    private let blockSpacing: CGFloat
    private weak var mainAreaNode: SKNode?
    private var mainAreaHeight: CGFloat = 0
    private let gameManager = GameManager.shared
    
    // Para controlar la generación de bloques
        private var spawnAction: SKAction?
        private var isGeneratingBlocks: Bool = false
        
        // Ahora interpretamos estos como tiempos en SEGUNDOS:
        // spawnInterval = “tiempo entre bloques”
        // spawnIntervalDecrement = “segundos que restamos tras cada bloque”
        private var spawnInterval: TimeInterval
        private var spawnIntervalDecrement: TimeInterval
    
    // MARK: - Constants
        private struct Constants {
            static let initialDelay: TimeInterval = 1.0
            static let minSpawnInterval: TimeInterval = 1.5
        }
        
        // MARK: - Initialization
        init(blockSize: CGSize = CGSize(width: 280, height: 120),
             blockSpacing: CGFloat = 1.0,
             mainAreaNode: SKNode?,
             mainAreaHeight: CGFloat) {
            
            self.blockSize = blockSize
            self.blockSpacing = blockSpacing
            self.mainAreaNode = mainAreaNode
            self.mainAreaHeight = mainAreaHeight
            
            // Leemos la “velocidad” del nivel, pero la usamos como spawnInterval (segundos).
            if let fallingSpeed = GameManager.shared.currentLevel?.fallingSpeed {
                // Por ejemplo: initial=8.0 => 8s entre bloques, increment=2.0 => restar 2s cada bloque
                self.spawnInterval = fallingSpeed.initial
                self.spawnIntervalDecrement = fallingSpeed.increment
            } else {
                // Valores por defecto
                self.spawnInterval = 4.0
                self.spawnIntervalDecrement = 0.0
            }
            
            print("🔧 BlocksManager inicializado. blockSize: \(blockSize), " +
                  "mainAreaHeight: \(mainAreaHeight), " +
                  "spawnInterval inicial: \(spawnInterval) s, " +
                  "decremento: \(spawnIntervalDecrement) s")
        }
    
    // MARK: - Iniciando generación de bloques
    func startBlockGeneration() {
        print("▶️ startBlockGeneration llamado.")
        guard !isGeneratingBlocks else {
            print("ℹ️ La generación de bloques ya está en curso.")
            return
        }
        isGeneratingBlocks = true
        
        // Esperamos un delay inicial (opcional)
        let initialDelay = SKAction.wait(forDuration: 1.0) // Por ejemplo 1s
        
        // Cuando acabe el delay, llamamos a spawnLoop()
        let beginAction = SKAction.run { [weak self] in
            self?.spawnLoop()
        }
        
        let sequence = SKAction.sequence([initialDelay, beginAction])
        mainAreaNode?.run(sequence)
        
        print("✅ Generación de bloques iniciada - spawnInterval: \(spawnInterval) s")
    }

    /// Bucle “recursivo” que genera 1 bloque, actualiza el spawnInterval
    /// y programa la siguiente aparición.
    private func spawnLoop() {
        // 1) Verificar si seguimos generando
        guard isGeneratingBlocks else {
            print("🛑 Generación detenida, no se continúa el loop.")
            return
        }
        
        // 2) Generar el bloque
        spawnBlock()
        
        // 3) Ajustar spawnInterval (acelerar)
        let newInterval = max(spawnInterval - spawnIntervalDecrement, Constants.minSpawnInterval)
        spawnInterval = newInterval
        print("🚀 Nuevo spawnInterval = \(spawnInterval) s (restado \(spawnIntervalDecrement))")
        
        // 4) Programar la siguiente aparición usando el spawnInterval actual
        let wait = SKAction.wait(forDuration: spawnInterval)
        let nextCall = SKAction.run { [weak self] in
            self?.spawnLoop()
        }
        let sequence = SKAction.sequence([wait, nextCall])
        
        mainAreaNode?.run(sequence)
    }

    /// Detener la generación
    func stopBlockGeneration() {
        print("⏹️ stopBlockGeneration llamado.")
        guard isGeneratingBlocks else {
            print("ℹ️ La generación de bloques ya está detenida.")
            return
        }
        isGeneratingBlocks = false
        // También puedes remover todas las acciones del mainAreaNode si quieres
        mainAreaNode?.removeAllActions()
        print("✅ Generación de bloques detenida.")
    }
    
    // MARK: - Block Generation
    private func generateNote(for blockConfig: Block) -> MusicalNote? {
        guard let randomNoteString = blockConfig.notes.randomElement() else {
            print("❌ Error: No hay notas disponibles en la configuración del bloque")
            return nil
        }
        
        print("📢 Intentando parsear nota: \(randomNoteString)")
        if let note = MusicalNote.parseSpanishFormat(randomNoteString) {
            print("✅ Nota generada correctamente: \(note.fullName)")
            return note
        } else {
            print("❌ Error al parsear la nota: \(randomNoteString)")
            return nil
        }
    }
    
    private func createBlock() -> SKNode {
        print("➡️ Creando nuevo bloque...")
        guard let currentLevel = gameManager.currentLevel else {
            print("❌ Error: No hay nivel actual")
            return createDefaultBlock()
        }
        
        let blockNode = SKNode()
        blockNode.zPosition = 2
        
        let allowedStyles = currentLevel.allowedStyles
        print("📝 Estilos permitidos: \(allowedStyles)")
        
        guard let randomStyle = allowedStyles.randomElement() else {
            print("❌ Error: No hay estilos permitidos")
            return createDefaultBlock()
        }
        
        guard let config = currentLevel.blocks[randomStyle] else {
            print("❌ Error: No se encontró configuración para el bloque \(randomStyle)")
            return createDefaultBlock()
        }
        
        guard let randomNoteString = config.notes.randomElement(),
              let note = MusicalNote.parseSpanishFormat(randomNoteString),
              let blockStyle = getBlockStyle(for: randomStyle) else {
            print("❌ Error: Falló la generación del bloque, usando bloque por defecto.")
            return createDefaultBlock()
        }
        
        // Crear contenedor y contenido visual
        let container = createBlockContainer(with: blockStyle)
        blockNode.addChild(container)
        
        let contentNode = BlockContentGenerator.generateBlockContent(
            with: blockStyle,
            blockSize: blockSize,
            desiredNote: note,
            baseNoteX: 5,
            baseNoteY: 0,
            leftMargin: 30,
            rightMargin: 30
        )
        contentNode.position = .zero
        contentNode.zPosition = 3
        blockNode.addChild(contentNode)
        
        // Guardar metadata del bloque
        let userData = NSMutableDictionary()
        userData.setValue(note.fullName, forKey: "noteName")
        userData.setValue(randomStyle, forKey: "blockStyle")
        userData.setValue(config.requiredHits, forKey: "requiredHits")
        userData.setValue(config.requiredTime, forKey: "requiredTime")
        blockNode.userData = userData
        
        print("✅ Bloque creado con nota: \(note.fullName) y estilo: \(randomStyle)")
        return blockNode
    }
    
    // MARK: - Block Creation Methods
    func spawnBlock() {
            print("➡️ spawnBlock llamado.")
            guard let mainAreaNode = mainAreaNode,
                  isGeneratingBlocks else {
                print("❌ No se pueden generar bloques: generación detenida o mainAreaNode es nil")
                return
            }
            
            // Verificar espacio
            if let firstBlock = blocks.first {
                let topLimit = mainAreaHeight/2 - blockSize.height/2
                let firstBlockTopEdge = firstBlock.position.y + blockSize.height/2
                
                if abs(firstBlockTopEdge - topLimit) < blockSpacing {
                    print("⏸️ Esperando espacio para nuevo bloque.")
                    return
                }
            }
            
            let newBlock = createBlock()
            
            if let blockInfo = createBlockInfo(for: newBlock) {
                let startY = mainAreaHeight/2 - blockSize.height/2
                newBlock.position = CGPoint(x: 0, y: startY)
                mainAreaNode.addChild(newBlock)
                blocks.insert(newBlock, at: 0)
                blockInfos.insert(blockInfo, at: 0)
                
                print("✅ Bloque añadido en posición Y: \(startY)")
                updateBlockPositions()
            } else {
                print("❌ Error al crear la metadata del bloque.")
            }
        }
    
    private func createBlockInfo(for block: SKNode) -> BlockInfo? {
//        print("📋 Creando BlockInfo para bloque.")
        guard let userData = block.userData,
              let noteData = userData.value(forKey: "noteName") as? String,
              let styleData = userData.value(forKey: "blockStyle") as? String,
              let config = gameManager.getBlockConfig(for: styleData),
              let requiredHits = userData.value(forKey: "requiredHits") as? Int,
              let requiredTime = userData.value(forKey: "requiredTime") as? TimeInterval else {
            print("❌ Error: Bloque creado sin datos válidos")
            return nil
        }
        
        let info = BlockInfo(
            node: block,
            note: noteData,
            style: styleData,
            config: config,
            requiredHits: requiredHits,
            requiredTime: requiredTime
        )
        print("✅ BlockInfo creado: nota \(noteData), estilo \(styleData), requiredHits: \(requiredHits), requiredTime: \(requiredTime)")
        return info
    }
    
    // MARK: - Block Visual Components
    private func createBlockContainer(with style: BlockStyle) -> SKNode {
//        print("🖼️ Creando contenedor para bloque con estilo: \(style)")
        let container = SKNode()
        container.zPosition = 0
        
        if let shadowColor = style.shadowColor,
           let shadowOffset = style.shadowOffset,
           let shadowBlur = style.shadowBlur {
            let shadowNode = createShadowNode(
                color: shadowColor,
                offset: shadowOffset,
                blur: shadowBlur,
                cornerRadius: style.cornerRadius
            )
            container.addChild(shadowNode)
//            print("🖼️ Sombra añadida al contenedor.")
        }
        
        let background = createBackground(with: style)
        container.addChild(background)
//        print("🖼️ Fondo añadido al contenedor.")
        
        return container
    }
    
    private func createShadowNode(color: SKColor, offset: CGSize, blur: CGFloat, cornerRadius: CGFloat) -> SKNode {
//        print("🖌️ Creando shadowNode con color: \(color), offset: \(offset), blur: \(blur)")
        let shadowNode = SKEffectNode()
        shadowNode.shouldRasterize = true
        shadowNode.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": blur])
        shadowNode.zPosition = 1
        
        let shadowShape = SKShapeNode(rectOf: blockSize, cornerRadius: cornerRadius)
        shadowShape.fillColor = color
        shadowShape.strokeColor = .clear
        shadowShape.alpha = 0.5
        
        shadowNode.addChild(shadowShape)
        shadowNode.position = CGPoint(x: offset.width, y: offset.height)
        
        return shadowNode
    }
    
    private func createBackground(with style: BlockStyle) -> SKNode {
//        print("🖌️ Creando background para bloque con estilo: \(style)")
        let background = SKShapeNode(rectOf: blockSize, cornerRadius: style.cornerRadius)
        background.fillColor = style.backgroundColor
        background.strokeColor = style.borderColor
        background.lineWidth = style.borderWidth
        background.zPosition = 2
        
        if let texture = style.fillTexture {
            background.fillTexture = texture
            background.alpha = style.textureOpacity
//            print("🖼️ Texture aplicada al background.")
        }
        
        return background
    }
    
    
    // MARK: - Block Position Management
    private func updateBlockPositions() {
        print("↕️ Actualizando posiciones de \(blocks.count) bloques.")
        let moveDistance = blockSize.height + blockSpacing
        let moveDuration = 0.5
        
        for (index, block) in blocks.enumerated() {
            // Calcular la posición final para cada bloque
            let targetY = (mainAreaHeight/2) - (blockSize.height/2) - (moveDistance * CGFloat(index))
            print("   Bloque \(index): moviéndose a Y = \(targetY)")
            // Mover el bloque a su posición con una animación suave
            let moveToPosition = SKAction.moveTo(y: targetY, duration: moveDuration)
            moveToPosition.timingMode = .easeInEaseOut
            
            // Detener cualquier acción previa
            block.removeAllActions()
            
            // Aplicar solo el movimiento de posicionamiento
            block.run(moveToPosition)
        }
    }
    
    // MARK: - Game State Checks
    func hasBlocksBelowLimit() -> Bool {
        let bottomLimit = -mainAreaHeight/2
        let result = blocks.contains { block in
            let blockBottom = block.position.y - blockSize.height/2
            let hasReachedLimit = blockBottom <= bottomLimit
            if hasReachedLimit {
                print("⚠️ Bloque ha alcanzado la zona de peligro. blockBottom: \(blockBottom), bottomLimit: \(bottomLimit)")
            }
            return hasReachedLimit
        }
        return result
    }
    
    // MARK: - Public Interface
    var currentBlocks: [SKNode] { blocks }
    
    var blockCount: Int { blocks.count }
    
    func clearBlocks() {
        print("🧹 Limpiando bloques...")
        stopBlockGeneration()
        for block in blocks {
            block.removeFromParent()
        }
        blocks.removeAll()
        blockInfos.removeAll()
        print("🧹 Bloques eliminados.")
    }
    
    func getCurrentBlock() -> BlockInfo? {
        print("🔍 Consultando bloque actual...")
        if let current = blockInfos.last {
            print("🔍 Bloque actual: nota \(current.note), estilo \(current.style)")
        } else {
            print("🔍 No hay bloque actual.")
        }
        return blockInfos.last
    }
    
    // MARK: - Block Style Management
    private func selectBlockStyleBasedOnWeights(from blocks: [String: Block]) -> BlockStyle {
        print("🔀 Seleccionando estilo basado en pesos...")
        var weightedStyles: [(BlockStyle, Double)] = []
        
        for (styleName, blockConfig) in blocks {
            if let style = getBlockStyle(for: styleName) {
                weightedStyles.append((style, blockConfig.weight))
                print("   Estilo \(styleName) con peso \(blockConfig.weight) añadido.")
            }
        }
        
        guard !weightedStyles.isEmpty else {
            print("⚠️ No se encontraron estilos con peso. Se retorna defaultBlock.")
            return .defaultBlock
        }
        
        let totalWeight = weightedStyles.reduce(0) { $0 + $1.1 }
        let randomValue = Double.random(in: 0..<totalWeight)
        print("   Total de peso: \(totalWeight), valor aleatorio: \(randomValue)")
        
        var accumulatedWeight = 0.0
        for (style, weight) in weightedStyles {
            accumulatedWeight += weight
            if randomValue < accumulatedWeight {
                print("   Estilo seleccionado: \(style)")
                return style
            }
        }
        
        print("   Estilo seleccionado por defecto: \(weightedStyles[0].0)")
        return weightedStyles[0].0
    }
    
    private func getBlockStyle(for styleName: String) -> BlockStyle? {
        print("🔍 Buscando estilo: \(styleName)")
        switch styleName {
        case "defaultBlock": return .defaultBlock
        case "iceBlock": return .iceBlock
        case "hardIceBlock": return .hardiceBlock
        case "ghostBlock": return .ghostBlock
        case "changingBlock": return .changingBlock
        default:
            print("⚠️ Estilo no reconocido: \(styleName)")
            return nil
        }
    }
    
    private func createDefaultBlock() -> SKNode {
        print("❓ Creando bloque por defecto.")
        let blockNode = SKNode()
        let style = BlockStyle.defaultBlock
        let container = createBlockContainer(with: style)
        blockNode.addChild(container)
        return blockNode
    }
    
    // MARK: - Block State Management
    func getCurrentNote() -> String? {
        let note = blocks.first?.userData?.value(forKey: "noteName") as? String
        print("🔍 Nota actual: \(note ?? "ninguna")")
        return note
    }
    
    func removeLastBlock() {
        print("🗑️ Eliminando último bloque...")
        guard let lastBlock = blocks.last,
              !blockInfos.isEmpty else {
            print("⚠️ No hay bloque para eliminar.")
            return
        }
        
        let fadeOut = SKAction.fadeOut(withDuration: 0.3)
        let scaleDown = SKAction.scale(to: 0.1, duration: 0.3)
        let group = SKAction.group([fadeOut, scaleDown])
        let remove = SKAction.removeFromParent()
        let sequence = SKAction.sequence([group, remove])
        
        lastBlock.run(sequence) { [weak self] in
            guard let self = self else { return }
            print("🗑️ Bloque eliminado. Actualizando lista de bloques...")
            self.blocks.removeLast()
            self.blockInfos.removeLast()
            self.updateBlockPositions()
        }
    }
    
    // MARK: - Block Progress Management
    func updateCurrentBlockProgress(hitTime: Date) -> Bool {
        print("⏱️ updateCurrentBlockProgress llamado a las \(hitTime)")
        guard let index = blockInfos.indices.last else {
            print("⚠️ No hay bloque actual para actualizar.")
            return false
        }
        
        var currentInfo = blockInfos[index]
        print("   Bloque actual: nota \(currentInfo.note), currentHits: \(currentInfo.currentHits)")
        
        if currentInfo.holdStartTime == nil {
            currentInfo.holdStartTime = hitTime
            blockInfos[index] = currentInfo
            print("   Se inicia el hold del bloque a \(hitTime)")
        }
        
        let holdDuration = Date().timeIntervalSince(currentInfo.holdStartTime ?? Date())
        print("   Duración del hold: \(holdDuration) (requerida: \(currentInfo.requiredTime))")
        
        if holdDuration >= currentInfo.requiredTime {
            currentInfo.currentHits += 1
            print("   Hit registrado. currentHits ahora: \(currentInfo.currentHits)")
            currentInfo.holdStartTime = nil
            blockInfos[index] = currentInfo
            
            if currentInfo.currentHits >= currentInfo.requiredHits {
                print("   Requisitos completos (hits: \(currentInfo.currentHits), requeridos: \(currentInfo.requiredHits)). Se eliminará el bloque.")
                removeLastBlock()
                return true
            }
        }
        
        return false
    }
    
    func resetCurrentBlockProgress() {
        print("🔄 Reset current block progress")
        guard let index = blockInfos.indices.last else {
            print("⚠️ No hay bloque actual para resetear.")
            return
        }
        var currentInfo = blockInfos[index]
        currentInfo.currentHits = 0
        currentInfo.holdStartTime = nil
        blockInfos[index] = currentInfo
        print("   Progreso del bloque reseteado.")
    }
    
}
</file>

<file path="MusicBlocks/Bloques/BlockStyle.swift">
//
//  BlockStyle.swift
//  MusicBlocks
//
//  Created by Jose R. García on 3/3/25.
//

import SpriteKit

struct BlockStyle {
    // Identificador y propiedades básicas
    let name: String
    
    // Relleno y borde
    let backgroundColor: SKColor
    let borderColor: SKColor
    let borderWidth: CGFloat
    let cornerRadius: CGFloat
    
    // Sombra (opcional)
    let shadowColor: SKColor?
    let shadowOffset: CGSize?
    let shadowBlur: CGFloat?
    
    // Textura
    let fillTexture: SKTexture?
    let textureOpacity: CGFloat
    let textureScale: CGFloat
    
    // Comportamiento especial (opcional)
    let specialBehavior: SpecialBehavior?
    
    enum SpecialBehavior {
        case ghost(fadeOutAlpha: CGFloat, fadeInAlpha: CGFloat, duration: TimeInterval)
        case changing(changeInterval: TimeInterval)
        case explosive(holdTime: TimeInterval)
    }
}

extension BlockStyle {
    static let defaultBlock = BlockStyle(
        name: "defaultBlock",
        backgroundColor: .white,
        borderColor: .black,
        borderWidth: 3.0,
        cornerRadius: 20.0,
        shadowColor: .gray,
        shadowOffset: CGSize(width: 3, height: -3),
        shadowBlur: 4.0,
        fillTexture: nil,
        textureOpacity: 1.0,
        textureScale: 1.0,
        specialBehavior: nil
    )
    
    static let iceBlock = BlockStyle(
        name: "iceBlock",
        backgroundColor: SKColor(red: 0.8, green: 0.9, blue: 1.0, alpha: 0.5),
        borderColor: SKColor(red: 0.5, green: 0.7, blue: 0.9, alpha: 1.0),
        borderWidth: 3.0,
        cornerRadius: 20.0,
        shadowColor: SKColor.blue,
        shadowOffset: CGSize(width: 2, height: -2),
        shadowBlur: 4.0,
        fillTexture: SKTexture(imageNamed: "iceTexture4"),
        textureOpacity: 0.5,
        textureScale: 1.0,
        specialBehavior: nil
    )
    
    static let hardiceBlock = BlockStyle(
        name: "hardiceBlock",
        backgroundColor: SKColor(red: 0.6, green: 0.8, blue: 1.0, alpha: 1.0),
        borderColor: SKColor.blue,
        borderWidth: 3.0,
        cornerRadius: 20.0,
        shadowColor: SKColor.darkGray,
        shadowOffset: CGSize(width: 3, height: -3),
        shadowBlur: 3.0,
        fillTexture: SKTexture(imageNamed: "iceTexture3"),
        textureOpacity: 0.2,
        textureScale: 1.0,
        specialBehavior: nil
    )
    
    static let ghostBlock = BlockStyle(
        name: "ghostBlock",
        backgroundColor: SKColor(white: 0.9, alpha: 0.5),
        borderColor: SKColor(white: 0.8, alpha: 0.7),
        borderWidth: 3.0,
        cornerRadius: 20.0,
        shadowColor: nil,
        shadowOffset: nil,
        shadowBlur: nil,
        fillTexture: SKTexture(imageNamed: "ghostTexture"),
        textureOpacity: 1.0,
        textureScale: 1.0,
        specialBehavior: .ghost(fadeOutAlpha: 0.2, fadeInAlpha: 0.7, duration: 0.5)
    )
    
    static let changingBlock = BlockStyle(
        name: "changingBlock",
        backgroundColor: SKColor(red: 0.8, green: 0.6, blue: 1.0, alpha: 1.0),
        borderColor: SKColor.magenta,
        borderWidth: 3.0,
        cornerRadius: 20.0,
        shadowColor: SKColor.purple,
        shadowOffset: CGSize(width: 2, height: -2),
        shadowBlur: 4.0,
        fillTexture: SKTexture(imageNamed: "wavesTexture"),
        textureOpacity: 1.0,
        textureScale: 1.0,
        specialBehavior: .changing(changeInterval: 1.0)
    )
    
    static let explosiveBlock = BlockStyle(
        name: "explosiveBlock",
        backgroundColor: SKColor(red: 1.0, green: 0.5, blue: 0.0, alpha: 1.0),
        borderColor: SKColor.red,
        borderWidth: 3.0,
        cornerRadius: 20.0,
        shadowColor: SKColor.red,
        shadowOffset: CGSize(width: 4, height: -4),
        shadowBlur: 6.0,
        fillTexture: SKTexture(imageNamed: "explosionTexture"),
        textureOpacity: 1.0,
        textureScale: 1.0,
        specialBehavior: .explosive(holdTime: 4.0)
    )
}
</file>

<file path="MusicBlocks/Bloques/MusicalNote.swift">
//
//  MusicalNote.swift
//  MusicBlocks
//
//  Created by Jose R. García on 3/3/25.
//

import CoreGraphics
import Foundation

/// Sistema unificado para la gestión de notas musicales
struct MusicalNote: Equatable, Identifiable {
    // MARK: - Types
    enum Alteration: String {
        case sharp = "#"    /// Sostenido
        case flat = "♭"     /// Bemol
        case natural = ""   /// Natural
    }
    
    // MARK: - Properties
    let id = UUID()
    let name: String         // Nombre de la nota (DO, RE, MI, etc.)
    let alteration: Alteration
    let octave: Int
    
    // MARK: - Computed Properties
    var fullName: String {
        "\(name)\(alteration.rawValue)\(octave)"
    }
    
    var displayName: String {
        let baseName = name.capitalized
        return alteration == .natural ? baseName : "\(baseName)\(alteration.rawValue)"
    }
    
    /// Posición vertical de la nota en el pentagrama
    var staffOffset: CGPoint {
        let baseOffset: [String: CGFloat] = [
            "DO": -36,
            "RE": -30,
            "MI": -24,
            "FA": -18,
            "SOL": -12,
            "LA": -6,
            "SI": 0
        ]
        
        guard let offset = baseOffset[name] else { return .zero }
        return CGPoint(x: 0, y: offset + (CGFloat(octave - 4) * 42))
    }
    
    // MARK: - Static Properties
    private static let enharmonicEquivalents: [String: String] = [
        "DO#": "RE♭", "RE♭": "DO#",
        "RE#": "MI♭", "MI♭": "RE#",
        "FA#": "SOL♭", "SOL♭": "FA#",
        "SOL#": "LA♭", "LA♭": "SOL#",
        "LA#": "SI♭", "SI♭": "LA#"
    ]
    
    // MARK: - Static Methods
    /// Genera todas las notas disponibles en el rango del juego
    static func generateAvailableNotes() -> [MusicalNote] {
        var notes: [MusicalNote] = []
        
        func addNote(_ name: String, octave: Int) {
            notes.append(MusicalNote(name: name, alteration: .natural, octave: octave))
            
            switch name {
            case "DO": 
                notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
            case "RE":
                notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
                notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
            case "MI": 
                notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
            case "FA": 
                notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
            case "SOL":
                notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
                notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
            case "LA":
                notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
                notes.append(MusicalNote(name: name, alteration: .sharp, octave: octave))
            case "SI": 
                notes.append(MusicalNote(name: name, alteration: .flat, octave: octave))
            default: break
            }
        }
        
        // Notas de la octava 3 (empezando desde LA)
        ["LA", "SI"].forEach { name in
            addNote(name, octave: 3)
        }
        
        // Notas de las octavas 4 y 5
        for octave in 4...5 {
            ["DO", "RE", "MI", "FA", "SOL", "LA", "SI"].forEach { name in
                addNote(name, octave: octave)
            }
        }
        
        // Nota DO de la octava 6
        addNote("DO", octave: 6)
        
        return notes
    }
    
    /// Parsea una nota desde un string
    static func parse(_ noteString: String) -> MusicalNote? {
        let pattern = "([A-Z]+)([#♭]?)([0-9])"
        let regex = try? NSRegularExpression(pattern: pattern, options: [])
        
        if let match = regex?.firstMatch(in: noteString, options: [], range: NSRange(noteString.startIndex..., in: noteString)) {
            let name = String(noteString[Range(match.range(at: 1), in: noteString)!])
            let alterationString = String(noteString[Range(match.range(at: 2), in: noteString)!])
            let octave = Int(String(noteString[Range(match.range(at: 3), in: noteString)!]))!
            
            let alteration: Alteration = alterationString == "#" ? .sharp :
                                       alterationString == "♭" ? .flat : .natural
            
            return MusicalNote(name: name, alteration: alteration, octave: octave)
        }
        return nil
    }
    
    // MARK: - Instance Methods
    func isEnharmonicWith(_ other: MusicalNote) -> Bool {
        let thisNote = "\(name)\(alteration.rawValue)"
        let otherNote = "\(other.name)\(other.alteration.rawValue)"
        
        return MusicalNote.enharmonicEquivalents[thisNote] == otherNote && octave == other.octave
    }
    
    // MARK: - Equatable
    static func == (lhs: MusicalNote, rhs: MusicalNote) -> Bool {
        return lhs.fullName == rhs.fullName || lhs.isEnharmonicWith(rhs)
    }
    
    
}

// MARK: - Note Format Conversion
extension MusicalNote {
    private static let noteNameMap: [String: String] = [
        "do": "DO", "DO": "DO",
        "re": "RE", "RE": "RE",
        "mi": "MI", "MI": "MI",
        "fa": "FA", "FA": "FA",
        "sol": "SOL", "SOL": "SOL",
        "la": "LA", "LA": "LA",
        "si": "SI", "SI": "SI"
    ]
    
    /// Parsea una nota desde un string en formato español (ej: "sol4", "la#4", "si♭3")
    static func parseSpanishFormat(_ noteString: String) -> MusicalNote? {
        // Patrón para capturar: nombre de nota (en minúsculas o mayúsculas),
        // alteración opcional (#, b, ♭) y número de octava
        let pattern = "([a-zA-Z]+)([#b♭]?)([0-9])"
        let regex = try? NSRegularExpression(pattern: pattern, options: [])
        
        if let match = regex?.firstMatch(in: noteString, options: [], range: NSRange(noteString.startIndex..., in: noteString)) {
            let noteName = String(noteString[Range(match.range(at: 1), in: noteString)!])
            let alterationString = String(noteString[Range(match.range(at: 2), in: noteString)!])
            let octave = Int(String(noteString[Range(match.range(at: 3), in: noteString)!]))!
            
            // Convertir el nombre de la nota al formato esperado
            guard let standardName = noteNameMap[noteName.lowercased()] else {
                print("❌ Nombre de nota no reconocido: \(noteName)")
                return nil
            }
            
            // Determinar la alteración
            let alteration: Alteration
            switch alterationString {
            case "#":
                alteration = .sharp
            case "b", "♭":
                alteration = .flat
            default:
                alteration = .natural
            }
            
            print("✅ Nota parseada: \(standardName)\(alteration.rawValue)\(octave)")
            return MusicalNote(name: standardName, alteration: alteration, octave: octave)
        }
        
        print("❌ No se pudo parsear la nota: \(noteString)")
        return nil
    }
}
</file>

<file path="MusicBlocks/Inicio y Profile/AchievementBadge.swift">
//
//  AchievementBadge.swift
//  MusicBlocks
//
//  Created by Jose R. García on 28/2/25.
//

import UIKit

// MARK: - Medal Models
struct MedalCategory {
    let type: MedalType
    let medals: [MedalInfo]
    
    var title: String {
        switch type {
        case .notesHit:
            return "Precisión Musical"
        case .playTime:
            return "Dedicación"
        case .streaks:
            return "Racha"
        case .perfectTuning:
            return "Afinación"
        }
    }
}

enum MedalType: String {
    case notesHit = "notes_hit"
    case playTime = "play_time"
    case streaks = "streaks"
    case perfectTuning = "perfect_tuning"
}

extension MedalType: CaseIterable {
    var icon: String {
        switch self {
        case .notesHit:
            return "🎵"
        case .playTime:
            return "⏱"
        case .streaks:
            return "🔥"
        case .perfectTuning:
            return "⭐️"
        }
    }
    
    var title: String {
        switch self {
        case .notesHit:
            return "Precisión Musical"
        case .playTime:
            return "Dedicación"
        case .streaks:
            return "Racha"
        case .perfectTuning:
            return "Afinación"
        }
    }
    
    var shortTitle: String {
        switch self {
        case .notesHit:
            return "Precisión"
        case .playTime:
            return "Tiempo"
        case .streaks:
            return "Rachas"
        case .perfectTuning:
            return "Afinación"
        }
    }
}

struct MedalInfo {
    let name: String
    let requirement: String
    let image: String
    let objective: MedalObjective?
    var isUnlocked: Bool
    
    init(from medal: Medal, isUnlocked: Bool = false) {
        self.name = medal.name
        self.requirement = medal.requirement
        self.image = medal.image
        self.objective = medal.objective
        self.isUnlocked = isUnlocked
    }
}

// MARK: - Medal Manager
final class MedalManager {
    static let shared = MedalManager()
    
    private(set) var medals: [MedalCategory] = []
    private var gameConfig: GameConfig?
    
    private init() {
        loadMedals()
    }
    
    func loadMedals() {
        gameConfig = GameLevelProcessor.loadGameLevelsFromFile()
        if let config = gameConfig {
            let medalsData = GameLevelProcessor.getMedals(from: config)
            
            medals = [
                MedalCategory(type: .notesHit, medals: medalsData.notesHit.map { MedalInfo(from: $0) }),
                MedalCategory(type: .playTime, medals: medalsData.playTime.map { MedalInfo(from: $0) }),
                MedalCategory(type: .streaks, medals: medalsData.streaks.map { MedalInfo(from: $0) }),
                MedalCategory(type: .perfectTuning, medals: medalsData.perfectTuning.map { MedalInfo(from: $0) })
            ]
            loadMedalsProgress()
        }
    }
    
    func getMedals() -> [MedalCategory] {
        return medals
    }
    
    func updateMedals(notesHit: Int, playTime: TimeInterval, currentStreak: Int, perfectTuningCount: Int) {
        medals = medals.map { category in
            var updatedMedals = category.medals
            
            switch category.type {
            case .notesHit:
                updatedMedals = category.medals.map { medal in
                    var updatedMedal = medal
                    if let requirement = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
                        updatedMedal.isUnlocked = notesHit >= requirement
                    }
                    return updatedMedal
                }
            case .playTime:
                updatedMedals = category.medals.map { medal in
                    var updatedMedal = medal
                    let playTimeHours = playTime / 3600
                    if medal.requirement.contains("minutos") {
                        if let minutes = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
                            updatedMedal.isUnlocked = playTimeHours * 60 >= Double(minutes)
                        }
                    } else if medal.requirement.contains("horas") {
                        if let hours = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
                            updatedMedal.isUnlocked = playTimeHours >= Double(hours)
                        }
                    }
                    return updatedMedal
                }
            case .streaks:
                updatedMedals = category.medals.map { medal in
                    var updatedMedal = medal
                    if let requirement = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
                        updatedMedal.isUnlocked = currentStreak >= requirement
                    }
                    return updatedMedal
                }
            case .perfectTuning:
                updatedMedals = category.medals.map { medal in
                    var updatedMedal = medal
                    if let requirement = Int(medal.requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
                        updatedMedal.isUnlocked = perfectTuningCount >= requirement
                    }
                    return updatedMedal
                }
            }
            
            return MedalCategory(type: category.type, medals: updatedMedals)
        }
        
        saveMedalsProgress()
    }
    
    private func saveMedalsProgress() {
        let progress = medals.map { category in
            return (category.type.rawValue, category.medals.map { $0.isUnlocked })
        }
        
        let progressDict = Dictionary(uniqueKeysWithValues: progress)
        UserDefaults.standard.set(progressDict, forKey: "medalsProgress")
    }
    
    private func loadMedalsProgress() {
        if let progressDict = UserDefaults.standard.dictionary(forKey: "medalsProgress") as? [String: [Bool]] {
            medals = medals.map { category in
                let unlockedStates = progressDict[category.type.rawValue] ?? Array(repeating: false, count: category.medals.count)
                let updatedMedals = zip(category.medals, unlockedStates).map { medal, isUnlocked in
                    MedalInfo(
                        from: Medal(
                            name: medal.name,
                            requirement: medal.requirement,
                            image: medal.image,
                            objective: medal.objective ?? createDefaultObjective(for: category.type, requirement: medal.requirement)
                        ),
                        isUnlocked: isUnlocked
                    )
                }
                return MedalCategory(type: category.type, medals: updatedMedals)
            }
        }
    }

    private func createDefaultObjective(for type: MedalType, requirement: String) -> MedalObjective {
        let target = extractTarget(from: requirement)
        
        switch type {
        case .notesHit:
            return MedalObjective(
                type: type.rawValue,
                target: target,
                lifetime: true,
                resetOnFail: false,
                accuracy: nil
            )
        case .playTime:
            return MedalObjective(
                type: type.rawValue,
                target: target,
                lifetime: true,
                resetOnFail: false,
                accuracy: nil
            )
        case .streaks:
            return MedalObjective(
                type: type.rawValue,
                target: target,
                lifetime: false,
                resetOnFail: true,
                accuracy: nil
            )
        case .perfectTuning:
            return MedalObjective(
                type: type.rawValue,
                target: target,
                lifetime: true,
                resetOnFail: false,
                accuracy: 1.0
            )
        }
    }

    private func extractTarget(from requirement: String) -> Int {
        if let target = Int(requirement.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) {
            if requirement.contains("minutos") {
                return target * 60
            } else if requirement.contains("horas") {
                return target * 3600
            }
            return target
        }
        return 0
    }
}
</file>

<file path="MusicBlocks/Inicio y Profile/AchievementsView.swift">
//
//  AchievementsView.swift
//  MusicBlocks
//
//  Created by Jose R. García on 1/3/25.
//

import UIKit

class AchievementsView: UIView {
    private let stackView: UIStackView = {
        let stack = UIStackView()
        stack.axis = .vertical
        stack.spacing = 16 // Reducido de 24 a 16
        return stack
    }()
    
    private let medalStatsView = MedalStatsView()
    private let medalsGridView = MedalsGridView()
    
    init(medals: [MedalCategory]) {
        super.init(frame: .zero)
        setupViews()
        configure(with: medals)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupViews() {
        stackView.translatesAutoresizingMaskIntoConstraints = false
        addSubview(stackView)
        
        stackView.addArrangedSubview(medalStatsView)
        stackView.addArrangedSubview(medalsGridView)
        
        NSLayoutConstraint.activate([
            stackView.topAnchor.constraint(equalTo: topAnchor, constant: 4), // Reducido de 8 a 4
            stackView.leadingAnchor.constraint(equalTo: leadingAnchor),
            stackView.trailingAnchor.constraint(equalTo: trailingAnchor),
            stackView.bottomAnchor.constraint(equalTo: bottomAnchor)
        ])
    }
    
    func configure(with medals: [MedalCategory]) {
        medalStatsView.configure(with: medals)
        medalsGridView.configure(with: medals)
    }
}

// MARK: - Medal Stats View
class MedalStatsView: UIView {
    private let titleLabel: UILabel = {
        let label = UILabel()
        label.text = "Progreso de Medallas"
        label.font = .systemFont(ofSize: 17, weight: .semibold)
        return label
    }()
    
    private let subtitleLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 14)
        label.textColor = .secondaryLabel
        return label
    }()
    
    private let typeStackView: UIStackView = {
        let stack = UIStackView()
        stack.axis = .horizontal
        stack.distribution = .fillEqually
        stack.spacing = 16
        return stack
    }()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupViews()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupViews() {
        [titleLabel, subtitleLabel, typeStackView].forEach {
            $0.translatesAutoresizingMaskIntoConstraints = false
            addSubview($0)
        }
        
        NSLayoutConstraint.activate([
            titleLabel.topAnchor.constraint(equalTo: topAnchor, constant: 16),
            titleLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
            
            subtitleLabel.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 4),
            subtitleLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
            
            typeStackView.topAnchor.constraint(equalTo: subtitleLabel.bottomAnchor, constant: 16),
            typeStackView.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
            typeStackView.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
            typeStackView.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -16)
        ])
        
        layer.cornerRadius = 12
        backgroundColor = .systemGray6
    }
    
    func configure(with medals: [MedalCategory]) {
        // Limpiar vista previa
        typeStackView.arrangedSubviews.forEach { $0.removeFromSuperview() }
        
        // Calcular totales
        let totalStats = getTotalStats(from: medals)
        subtitleLabel.text = "\(totalStats.unlocked) de \(totalStats.total) medallas desbloqueadas"
        
        // Crear vistas para cada tipo
        MedalType.allCases.forEach { type in
            if let category = medals.first(where: { $0.type == type }) {
                let stats = getCategoryStats(for: category)
                let typeView = MedalTypeView(
                    type: type,
                    unlockedCount: stats.unlocked,
                    totalCount: stats.total
                )
                typeStackView.addArrangedSubview(typeView)
            }
        }
    }
    
    private func getTotalStats(from medals: [MedalCategory]) -> (unlocked: Int, total: Int) {
        let unlocked = medals.reduce(0) { $0 + $1.medals.filter { $0.isUnlocked }.count }
        let total = medals.reduce(0) { $0 + $1.medals.count }
        return (unlocked, total)
    }
    
    private func getCategoryStats(for category: MedalCategory) -> (unlocked: Int, total: Int) {
        let unlocked = category.medals.filter { $0.isUnlocked }.count
        return (unlocked, category.medals.count)
    }
}

// MARK: - Medal Type View
class MedalTypeView: UIView {
    private let iconLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 24)
        label.textAlignment = .center
        return label
    }()
    
    private let statsLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 12, weight: .medium)
        label.textAlignment = .center
        return label
    }()
    
    private let titleLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 10)
        label.textColor = .secondaryLabel
        label.textAlignment = .center
        return label
    }()
    
    init(type: MedalType, unlockedCount: Int, totalCount: Int) {
        super.init(frame: .zero)
        setupViews()
        configure(with: type, unlockedCount: unlockedCount, totalCount: totalCount)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupViews() {
        [iconLabel, statsLabel, titleLabel].forEach {
            $0.translatesAutoresizingMaskIntoConstraints = false
            addSubview($0)
        }
        
        NSLayoutConstraint.activate([
            iconLabel.topAnchor.constraint(equalTo: topAnchor, constant: 8),
            iconLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
            
            statsLabel.topAnchor.constraint(equalTo: iconLabel.bottomAnchor, constant: 4),
            statsLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
            
            titleLabel.topAnchor.constraint(equalTo: statsLabel.bottomAnchor, constant: 2),
            titleLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
            titleLabel.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -8)
        ])
        
        layer.cornerRadius = 8
    }
    
    private func configure(with type: MedalType, unlockedCount: Int, totalCount: Int) {
        iconLabel.text = type.icon
        statsLabel.text = "\(unlockedCount)/\(totalCount)"
        titleLabel.text = type.shortTitle
        backgroundColor = typeColor(for: type).withAlphaComponent(0.1)
    }
    
    private func typeColor(for type: MedalType) -> UIColor {
        switch type {
        case .notesHit:
            return .systemBlue
        case .playTime:
            return .systemRed
        case .streaks:
            return .systemYellow
        case .perfectTuning:
            return .systemPurple
        }
    }
}

// MARK: - Medals Grid View
class MedalsGridView: UIView {
    private let stackView: UIStackView = {
        let stack = UIStackView()
        stack.axis = .vertical
        stack.spacing = 16
        return stack
    }()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupViews()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupViews() {
        stackView.translatesAutoresizingMaskIntoConstraints = false
        addSubview(stackView)
        
        NSLayoutConstraint.activate([
            stackView.topAnchor.constraint(equalTo: topAnchor),
            stackView.leadingAnchor.constraint(equalTo: leadingAnchor),
            stackView.trailingAnchor.constraint(equalTo: trailingAnchor),
            stackView.bottomAnchor.constraint(equalTo: bottomAnchor)
        ])
    }
    
    func configure(with medals: [MedalCategory]) {
        // Limpiar vista previa
        stackView.arrangedSubviews.forEach { $0.removeFromSuperview() }
        
        // Crear sección para cada categoría
        medals.forEach { category in
            let categoryView = MedalCategoryView(category: category)
            stackView.addArrangedSubview(categoryView)
        }
    }
}

// MARK: - Medal Category View
class MedalCategoryView: UIView {
    private let titleLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 17, weight: .semibold)
        return label
    }()
    
    private let statsLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 12)
        label.textColor = .secondaryLabel
        return label
    }()
    
    private let scrollView: UIScrollView = {
        let scroll = UIScrollView()
        scroll.showsHorizontalScrollIndicator = false
        return scroll
    }()
    
    private let medalsStack: UIStackView = {
        let stack = UIStackView()
        stack.axis = .horizontal
        stack.spacing = 12
        return stack
    }()
    
    init(category: MedalCategory) {
        super.init(frame: .zero)
        setupViews()
        configure(with: category)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupViews() {
        [titleLabel, statsLabel, scrollView].forEach {
            $0.translatesAutoresizingMaskIntoConstraints = false
            addSubview($0)
        }
        
        scrollView.addSubview(medalsStack)
        medalsStack.translatesAutoresizingMaskIntoConstraints = false
        
        NSLayoutConstraint.activate([
            titleLabel.topAnchor.constraint(equalTo: topAnchor),
            titleLabel.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
            
            statsLabel.centerYAnchor.constraint(equalTo: titleLabel.centerYAnchor),
            statsLabel.leadingAnchor.constraint(equalTo: titleLabel.trailingAnchor, constant: 8),
            
            scrollView.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 12),
            scrollView.leadingAnchor.constraint(equalTo: leadingAnchor),
            scrollView.trailingAnchor.constraint(equalTo: trailingAnchor),
            scrollView.bottomAnchor.constraint(equalTo: bottomAnchor),
            
            medalsStack.topAnchor.constraint(equalTo: scrollView.topAnchor),
            medalsStack.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor, constant: 16),
            medalsStack.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor, constant: -16),
            medalsStack.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
            medalsStack.heightAnchor.constraint(equalTo: scrollView.heightAnchor)
        ])
    }
    
    private func configure(with category: MedalCategory) {
        titleLabel.text = category.title
        let stats = getCategoryStats(for: category)
        statsLabel.text = "\(stats.unlocked)/\(stats.total)"
        
        category.medals.forEach { medal in
            let medalView = MedalView(
                medalInfo: medal,
                color: typeColor(for: category.type)
            )
            medalsStack.addArrangedSubview(medalView)
        }
    }
    
    private func getCategoryStats(for category: MedalCategory) -> (unlocked: Int, total: Int) {
        let unlocked = category.medals.filter { $0.isUnlocked }.count
        return (unlocked, category.medals.count)
    }
    
    private func typeColor(for type: MedalType) -> UIColor {
        switch type {
        case .notesHit:
            return .systemBlue
        case .playTime:
            return .systemRed
        case .streaks:
            return .systemYellow
        case .perfectTuning:
            return .systemPurple
        }
    }
}

// MARK: - Medal View
class MedalView: UIView {
    private let imageView: UIImageView = {
        let imageView = UIImageView()
        imageView.contentMode = .scaleAspectFit
        return imageView
    }()
    
    private let lockImageView: UIImageView = {
        let imageView = UIImageView()
        imageView.image = UIImage(systemName: "lock.fill")
        imageView.tintColor = .white
        return imageView
    }()
    
    private let nameLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 12, weight: .medium)
        label.textAlignment = .center
        label.numberOfLines = 0
        return label
    }()
    
    private let requirementLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 10)
        label.textColor = .secondaryLabel
        label.textAlignment = .center
        label.numberOfLines = 0
        return label
    }()
    
    init(medalInfo: MedalInfo, color: UIColor) {
        super.init(frame: .zero)
        setupViews()
        configure(with: medalInfo, color: color)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupViews() {
        [imageView, lockImageView, nameLabel, requirementLabel].forEach {
            $0.translatesAutoresizingMaskIntoConstraints = false
            addSubview($0)
        }
        
        NSLayoutConstraint.activate([
            imageView.topAnchor.constraint(equalTo: topAnchor, constant: 8),
            imageView.centerXAnchor.constraint(equalTo: centerXAnchor),
            imageView.widthAnchor.constraint(equalToConstant: 60),
            imageView.heightAnchor.constraint(equalToConstant: 60),
            
            lockImageView.centerXAnchor.constraint(equalTo: imageView.centerXAnchor),
            lockImageView.centerYAnchor.constraint(equalTo: imageView.centerYAnchor),
            lockImageView.widthAnchor.constraint(equalToConstant: 20),
            lockImageView.heightAnchor.constraint(equalToConstant: 20),
            
            nameLabel.topAnchor.constraint(equalTo: imageView.bottomAnchor, constant: 8),
            nameLabel.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 8),
            nameLabel.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -8),
            
            requirementLabel.topAnchor.constraint(equalTo: nameLabel.bottomAnchor, constant: 4),
            requirementLabel.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 8),
            requirementLabel.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -8),
            requirementLabel.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -8)
        ])
        
        layer.cornerRadius = 12
        backgroundColor = .systemGray6
        
        // Establecer ancho fijo para cada medalla
        widthAnchor.constraint(equalToConstant: 120).isActive = true
    }
    
    private func configure(with medalInfo: MedalInfo, color: UIColor) {
        // Configurar imagen
        imageView.image = UIImage(named: medalInfo.image)
        imageView.alpha = medalInfo.isUnlocked ? 1.0 : 0.3
        
        // Configurar visibilidad del candado
        lockImageView.isHidden = medalInfo.isUnlocked
        
        // Configurar textos
        nameLabel.text = medalInfo.name
        nameLabel.textColor = medalInfo.isUnlocked ? .label : .secondaryLabel
        
        requirementLabel.text = medalInfo.requirement
        
        // Configurar borde
        layer.borderWidth = 2
        layer.borderColor = medalInfo.isUnlocked ? color.cgColor : UIColor.systemGray.cgColor
        
        // Configurar opacidad general
        alpha = medalInfo.isUnlocked ? 1.0 : 0.8
        
        // Añadir superposición oscura si está bloqueada
        if !medalInfo.isUnlocked {
            let overlayView = UIView()
            overlayView.backgroundColor = .black
            overlayView.alpha = 0.3
            overlayView.translatesAutoresizingMaskIntoConstraints = false
            insertSubview(overlayView, aboveSubview: imageView)
            
            NSLayoutConstraint.activate([
                overlayView.topAnchor.constraint(equalTo: imageView.topAnchor),
                overlayView.leadingAnchor.constraint(equalTo: imageView.leadingAnchor),
                overlayView.trailingAnchor.constraint(equalTo: imageView.trailingAnchor),
                overlayView.bottomAnchor.constraint(equalTo: imageView.bottomAnchor)
            ])
            
            overlayView.layer.cornerRadius = 30
            overlayView.clipsToBounds = true
        }
    }
}

#if DEBUG
import SwiftUI

// Función helper para obtener medallas de prueba
private func getMockMedals() -> [MedalCategory] {
    guard let gameConfig = GameLevelProcessor.loadGameLevelsFromFile(),
          let medals = try? JSONDecoder().decode(Medals.self, from: JSONEncoder().encode(gameConfig.medals)) else {
        return []
    }
    
    return [
        MedalCategory(
            type: .notesHit,
            medals: medals.notesHit.map { medal in
                MedalInfo(
                    from: medal,
                    isUnlocked: Bool.random() // Para la preview, algunas estarán desbloqueadas al azar
                )
            }
        ),
        MedalCategory(
            type: .playTime,
            medals: medals.playTime.map { medal in
                MedalInfo(
                    from: medal,
                    isUnlocked: Bool.random()
                )
            }
        ),
        MedalCategory(
            type: .streaks,
            medals: medals.streaks.map { medal in
                MedalInfo(
                    from: medal,
                    isUnlocked: Bool.random()
                )
            }
        ),
        MedalCategory(
            type: .perfectTuning,
            medals: medals.perfectTuning.map { medal in
                MedalInfo(
                    from: medal,
                    isUnlocked: Bool.random()
                )
            }
        )
    ]
}

@available(iOS 17.0, *)
struct AchievementsView_Previews: PreviewProvider {
    static var previews: some View {
        AchievementsViewRepresentable()
            .frame(height: 600)
            .padding()
            .previewDisplayName("Light Mode")
        
        AchievementsViewRepresentable()
            .frame(height: 600)
            .padding()
            .preferredColorScheme(.dark)
            .previewDisplayName("Dark Mode")
    }
    
    private struct AchievementsViewRepresentable: UIViewRepresentable {
        func makeUIView(context: Context) -> AchievementsView {
            let mockMedals = getMockMedals()
            return AchievementsView(medals: mockMedals)
        }
        
        func updateUIView(_ uiView: AchievementsView, context: Context) {}
    }
}

@available(iOS 17.0, *)
struct MedalStatsView_Previews: PreviewProvider {
    static var previews: some View {
        UIViewPreview {
            let view = MedalStatsView()
            view.configure(with: getMockMedals())
            return view
        }
        .frame(height: 200)
        .padding()
        .previewLayout(.sizeThatFits)
        .previewDisplayName("Medal Stats View")
    }
}

@available(iOS 17.0, *)
struct MedalsGridView_Previews: PreviewProvider {
    static var previews: some View {
        UIViewPreview {
            let view = MedalsGridView()
            view.configure(with: getMockMedals())
            return view
        }
        .frame(height: 400)
        .padding()
        .previewLayout(.sizeThatFits)
        .previewDisplayName("Medals Grid View")
    }
}

// Helper para previews de UIView
struct UIViewPreview<View: UIView>: UIViewRepresentable {
    let view: View
    
    init(_ builder: @escaping () -> View) {
        view = builder()
    }
    
    func makeUIView(context: Context) -> View {
        return view
    }
    
    func updateUIView(_ view: View, context: Context) {
        view.setContentHuggingPriority(.defaultHigh, for: .horizontal)
        view.setContentHuggingPriority(.defaultHigh, for: .vertical)
    }
}
#endif
</file>

<file path="MusicBlocks/Inicio y Profile/AvatarPickerViewController.swift">
//
//  AvatarPickerViewController.swift
//  MusicBlocks
//
//  Created by Jose R. García on 1/3/25.
//

import UIKit

protocol AvatarPickerViewControllerDelegate: AnyObject {
    func avatarPicker(_ picker: AvatarPickerViewController, didSelect avatar: String)
}

class AvatarPickerViewController: UIViewController, UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {
    private let collectionView: UICollectionView
    private let availableAvatars: [String]
    private var selectedAvatar: String
    
    weak var delegate: AvatarPickerViewControllerDelegate?
    
    init(selectedAvatar: String, availableAvatars: [String]) {
        self.selectedAvatar = selectedAvatar
        self.availableAvatars = availableAvatars
        
        // Configurar el layout con tamaños estimados
        let layout = UICollectionViewFlowLayout()
        layout.scrollDirection = .vertical
        layout.minimumLineSpacing = 16
        layout.minimumInteritemSpacing = 16
        
        self.collectionView = UICollectionView(frame: .zero, collectionViewLayout: layout)
        super.init(nibName: nil, bundle: nil)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupViews()
    }
    
    private func setupViews() {
        title = "Elegir Avatar"
        view.backgroundColor = .systemBackground
        
        // Configurar botones de navegación
        navigationItem.leftBarButtonItem = UIBarButtonItem(
            title: "Cancelar",
            style: .plain,
            target: self,
            action: #selector(handleCancel)
        )
        
        navigationItem.rightBarButtonItem = UIBarButtonItem(
            title: "Guardar",
            style: .done,
            target: self,
            action: #selector(handleSave)
        )
        
        // Configurar collection view
        collectionView.translatesAutoresizingMaskIntoConstraints = false
        collectionView.backgroundColor = .systemBackground
        collectionView.delegate = self
        collectionView.dataSource = self
        collectionView.register(AvatarCell.self, forCellWithReuseIdentifier: "AvatarCell")
        collectionView.contentInset = UIEdgeInsets(top: 16, left: 16, bottom: 16, right: 16)
        
        view.addSubview(collectionView)
        
        NSLayoutConstraint.activate([
            collectionView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            collectionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            collectionView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            collectionView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
    }
    
    @objc private func handleCancel() {
        dismiss(animated: true)
    }
    
    @objc private func handleSave() {
        delegate?.avatarPicker(self, didSelect: selectedAvatar)
    }
    
    // MARK: - UICollectionViewDataSource
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return availableAvatars.count
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "AvatarCell", for: indexPath) as! AvatarCell
        let avatar = availableAvatars[indexPath.item]
        cell.configure(with: avatar, isSelected: avatar == selectedAvatar)
        return cell
    }
    
    // MARK: - UICollectionViewDelegate
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        selectedAvatar = availableAvatars[indexPath.item]
        collectionView.reloadData()
    }
    
    // MARK: - UICollectionViewDelegateFlowLayout
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        let availableWidth = collectionView.bounds.width - 48
        let width = availableWidth / 3
        let height = width * 1.4
        
        return CGSize(width: width, height: height)
    }
}

// MARK: - Avatar Cell
class AvatarCell: UICollectionViewCell {
    private let containerView: UIView = {
        let view = UIView()
        view.backgroundColor = .systemBackground
        view.layer.cornerRadius = 12
        view.clipsToBounds = true
        return view
    }()
    
    private let imageView: UIImageView = {
        let imageView = UIImageView()
        imageView.contentMode = .scaleAspectFit
        imageView.clipsToBounds = true
        return imageView
    }()
    
    private let nameLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 12)
        label.textColor = .secondaryLabel
        label.textAlignment = .center
        return label
    }()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupViews()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupViews() {
        contentView.addSubview(containerView)
        containerView.addSubview(imageView)
        containerView.addSubview(nameLabel)
        
        containerView.translatesAutoresizingMaskIntoConstraints = false
        imageView.translatesAutoresizingMaskIntoConstraints = false
        nameLabel.translatesAutoresizingMaskIntoConstraints = false
        
        NSLayoutConstraint.activate([
            // Container constraints
            containerView.topAnchor.constraint(equalTo: contentView.topAnchor),
            containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
            containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
            
            // Image constraints
            imageView.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 8),
            imageView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 8),
            imageView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -8),
            imageView.heightAnchor.constraint(equalTo: imageView.widthAnchor), // Aspecto cuadrado
            
            // Label constraints
            nameLabel.topAnchor.constraint(equalTo: imageView.bottomAnchor, constant: 4),
            nameLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 4),
            nameLabel.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -4),
            nameLabel.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -8)
        ])
    }
    
    func configure(with avatar: String, isSelected: Bool) {
        imageView.image = UIImage(named: avatar)
        nameLabel.text = avatar
        
        containerView.layer.borderWidth = isSelected ? 3 : 0
        containerView.layer.borderColor = isSelected ? UIColor.systemRed.cgColor : nil
        containerView.backgroundColor = isSelected ? .systemRed.withAlphaComponent(0.1) : .systemBackground
    }
    
    override func prepareForReuse() {
        super.prepareForReuse()
        imageView.image = nil
        nameLabel.text = nil
        containerView.layer.borderWidth = 0
        containerView.layer.borderColor = nil
        containerView.backgroundColor = .systemBackground
    }
}
</file>

<file path="MusicBlocks/Inicio y Profile/ContentView.swift">
//
//  ContentView.swift
//  MusicBlocks
//
//  Created by Jose R. García on 14/2/25.
//

import SwiftUI
import AVFoundation
import SpriteKit

struct ContentView: View {
    @StateObject private var audioController = AudioController.sharedInstance
    @State private var gameVersion: String = "--" // Valor por defecto
    @State private var navigateToGame = false  // Controla la navegación al juego
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 30) {
                Spacer()
                
                // Logo
                VStack(spacing: 15) {
                    Image("logoMusicBlocks")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 320, height: 320)
                }
                .padding(.bottom, 20)
                
                // Botones de navegación
                VStack(spacing: 20) {
                    Button(action: {
                        startGameSequence()
                    }) {
                        HStack {
                            Image(systemName: "gamecontroller")
                            Text("Jugar")
                                .font(.headline)
                        }
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(
                            RoundedRectangle(cornerRadius: 15)
                                .fill(Color.red)
                        )
                        .foregroundColor(.white)
                    }
                    Button(action: {
                        audioController.playButtonSound()
                        // Presentar el ProfileViewController
                        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                           let window = windowScene.windows.first,
                           let rootViewController = window.rootViewController {
                            let profileVC = ProfileViewController()
                            let navController = UINavigationController(rootViewController: profileVC)
                            navController.modalPresentationStyle = .fullScreen
                            rootViewController.present(navController, animated: true)
                        }
                    }) {
                        HStack {
                            Image(systemName: "person.fill")
                            Text("Mi Perfil")
                                .font(.headline)
                        }
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(
                            RoundedRectangle(cornerRadius: 15)
                                .fill(Color.red.opacity(0.8))
                        )
                        .foregroundColor(.white)
                    }
                }
                .padding(.horizontal, 40)
                
                Spacer()
                
                Text(gameVersion)
                    .font(.caption)
                    .foregroundColor(.red)
                    .padding(.bottom, 20)
            }
            .background(Color.white.ignoresSafeArea())
            .navigationBarHidden(true)
            // Navega a MusicBlocksSceneView cuando navigateToGame sea true
            .navigationDestination(isPresented: $navigateToGame) {
                MusicBlocksSceneView()
            }
        }
        .onAppear {
            setupAudio()
            loadGameVersion()
            // Iniciar la música de fondo en el menú
            audioController.startBackgroundMusic()
        }
        .onDisappear {
            audioController.stop()
        }
    }
    
    /// Solicita acceso al micrófono si es necesario.
    private func setupAudio() {
        AVCaptureDevice.requestAccess(for: .audio) { granted in
            if granted {
                DispatchQueue.main.async {
                    // Puedes iniciar alguna acción extra si lo deseas.
                }
            }
        }
    }
    
    /// Carga la versión del juego desde el archivo JSON.
    private func loadGameVersion() {
        if let gameConfig = GameLevelProcessor.loadGameLevelsFromFile() {
            DispatchQueue.main.async {
                self.gameVersion = "v\(gameConfig.gameVersion)"
            }
        }
    }
    
    /// Secuencia para iniciar el juego:
    /// 1. Reproduce el sonido de clic.
    /// 2. Después de 0.2 s, inicia el fade out de la música (duración 0.5 s).
    /// 3. Tras 0.6 s en total, navega a la escena del juego.
    private func startGameSequence() {
        audioController.playButtonSound()
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            audioController.stopBackgroundMusic(duration: 0.3)
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
                navigateToGame = true
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</file>

<file path="MusicBlocks/Inicio y Profile/ExpandableSectionView.swift">
//
//  ExpandableSectionView.swift
//  MusicBlocks
//
//  Created by Jose R. García on 1/3/25.
//

import UIKit

protocol ExpandableSectionViewDelegate: AnyObject {
    func expandableSectionDidToggle(_ section: ExpandableSectionView)
}

class ExpandableSectionView: UIView {
    // MARK: - Properties
    private let headerView: UIView = {
        let view = UIView()
        view.backgroundColor = .systemGray6
        view.layer.cornerRadius = 10
        return view
    }()
    
    private let iconImageView: UIImageView = {
        let imageView = UIImageView()
        imageView.contentMode = .scaleAspectFit
        return imageView
    }()
    
    private let titleLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 17, weight: .semibold)
        return label
    }()
    
    private let chevronImageView: UIImageView = {
        let config = UIImage.SymbolConfiguration(pointSize: 14)
        let imageView = UIImageView()
        imageView.image = UIImage(systemName: "chevron.down", withConfiguration: config)
        imageView.tintColor = .secondaryLabel
        imageView.contentMode = .scaleAspectFit
        return imageView
    }()
    
    private var contentView: UIView?
    private var isExpanded = false
    weak var delegate: ExpandableSectionViewDelegate?
    
    // Constraints que serán activadas/desactivadas
    private var contentConstraints: [NSLayoutConstraint] = []
    private var collapsedConstraint: NSLayoutConstraint?
    
    // MARK: - Initialization
    init(title: String, icon: UIImage?, iconTintColor: UIColor = .systemBlue) {
        super.init(frame: .zero)
        titleLabel.text = title
        iconImageView.image = icon
        iconImageView.tintColor = iconTintColor
        setupViews()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: - Setup
    private func setupViews() {
        [headerView, iconImageView, titleLabel, chevronImageView].forEach {
            $0.translatesAutoresizingMaskIntoConstraints = false
        }
        
        addSubview(headerView)
        headerView.addSubview(iconImageView)
        headerView.addSubview(titleLabel)
        headerView.addSubview(chevronImageView)
        
        setupConstraints()
        setupGesture()
    }
    
    private func setupConstraints() {
        NSLayoutConstraint.activate([
            headerView.topAnchor.constraint(equalTo: topAnchor),
            headerView.leadingAnchor.constraint(equalTo: leadingAnchor),
            headerView.trailingAnchor.constraint(equalTo: trailingAnchor),
            
            iconImageView.leadingAnchor.constraint(equalTo: headerView.leadingAnchor, constant: 16),
            iconImageView.centerYAnchor.constraint(equalTo: headerView.centerYAnchor),
            iconImageView.widthAnchor.constraint(equalToConstant: 24),
            iconImageView.heightAnchor.constraint(equalToConstant: 24),
            
            titleLabel.leadingAnchor.constraint(equalTo: iconImageView.trailingAnchor, constant: 12),
            titleLabel.centerYAnchor.constraint(equalTo: headerView.centerYAnchor),
            
            chevronImageView.trailingAnchor.constraint(equalTo: headerView.trailingAnchor, constant: -16),
            chevronImageView.centerYAnchor.constraint(equalTo: headerView.centerYAnchor),
            chevronImageView.widthAnchor.constraint(equalToConstant: 12),
            chevronImageView.heightAnchor.constraint(equalToConstant: 12),
            
            headerView.heightAnchor.constraint(equalToConstant: 50)
        ])
        
        // Crear constraint para el estado colapsado (hace que el bottom de la vista sea igual al bottom del header)
        collapsedConstraint = bottomAnchor.constraint(equalTo: headerView.bottomAnchor)
        
        // Activar el constraint de colapso inicialmente ya que empezamos colapsados
        collapsedConstraint?.isActive = true
    }
    
    private func setupGesture() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(handleHeaderTap))
        headerView.addGestureRecognizer(tapGesture)
        headerView.isUserInteractionEnabled = true
    }
    
    // MARK: - Public Methods
    func setContentView(_ view: UIView) {
        // Remover vista de contenido y constraints anteriores si existen
        contentView?.removeFromSuperview()
        NSLayoutConstraint.deactivate(contentConstraints)
        contentConstraints.removeAll()
        
        // Configurar nueva vista de contenido
        contentView = view
        if let contentView = contentView {
            contentView.translatesAutoresizingMaskIntoConstraints = false
            addSubview(contentView)
            
            // Crear nuevas constraints para el contenido
            let topConstraint = contentView.topAnchor.constraint(equalTo: headerView.bottomAnchor, constant: 8)
            let leadingConstraint = contentView.leadingAnchor.constraint(equalTo: leadingAnchor)
            let trailingConstraint = contentView.trailingAnchor.constraint(equalTo: trailingAnchor)
            let bottomConstraint = contentView.bottomAnchor.constraint(equalTo: bottomAnchor)
            
            // Guardar las constraints para poder activarlas/desactivarlas después
            contentConstraints = [topConstraint, leadingConstraint, trailingConstraint, bottomConstraint]
            
            // Si la sección está expandida, activar las constraints de contenido y desactivar la de colapso
            if isExpanded {
                NSLayoutConstraint.activate(contentConstraints)
                collapsedConstraint?.isActive = false
                contentView.isHidden = false
                contentView.alpha = 1
            } else {
                // Si está colapsada, ocultar el contenido y no activar sus constraints
                contentView.isHidden = true
                contentView.alpha = 0
            }
        }
    }
    
    // MARK: - Actions
    @objc private func handleHeaderTap() {
        toggleSection()
    }
    
    private func toggleSection() {
        isExpanded.toggle()
        
        UIView.animate(withDuration: 0.3) {
            // Rotar el chevron
            self.chevronImageView.transform = self.isExpanded ?
                CGAffineTransform(rotationAngle: .pi) :
                .identity
            
            if self.isExpanded {
                // Expandir: desactivar constraint de colapso, activar constraints de contenido
                self.collapsedConstraint?.isActive = false
                NSLayoutConstraint.activate(self.contentConstraints)
                self.contentView?.isHidden = false
                self.contentView?.alpha = 1
            } else {
                // Colapsar: desactivar constraints de contenido, activar constraint de colapso
                NSLayoutConstraint.deactivate(self.contentConstraints)
                self.collapsedConstraint?.isActive = true
                self.contentView?.isHidden = true
                self.contentView?.alpha = 0
            }
            
            // Forzar actualización del layout
            self.superview?.layoutIfNeeded()
        }
        
        delegate?.expandableSectionDidToggle(self)
    }
    
    // MARK: - Layout
    override func layoutSubviews() {
        super.layoutSubviews()
        
        // Aplicar sombra al header
        headerView.layer.shadowColor = UIColor.black.cgColor
        headerView.layer.shadowOffset = CGSize(width: 0, height: 2)
        headerView.layer.shadowRadius = 4
        headerView.layer.shadowOpacity = 0.1
        headerView.layer.masksToBounds = false
    }
}
</file>

<file path="MusicBlocks/Inicio y Profile/MusicBlocksApp.swift">
//
//  MusicBlocksApp.swift
//  MusicBlocks
//
//  Created by Jose R. García on 14/2/25.
//

import SwiftUI

@main
struct MusicBlocksApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()

        }
    }
}
</file>

<file path="MusicBlocks/Inicio y Profile/ProfileHeaderView.swift">
//
//  ProfileHeaderView.swift
//  MusicBlocks
//
//  Created by Jose R. García on 1/3/25.
//

import UIKit

protocol ProfileHeaderViewDelegate: AnyObject {
    func profileHeaderView(_ view: ProfileHeaderView, didUpdateUsername username: String)
    func profileHeaderViewDidTapAvatar(_ view: ProfileHeaderView)
}

class ProfileHeaderView: UIView {
    // MARK: - Properties
    private let avatarImageView: UIImageView = {
        let imageView = UIImageView()
        imageView.contentMode = .scaleAspectFit
        imageView.layer.cornerRadius = 12
        imageView.clipsToBounds = true
        imageView.layer.borderWidth = 2
        imageView.layer.borderColor = UIColor.systemRed.cgColor
        return imageView
    }()
    
    private let editAvatarButton: UIButton = {
        let button = UIButton()
        let config = UIImage.SymbolConfiguration(pointSize: 30)
        button.setImage(UIImage(systemName: "pencil.circle.fill", withConfiguration: config), for: .normal)
        button.tintColor = .systemRed
        button.backgroundColor = .white
        button.layer.cornerRadius = 15
        return button
    }()
    
    private let usernameLabel: UILabel = {
            let label = UILabel()
            label.font = .systemFont(ofSize: 20, weight: .medium)
            label.textAlignment = .center
            label.isUserInteractionEnabled = true
            return label
        }()
            
    private func setupGestures() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(usernameTapped))
        usernameLabel.addGestureRecognizer(tapGesture)
    }
    
    @objc private func usernameTapped() {
        handleUsernameTap()
    }
    
    private let editUsernameButton: UIButton = {
        let button = UIButton()
        let config = UIImage.SymbolConfiguration(pointSize: 14)
        button.setImage(UIImage(systemName: "pencil", withConfiguration: config), for: .normal)
        button.tintColor = .systemRed
        return button
    }()
    
    weak var delegate: ProfileHeaderViewDelegate?
    
    // MARK: - Initialization
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupViews()
        setupGestures()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: - Setup
    private func setupViews() {
        [avatarImageView, editAvatarButton, usernameLabel, editUsernameButton].forEach {
            $0.translatesAutoresizingMaskIntoConstraints = false
            addSubview($0)
        }
        
        setupConstraints()
        setupActions()
    }
    
    private func setupConstraints() {
        NSLayoutConstraint.activate([
            avatarImageView.topAnchor.constraint(equalTo: topAnchor, constant: 20),
            avatarImageView.centerXAnchor.constraint(equalTo: centerXAnchor),
            avatarImageView.widthAnchor.constraint(equalToConstant: 120),
            avatarImageView.heightAnchor.constraint(equalToConstant: 160),
            
            editAvatarButton.trailingAnchor.constraint(equalTo: avatarImageView.trailingAnchor, constant: 5),
            editAvatarButton.bottomAnchor.constraint(equalTo: avatarImageView.bottomAnchor, constant: 5),
            editAvatarButton.widthAnchor.constraint(equalToConstant: 30),
            editAvatarButton.heightAnchor.constraint(equalToConstant: 30),
            
            usernameLabel.topAnchor.constraint(equalTo: avatarImageView.bottomAnchor, constant: 15),
            usernameLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
            usernameLabel.bottomAnchor.constraint(equalTo: bottomAnchor),
            
            editUsernameButton.leadingAnchor.constraint(equalTo: usernameLabel.trailingAnchor, constant: 5),
            editUsernameButton.centerYAnchor.constraint(equalTo: usernameLabel.centerYAnchor)
        ])
    }
    
    private func setupActions() {
        editAvatarButton.addTarget(self, action: #selector(handleAvatarTap), for: .touchUpInside)
        editUsernameButton.addTarget(self, action: #selector(handleUsernameTap), for: .touchUpInside)
    }
    
    // MARK: - Configuration
    func configure(with profile: UserProfile) {
        usernameLabel.text = profile.username
        
        if profile.avatarName.isEmpty {
            avatarImageView.image = UIImage(systemName: "person.circle.fill")
            avatarImageView.tintColor = .systemRed
        } else {
            avatarImageView.image = UIImage(named: profile.avatarName)
        }
    }
    
    // MARK: - Actions
    @objc private func handleAvatarTap() {
        delegate?.profileHeaderViewDidTapAvatar(self)
    }

    @objc private func handleUsernameTap() {
        showEditUsernameAlert()
    }
    
    private func showEditUsernameAlert() {
        let alert = UIAlertController(
            title: "Editar nombre",
            message: "Introduce tu nuevo nombre de usuario",
            preferredStyle: .alert
        )
        
        alert.addTextField { textField in
            textField.text = self.usernameLabel.text
            textField.clearButtonMode = .whileEditing
        }
        
        alert.addAction(UIAlertAction(title: "Cancelar", style: .cancel))
        alert.addAction(UIAlertAction(title: "Guardar", style: .default) { [weak self] _ in
            guard let self = self,
                  let textField = alert.textFields?.first,
                  let newUsername = textField.text?.trimmingCharacters(in: .whitespacesAndNewlines),
                  !newUsername.isEmpty else { return }
            
            self.usernameLabel.text = newUsername
            self.delegate?.profileHeaderView(self, didUpdateUsername: newUsername)
        })
        
        // Buscar el view controller más cercano para presentar el alert
        if let viewController = self.findViewController() {
            viewController.present(alert, animated: true)
        } else {
            // Fallback si no encontramos un view controller
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let window = windowScene.windows.first,
               let rootViewController = window.rootViewController {
                var topViewController = rootViewController
                while let presentedViewController = topViewController.presentedViewController {
                    topViewController = presentedViewController
                }
                topViewController.present(alert, animated: true)
            }
        }
    }
    
    // Método auxiliar para encontrar el view controller más cercano
    private func findViewController() -> UIViewController? {
        var responder: UIResponder? = self
        while let nextResponder = responder?.next {
            responder = nextResponder
            if let viewController = responder as? UIViewController {
                return viewController
            }
        }
        return nil
    }
}

#if DEBUG
import SwiftUI

@available(iOS 17.0, *)
struct ProfileHeaderView_Previews: PreviewProvider {
    static var previews: some View {
        // Preview en modo claro
        ProfileHeaderViewRepresentable()
            .frame(height: 250)
            .padding()
            .previewDisplayName("Light Mode")
        
        // Preview en modo oscuro
        ProfileHeaderViewRepresentable()
            .frame(height: 250)
            .padding()
            .preferredColorScheme(.dark)
            .previewDisplayName("Dark Mode")
    }
    
    private struct ProfileHeaderViewRepresentable: UIViewRepresentable {
        func makeUIView(context: Context) -> ProfileHeaderView {
            let view = ProfileHeaderView()
            view.configure(with: UserProfile.mock)
            return view
        }
        
        func updateUIView(_ uiView: ProfileHeaderView, context: Context) {}
    }
}

extension UserProfile {
    static var mock: UserProfile {
        UserProfile(
            username: "Usuario de Prueba",
            avatarName: "avatar1",
            statistics: Statistics(
                totalScore: 1000,
                currentLevel: 5,
                playTime: 3600,
                notesHit: 100,
                currentStreak: 5,
                bestStreak: 10,
                perfectLevelsCount: 2,
                totalGamesPlayed: 15,
                averageAccuracy: 0.85
            ),
            achievements: Achievements(
                unlockedMedals: [:],
                lastUpdateDate: Date()
            )
        )
    }
}
#endif
</file>

<file path="MusicBlocks/Inicio y Profile/ProfileViewController.swift">
//
//  ProfileViewController.swift
//  MusicBlocks
//
//  Created by Jose R. García on 1/3/25.
//

import UIKit
import SpriteKit

/// `ProfileViewController` maneja la visualización y gestión del perfil del usuario.
/// Incluye la información del perfil, estadísticas y logros del usuario.
class ProfileViewController: UIViewController {
    // MARK: - Properties
    
    /// El perfil del usuario actual cargado desde UserDefaults
    private var profile = UserProfile.load()
    
    /// Gestor singleton para manejar las medallas y logros
    private let medalManager = MedalManager.shared
    
    /// ScrollView principal que contiene todo el contenido del perfil
    private var scrollView: UIScrollView!
    
    /// Vista contenedora para todos los elementos del perfil
    private var contentView: UIView!
    
    /// Vista de cabecera que muestra la información básica del perfil (avatar y nombre)
    private var profileHeaderView: ProfileHeaderView!
    
    /// Sección expandible que muestra las estadísticas del usuario
    private var statsSection: ExpandableSectionView!
    
    /// Sección expandible que muestra los logros del usuario
    private var achievementsSection: ExpandableSectionView!
    
    // MARK: - Lifecycle
    
    /// Configura la vista inicial cuando se carga el controlador
    override func viewDidLoad() {
        super.viewDidLoad()
        setupNavigationBar()
        setupViews()
        loadProfile()
    }
    
    // MARK: - Setup
    
    /// Configura la barra de navegación y el color de fondo
    private func setupNavigationBar() {
        title = "Perfil"
        navigationController?.navigationBar.prefersLargeTitles = false
        view.backgroundColor = .systemBackground
        
        // Agregar botón para volver al menú principal
        let menuButton = UIBarButtonItem(
            image: UIImage(systemName: "house.fill"),
            style: .plain,
            target: self,
            action: #selector(returnToMainMenu)
        )
        menuButton.tintColor = .systemRed
        navigationItem.leftBarButtonItem = menuButton
    }
    
    /// Acción para volver al menú principal (ContentView)
    @objc private func returnToMainMenu() {
        // Cerrar este view controller y volver al ContentView
        dismiss(animated: true)
    }
    
    /// Configura todas las vistas y su jerarquía
    private func setupViews() {
        // Setup ScrollView
        scrollView = UIScrollView()
        scrollView.translatesAutoresizingMaskIntoConstraints = false
        scrollView.backgroundColor = .systemBackground
        view.addSubview(scrollView)
        
        // Setup ContentView - Contenedor principal
        contentView = UIView()
        contentView.translatesAutoresizingMaskIntoConstraints = false
        contentView.backgroundColor = .systemBackground
        scrollView.addSubview(contentView)
        
        // Setup ProfileHeaderView - Vista de cabecera del perfil
        profileHeaderView = ProfileHeaderView()
        profileHeaderView.translatesAutoresizingMaskIntoConstraints = false
        profileHeaderView.delegate = self
        contentView.addSubview(profileHeaderView)
        
        // Setup StatsSection - Sección de estadísticas
        statsSection = ExpandableSectionView(
            title: "Estadísticas",
            icon: UIImage(systemName: "chart.bar.fill"),
            iconTintColor: .systemRed
        )
        statsSection.translatesAutoresizingMaskIntoConstraints = false
        statsSection.delegate = self
        contentView.addSubview(statsSection)
        
        // Setup AchievementsSection - Sección de logros
        achievementsSection = ExpandableSectionView(
            title: "Logros",
            icon: UIImage(systemName: "trophy.fill"),
            iconTintColor: .systemYellow
        )
        achievementsSection.translatesAutoresizingMaskIntoConstraints = false
        achievementsSection.delegate = self
        contentView.addSubview(achievementsSection)
        
        setupConstraints()
    }
    
    /// Configura las constraints de todas las vistas
    private func setupConstraints() {
        NSLayoutConstraint.activate([
            // ScrollView - Ocupa todo el espacio disponible
            scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
            
            // ContentView - Se ajusta al ancho del ScrollView
            contentView.topAnchor.constraint(equalTo: scrollView.topAnchor),
            contentView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor),
            contentView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor),
            contentView.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
            contentView.widthAnchor.constraint(equalTo: scrollView.widthAnchor),
            
            // ProfileHeaderView - Margen superior e inferior
            profileHeaderView.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 20),
            profileHeaderView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20),
            profileHeaderView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20),
            
            // StatsSection - Separación respecto al header
            statsSection.topAnchor.constraint(equalTo: profileHeaderView.bottomAnchor, constant: 20),
            statsSection.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20),
            statsSection.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20),
            
            // AchievementsSection - Espaciado reducido respecto a stats
            achievementsSection.topAnchor.constraint(equalTo: statsSection.bottomAnchor, constant: 8),
            achievementsSection.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20),
            achievementsSection.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20),
            achievementsSection.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -20)
        ])
    }
    
    /// Carga y configura los datos del perfil en las vistas
    private func loadProfile() {
        profileHeaderView.configure(with: profile)
        updateStats()
        updateAchievements()
    }
    
    /// Actualiza la vista de estadísticas con los datos actuales
    private func updateStats() {
        let statsView = StatsView(statistics: profile.statistics)
        statsView.delegate = self  // Esta línea es la que falta
        statsSection.setContentView(statsView)
    }
    
    /// Actualiza la vista de logros con las medallas actuales
    private func updateAchievements() {
        let achievementsView = AchievementsView(medals: medalManager.getMedals())
        achievementsSection.setContentView(achievementsView)
    }
    
    /// Maneja la visualización del alert para editar el nombre de usuario
    private func showEditUsernameAlert(currentUsername: String) {
        // Asegurarnos de que estamos en el hilo principal
        DispatchQueue.main.async {
            let alertController = UIAlertController(
                title: "Editar Nombre",
                message: "Introduce tu nuevo nombre de usuario",
                preferredStyle: .alert
            )
            
            // Añadir campo de texto
            alertController.addTextField { textField in
                textField.text = currentUsername
                textField.placeholder = "Nombre de usuario"
                textField.autocapitalizationType = .words
            }
            
            // Acción de guardar
            let saveAction = UIAlertAction(title: "Guardar", style: .default) { [weak self] _ in
                guard let self = self,
                      let textField = alertController.textFields?.first,
                      let newUsername = textField.text?.trimmingCharacters(in: .whitespacesAndNewlines),
                      !newUsername.isEmpty else {
                    return
                }
                
                // Actualizar el nombre de usuario
                self.profile.username = newUsername
                self.profile.save()
                
                // Actualizar la interfaz
                self.profileHeaderView.configure(with: self.profile)
            }
            
            // Acción de cancelar
            let cancelAction = UIAlertAction(title: "Cancelar", style: .cancel)
            
            alertController.addAction(saveAction)
            alertController.addAction(cancelAction)
            
            // Presentar el alert desde el presentador correcto
            if let presentingController = self.presentingViewController {
                presentingController.present(alertController, animated: true)
            } else {
                self.present(alertController, animated: true)
            }
        }
    }

    /// Obtiene el view controller más alto en la jerarquía
    private func getTopViewController() -> UIViewController? {
        // Obtener la escena activa y su ventana
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
              let keyWindow = windowScene.windows.first(where: { $0.isKeyWindow }) else {
            return nil
        }
        
        var topController = keyWindow.rootViewController
        
        while let presentedController = topController?.presentedViewController {
            topController = presentedController
        }
        
        return topController
    }
}

// MARK: - ProfileHeaderViewDelegate
extension ProfileViewController: ProfileHeaderViewDelegate {
    /// Maneja la actualización del nombre de usuario
    func profileHeaderView(_ view: ProfileHeaderView, didUpdateUsername username: String) {
        // Aquí simplemente actualizamos el modelo con el nuevo nombre
        profile.username = username
        profile.save()
    }
    
    /// Maneja la selección del avatar mostrando el picker
    func profileHeaderViewDidTapAvatar(_ view: ProfileHeaderView) {
        let avatarPicker = AvatarPickerViewController(
            selectedAvatar: profile.avatarName,
            availableAvatars: ["avatar1", "avatar2", "avatar3", "avatar4", "avatar5", "avatar6", "avatar7", "avatar8", "avatar9", "avatar10", "avatar11", "avatar12", "avatar13", "avatar14"]
        )
        avatarPicker.delegate = self
        let nav = UINavigationController(rootViewController: avatarPicker)
        present(nav, animated: true)
    }
}

// MARK: - AvatarPickerViewControllerDelegate
extension ProfileViewController: AvatarPickerViewControllerDelegate {
    /// Maneja la selección de un nuevo avatar
    func avatarPicker(_ picker: AvatarPickerViewController, didSelect avatar: String) {
        profile.avatarName = avatar
        profile.save()
        profileHeaderView.configure(with: profile)
        dismiss(animated: true)
    }
}

// MARK: - ExpandableSectionViewDelegate
extension ProfileViewController: ExpandableSectionViewDelegate {
    /// Anima los cambios cuando una sección se expande o colapsa
    func expandableSectionDidToggle(_ section: ExpandableSectionView) {
        UIView.animate(withDuration: 0.3) {
            self.view.layoutIfNeeded()
        }
    }
}

// Añadir conformidad al protocolo StatsViewDelegate en la clase ProfileViewController
extension ProfileViewController: StatsViewDelegate {
    func statsViewDidTapResetButton(_ statsView: StatsView) {
        // Mostrar alerta de confirmación
        let alert = UIAlertController(
            title: "Borrar datos",
            message: "¿Estás seguro de que deseas borrar todas tus estadísticas? Esta acción no se puede deshacer.",
            preferredStyle: .alert
        )
        
        // Acción para confirmar el borrado
        let resetAction = UIAlertAction(title: "Borrar", style: .destructive) { [weak self] _ in
            guard let self = self else { return }
            
            // Crear estadísticas nuevas (resetear todo a valores iniciales)
            self.profile.statistics = Statistics()
            self.profile.save()
            
            // Actualizar la vista con las estadísticas reseteadas
            self.updateStats()
            
            // Mostrar mensaje de confirmación
            self.showToast(message: "Estadísticas restablecidas")
        }
        
        // Acción para cancelar
        let cancelAction = UIAlertAction(title: "Cancelar", style: .cancel)
        
        alert.addAction(resetAction)
        alert.addAction(cancelAction)
        
        // Presentar la alerta
        present(alert, animated: true)
    }
    
    // Método auxiliar para mostrar un mensaje toast
    private func showToast(message: String) {
        let toastLabel = UILabel()
        toastLabel.backgroundColor = UIColor.black.withAlphaComponent(0.7)
        toastLabel.textColor = .white
        toastLabel.textAlignment = .center
        toastLabel.font = UIFont.systemFont(ofSize: 14)
        toastLabel.text = message
        toastLabel.alpha = 0
        toastLabel.layer.cornerRadius = 10
        toastLabel.clipsToBounds = true
        
        view.addSubview(toastLabel)
        toastLabel.translatesAutoresizingMaskIntoConstraints = false
        
        NSLayoutConstraint.activate([
            toastLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            toastLabel.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -20),
            toastLabel.widthAnchor.constraint(lessThanOrEqualTo: view.widthAnchor, multiplier: 0.7),
            toastLabel.heightAnchor.constraint(equalToConstant: 40)
        ])
        
        UIView.animate(withDuration: 0.5, animations: {
            toastLabel.alpha = 1
        }, completion: { _ in
            UIView.animate(withDuration: 0.5, delay: 1.5, options: .curveEaseOut, animations: {
                toastLabel.alpha = 0
            }, completion: { _ in
                toastLabel.removeFromSuperview()
            })
        })
    }
}

#if DEBUG
// MARK: - SwiftUI Preview
import SwiftUI

struct ProfileViewControllerPreview: UIViewControllerRepresentable {
    func makeUIViewController(context: Context) -> ProfileViewController {
        // Crear datos de ejemplo para la preview
        let profile = UserProfile(
            username: "Jugador de Prueba",
            avatarName: "avatar1",
            statistics: Statistics(
                totalScore: 2500,
                currentLevel: 7,
                playTime: 7200, // 2 horas
                notesHit: 450,
                currentStreak: 15,
                bestStreak: 25,
                perfectLevelsCount: 5,
                totalGamesPlayed: 35,
                averageAccuracy: 0.88
            ),
            achievements: Achievements(
                unlockedMedals: [
                    MedalType.notesHit.rawValue: [true, true, false],
                    MedalType.playTime.rawValue: [true, true, false],
                    MedalType.streaks.rawValue: [true, true, true],
                    MedalType.perfectTuning.rawValue: [true, true, false]
                ],
                lastUpdateDate: Date()
            )
        )
        profile.save()
        
        // Crear y devolver el view controller
        let profileVC = ProfileViewController()
        return profileVC
    }
    
    func updateUIViewController(_ uiViewController: ProfileViewController, context: Context) {
        // No es necesario actualizar nada aquí
    }
}

struct ProfileViewController_Preview: PreviewProvider {
    static var previews: some View {
        // Vista de previsualización para modo claro y oscuro
        Group {
            ProfileViewControllerPreview()
                .edgesIgnoringSafeArea(.all)
                .preferredColorScheme(.light)
                .previewDisplayName("Perfil - Modo Claro")
            
            ProfileViewControllerPreview()
                .edgesIgnoringSafeArea(.all)
                .preferredColorScheme(.dark)
                .previewDisplayName("Perfil - Modo Oscuro")
        }
    }
}
#endif
</file>

<file path="MusicBlocks/Inicio y Profile/StatsView.swift">
//
//  StatsView.swift
//  MusicBlocks
//
//  Created by Jose R. García on 8/3/25.
//

import UIKit

protocol StatsViewDelegate: AnyObject {
    func statsViewDidTapResetButton(_ statsView: StatsView)
}

class StatsView: UIView {
    
    // MARK: - Properties
    weak var delegate: StatsViewDelegate?
    
    private let stackView: UIStackView = {
        let stack = UIStackView()
        stack.axis = .vertical
        stack.spacing = 12
        stack.distribution = .fill
        return stack
    }()
    
    private let resetButton: UIButton = {
        var configuration = UIButton.Configuration.plain()
        
        // Configurar el contenido
        configuration.image = UIImage(systemName: "trash")
        configuration.title = "Borrar datos"
        configuration.imagePadding = 5 // Espaciado entre imagen y texto
        
        // Configurar el estilo
        configuration.baseForegroundColor = .systemRed
        configuration.contentInsets = NSDirectionalEdgeInsets(top: 5, leading: 10, bottom: 5, trailing: 10)
        
        // Crear el botón con la configuración
        let button = UIButton(configuration: configuration)
        
        // Configurar el borde
        button.layer.borderColor = UIColor.systemRed.cgColor
        button.layer.borderWidth = 1
        button.layer.cornerRadius = 8
        
        return button
    }()
    
    init(statistics: Statistics) {
        super.init(frame: .zero)
        setupViews()
        configure(with: statistics)
        setupActions()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupViews() {
        stackView.translatesAutoresizingMaskIntoConstraints = false
        resetButton.translatesAutoresizingMaskIntoConstraints = false
        
        addSubview(stackView)
        addSubview(resetButton)
        
        NSLayoutConstraint.activate([
            stackView.topAnchor.constraint(equalTo: topAnchor, constant: 8),
            stackView.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
            stackView.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
            
            resetButton.topAnchor.constraint(equalTo: stackView.bottomAnchor, constant: 16),
            resetButton.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
            resetButton.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -8)
        ])
    }
    
    private func setupActions() {
            // Añadir acción al botón de reset
            resetButton.addTarget(self, action: #selector(resetButtonTapped), for: .touchUpInside)
        }
        
    @objc private func resetButtonTapped() {
        print("Botón de reset tocado") // Añadir para depuración
        // Notificar al delegado que se ha pulsado el botón de reset
        delegate?.statsViewDidTapResetButton(self)
    }
    
    private func configure(with statistics: Statistics) {
            // Limpiar vista previa
            stackView.arrangedSubviews.forEach { $0.removeFromSuperview() }
            
            // Sección de Puntuación
            addSectionHeader("Puntuación")
            addStatRow(title: "Puntuación Total", value: statistics.formattedTotalScore)
            addStatRow(title: "Nivel Actual", value: "\(statistics.currentLevel)")
            
            // Sección de Partidas
            addSectionHeader("Partidas")
            addStatRow(title: "Total Jugadas", value: "\(statistics.totalGamesPlayed)")
            addStatRow(title: "Ganadas", value: "\(statistics.gamesWon)")
            addStatRow(title: "Perdidas", value: "\(statistics.gamesLost)")
            let winRate = statistics.totalGamesPlayed > 0 ?
                Double(statistics.gamesWon) / Double(statistics.totalGamesPlayed) * 100 : 0
            addStatRow(title: "Ratio Victoria", value: String(format: "%.1f%%", winRate))
            
            // Sección de Rendimiento
            addSectionHeader("Rendimiento")
            addStatRow(title: "Notas Acertadas", value: "\(statistics.notesHit)")
            addStatRow(title: "Mejor Racha", value: "\(statistics.bestStreak)")
            addStatRow(title: "Precisión Media", value: statistics.formattedAccuracy)
            addStatRow(title: "Niveles Perfectos", value: "\(statistics.perfectLevelsCount)")
            
            // Sección de Tiempo
            addSectionHeader("Tiempo")
            addStatRow(title: "Tiempo Total", value: statistics.formattedPlayTime)
        }
    
    private func addSectionHeader(_ title: String) {
            let headerView = SectionHeaderView(title: title)
            stackView.addArrangedSubview(headerView)
            
            // Añadir un pequeño espaciado después del header
            let spacer = UIView()
            spacer.heightAnchor.constraint(equalToConstant: 8).isActive = true
            stackView.addArrangedSubview(spacer)
        }

    
    private func addStatRow(title: String, value: String) {
        let row = StatRowView(title: title, value: value)
        stackView.addArrangedSubview(row)
    }
}

class StatRowView: UIView {
    private let titleLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 15)
        label.textColor = .secondaryLabel
        return label
    }()
    
    private let valueLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 15, weight: .medium)
        label.textColor = .label
        return label
    }()
    
    init(title: String, value: String) {
        super.init(frame: .zero)
        titleLabel.text = title
        valueLabel.text = value
        setupViews()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupViews() {
        [titleLabel, valueLabel].forEach {
            $0.translatesAutoresizingMaskIntoConstraints = false
            addSubview($0)
        }
        
        NSLayoutConstraint.activate([
            titleLabel.leadingAnchor.constraint(equalTo: leadingAnchor),
            titleLabel.centerYAnchor.constraint(equalTo: centerYAnchor),
            
            valueLabel.trailingAnchor.constraint(equalTo: trailingAnchor),
            valueLabel.centerYAnchor.constraint(equalTo: centerYAnchor),
            
            heightAnchor.constraint(equalToConstant: 30)
        ])
    }
}

// Nuevo componente para los headers de sección
class SectionHeaderView: UIView {
    private let titleLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 17, weight: .bold)
        label.textColor = .systemPurple
        return label
    }()
    
    private let separatorLine: UIView = {
        let view = UIView()
        view.backgroundColor = .systemPurple.withAlphaComponent(0.3)
        return view
    }()
    
    init(title: String) {
        super.init(frame: .zero)
        titleLabel.text = title
        setupViews()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupViews() {
        [titleLabel, separatorLine].forEach {
            $0.translatesAutoresizingMaskIntoConstraints = false
            addSubview($0)
        }
        
        NSLayoutConstraint.activate([
            titleLabel.topAnchor.constraint(equalTo: topAnchor),
            titleLabel.leadingAnchor.constraint(equalTo: leadingAnchor),
            
            separatorLine.leadingAnchor.constraint(equalTo: leadingAnchor),
            separatorLine.trailingAnchor.constraint(equalTo: trailingAnchor),
            separatorLine.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 4),
            separatorLine.bottomAnchor.constraint(equalTo: bottomAnchor),
            separatorLine.heightAnchor.constraint(equalToConstant: 1)
        ])
    }
}

// Actualizar la preview
#if DEBUG
import SwiftUI

@available(iOS 17.0, *)
struct StatsView_Previews: PreviewProvider {
    static var previews: some View {
        StatsViewRepresentable()
            .padding()
            .previewDisplayName("Light Mode")
        
        StatsViewRepresentable()
            .padding()
            .preferredColorScheme(.dark)
            .previewDisplayName("Dark Mode")
    }
    
    private struct StatsViewRepresentable: UIViewRepresentable {
        func makeUIView(context: Context) -> StatsView {
            let mockStats = Statistics(
                totalScore: 1500,
                currentLevel: 5,
                playTime: 3600,
                notesHit: 250,
                currentStreak: 10,
                bestStreak: 15,
                perfectLevelsCount: 3,
                totalGamesPlayed: 20,
                averageAccuracy: 0.83,
                gamesWon: 12,
                gamesLost: 8
            )
            return StatsView(statistics: mockStats)
        }
        
        func updateUIView(_ uiView: StatsView, context: Context) {}
    }
}
#endif
</file>

<file path="MusicBlocks/Inicio y Profile/UserProfile.swift">
//
//  UserProfile.swift
//  MusicBlocks
//
//  Created by Jose R. García on 8/3/25.
//

import Foundation

/// Estructura principal que representa el perfil del usuario en el juego.
/// Contiene toda la información personal, estadísticas y logros del jugador.
struct UserProfile: Codable {
    /// Nombre de usuario mostrado en el perfil
    var username: String
    
    /// Nombre del avatar seleccionado por el usuario
    var avatarName: String
    
    /// Estadísticas acumuladas del jugador
    var statistics: Statistics
    
    /// Logros y medallas desbloqueadas
    var achievements: Achievements
    
    /// Nombre de usuario por defecto para nuevos perfiles
    static let defaultUsername = "Pequeño músico"
    
    /// Avatar por defecto para nuevos perfiles
    static let defaultAvatarName = "avatar1"
    
    /// Inicializador con valores por defecto para crear un nuevo perfil
    /// - Parameters:
    ///   - username: Nombre de usuario, por defecto "Pequeño músico"
    ///   - avatarName: Nombre del avatar, por defecto "avatar1"
    ///   - statistics: Estadísticas iniciales
    ///   - achievements: Logros iniciales
    init(username: String = defaultUsername,
         avatarName: String = defaultAvatarName,
         statistics: Statistics = Statistics(),
         achievements: Achievements = Achievements()) {
        self.username = username
        self.avatarName = avatarName
        self.statistics = statistics
        self.achievements = achievements
    }
    
    /// Carga el perfil del usuario desde UserDefaults
    /// - Returns: El perfil guardado o un nuevo perfil con valores por defecto
    static func load() -> UserProfile {
        if let data = UserDefaults.standard.data(forKey: "userProfile"),
           let profile = try? JSONDecoder().decode(UserProfile.self, from: data) {
            return profile
        }
        return UserProfile()
    }
    
    /// Guarda el perfil actual en UserDefaults
    func save() {
        if let encoded = try? JSONEncoder().encode(self) {
            UserDefaults.standard.set(encoded, forKey: "userProfile")
        }
    }
}

// MARK: - Statistics
/// Estructura que mantiene todas las estadísticas del jugador
struct Statistics: Codable {
    /// Puntuación total acumulada en todos los juegos
    var totalScore: Int
    
    /// Nivel actual del jugador
    var currentLevel: Int
    
    /// Tiempo total de juego en segundos
    var playTime: TimeInterval
    
    /// Número total de notas acertadas
    var notesHit: Int
    
    /// Racha actual de notas acertadas consecutivas
    var currentStreak: Int
    
    /// Mejor racha de notas acertadas consecutivas
    var bestStreak: Int
    
    /// Número de niveles completados con precisión perfecta
    var perfectLevelsCount: Int
    
    /// Número total de partidas jugadas
    var totalGamesPlayed: Int
    
    /// Precisión promedio en todas las partidas (0.0 a 1.0)
    var averageAccuracy: Double
    
    /// Número total de partidas ganadas
    var gamesWon: Int
    
    /// Número total de partidas perdidas
    var gamesLost: Int
    
    /// Inicializador con valores por defecto para nuevas estadísticas
    init(totalScore: Int = 0,
         currentLevel: Int = 0,
         playTime: TimeInterval = 0,
         notesHit: Int = 0,
         currentStreak: Int = 0,
         bestStreak: Int = 0,
         perfectLevelsCount: Int = 0,
         totalGamesPlayed: Int = 0,
         averageAccuracy: Double = 0.0,
         gamesWon: Int = 0,
         gamesLost: Int = 0) {
        self.totalScore = totalScore
        self.currentLevel = currentLevel
        self.playTime = playTime
        self.notesHit = notesHit
        self.currentStreak = currentStreak
        self.bestStreak = bestStreak
        self.perfectLevelsCount = perfectLevelsCount
        self.totalGamesPlayed = totalGamesPlayed
        self.averageAccuracy = averageAccuracy
        self.gamesWon = gamesWon
        self.gamesLost = gamesLost
    }

    
    /// Actualiza la precisión promedio con un nuevo valor
    /// - Parameter newAccuracy: Nueva precisión a incorporar en el promedio (0.0 a 1.0)
    mutating func updateAccuracy(with newAccuracy: Double) {
        if totalGamesPlayed == 0 {
            averageAccuracy = newAccuracy
        } else {
            let totalAccuracy = averageAccuracy * Double(totalGamesPlayed)
            averageAccuracy = (totalAccuracy + newAccuracy) / Double(totalGamesPlayed + 1)
        }
        totalGamesPlayed += 1
    }
    
    /// Actualiza la racha actual y, si corresponde, la mejor racha
    /// - Parameter hitNote: true si acertó la nota, false si falló
    mutating func updateStreak(hitNote: Bool) {
        if hitNote {
            currentStreak += 1
            if currentStreak > bestStreak {
                bestStreak = currentStreak
            }
        } else {
            currentStreak = 0
        }
    }
    
    /// Añade tiempo de juego al total
    /// - Parameter time: Tiempo a añadir en segundos
    mutating func addPlayTime(_ time: TimeInterval) {
        playTime += time
    }
}

// MARK: - Achievements
/// Estructura que gestiona los logros y medallas del jugador
struct Achievements: Codable {
    /// Diccionario que almacena el estado de desbloqueo de las medallas
    /// La clave es el tipo de medalla y el valor es un array de booleanos
    var unlockedMedals: [String: [Bool]]
    
    /// Fecha de la última actualización de los logros
    var lastUpdateDate: Date
    
    /// Inicializador con valores por defecto para nuevos logros
    init(unlockedMedals: [String: [Bool]] = [:], lastUpdateDate: Date = Date()) {
        self.unlockedMedals = unlockedMedals
        self.lastUpdateDate = lastUpdateDate
    }
    
    /// Actualiza el estado de una medalla específica
    /// - Parameters:
    ///   - type: Tipo de medalla
    ///   - index: Índice de la medalla en su categoría
    ///   - isUnlocked: true si se ha desbloqueado, false si no
    mutating func updateMedal(type: MedalType, index: Int, isUnlocked: Bool) {
        if unlockedMedals[type.rawValue] == nil {
            unlockedMedals[type.rawValue] = Array(repeating: false, count: 5)
        }
        unlockedMedals[type.rawValue]?[index] = isUnlocked
        lastUpdateDate = Date()
    }
    
    /// Verifica si una medalla específica está desbloqueada
    /// - Parameters:
    ///   - type: Tipo de medalla
    ///   - index: Índice de la medalla en su categoría
    /// - Returns: true si está desbloqueada, false si no
    func isMedalUnlocked(type: MedalType, index: Int) -> Bool {
        return unlockedMedals[type.rawValue]?[index] ?? false
    }
}

// MARK: - Formatters
extension Statistics {
    /// Devuelve el tiempo de juego formateado (ej: "1:30 h" o "45 min")
    var formattedPlayTime: String {
        let hours = Int(playTime) / 3600
        let minutes = Int(playTime) / 60 % 60
        if hours > 0 {
            return String(format: "%d:%02d h", hours, minutes)
        } else {
            return String(format: "%d min", minutes)
        }
    }
    
    /// Devuelve la puntuación total formateada con separadores locales
    var formattedTotalScore: String {
        return NumberFormatter.localizedString(from: NSNumber(value: totalScore), number: .decimal)
    }
    
    /// Devuelve la precisión promedio formateada como porcentaje
    var formattedAccuracy: String {
        return String(format: "%.1f%%", averageAccuracy * 100)
    }
}

// MARK: - Helper Methods
extension UserProfile {
    /// Actualiza las estadísticas del jugador después de una partida o acción
    /// - Parameters:
    ///   - score: Puntos ganados en la partida
    ///   - noteHit: Indica si se acertó una nota
    ///   - accuracy: Precisión de la partida (0.0 a 1.0)
    ///   - levelCompleted: Indica si se completó un nivel
    ///   - isPerfect: Indica si el nivel se completó con precisión perfecta
    ///   - playTime: Tiempo jugado en la partida
    mutating func updateStatistics(score: Int = 0,
                                 noteHit: Bool = false,
                                 accuracy: Double? = nil,
                                 levelCompleted: Bool = false,
                                 isPerfect: Bool = false,
                                 playTime: TimeInterval = 0,
                                 gamesWon: Int = 0,
                                 gamesLost: Int = 0) {
        statistics.totalScore += score
        
        if noteHit {
            statistics.notesHit += 1
            statistics.updateStreak(hitNote: true)
        } else {
            statistics.updateStreak(hitNote: false)
        }
        
        if let accuracy = accuracy {
            statistics.updateAccuracy(with: accuracy)
        }
        
        if levelCompleted {
            statistics.currentLevel += 1
            if isPerfect {
                statistics.perfectLevelsCount += 1
            }
        }
        
        if playTime > 0 {
            statistics.addPlayTime(playTime)
        }
        
        // Actualizar estadísticas de partidas
            statistics.gamesWon += gamesWon
            statistics.gamesLost += gamesLost
            statistics.totalGamesPlayed = statistics.gamesWon + statistics.gamesLost
            
            // Actualizar medallas
            MedalManager.shared.updateMedals(
                notesHit: statistics.notesHit,
                playTime: statistics.playTime,
                currentStreak: statistics.currentStreak,
                perfectTuningCount: statistics.perfectLevelsCount
            )
            
            save()
        }
    
    /// Restablece todas las estadísticas y logros a sus valores iniciales
    func resetStatistics() {
        var resetProfile = self
        resetProfile.statistics = Statistics()
        resetProfile.achievements = Achievements()
        resetProfile.save()
    }
}
</file>

<file path="MusicBlocks/Paneles/DetectedNoteCounterNode.swift">
//
//  DetectedNoteCounterNode.swift
//  MusicBlocks
//
//  Created by Jose R. García on 25/2/25.
//

import SpriteKit

class DetectedNoteCounterNode: SKNode {
    // MARK: - Layout Configuration
    struct Layout {
        static let defaultSize = CGSize(width: 100, height: 40)
        static let cornerRadius: CGFloat = 8
        static let backgroundAlpha: CGFloat = 0.95
        static let inactiveAlpha: CGFloat = 0.6
        static let animationDuration: TimeInterval = 0.2
        static let fontSize: CGFloat = 18  // Fuente más pequeña
        static let padding: CGFloat = 10
        static let shadowRadius: CGFloat = 4.0
        static let shadowOpacity: Float = 0.2
        static let shadowOffset = CGPoint(x: 0, y: -1)
    }
    
    // MARK: - Properties
    private let containerSize: CGSize
    private let container: SKShapeNode
    private let shadowNode: SKEffectNode
    private let noteLabel: SKLabelNode
    
    var currentNote: String = "-" {
        didSet {
            updateDisplay()
        }
    }
    
    var isActive: Bool = false {
        didSet {
            updateDisplay()
        }
    }
    
    // MARK: - Initialization
    init(size: CGSize = Layout.defaultSize) {
        self.containerSize = size
        
        // Crear nodo de sombra
        shadowNode = SKEffectNode()
        let shadowShape = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
        shadowShape.fillColor = .black
        shadowShape.strokeColor = .clear
        shadowShape.alpha = CGFloat(Layout.shadowOpacity)
        shadowNode.addChild(shadowShape)
        shadowNode.shouldRasterize = true
        shadowNode.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": Layout.shadowRadius])
        shadowNode.position = Layout.shadowOffset
        
        // Inicializar contenedor principal
        container = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
        
        // Etiqueta para el valor de la nota (centrada)
        noteLabel = SKLabelNode(fontNamed: "Helvetica-Bold")
        noteLabel.fontSize = min(size.height * 0.5, Layout.fontSize)
        noteLabel.verticalAlignmentMode = .center
        noteLabel.horizontalAlignmentMode = .center
        
        super.init()
        
        setupNodes()
        updateDisplay()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: - Setup
    private func setupNodes() {
        // Aplicar estilo común del contenedor
        applyContainerStyle(size: containerSize)
        
        // Posicionar etiqueta en el centro
        noteLabel.position = CGPoint(x: 0, y: 0)
        addChild(noteLabel)
    }
    
    // MARK: - Updates
    private func updateDisplay() {
        // Actualizar texto
        noteLabel.text = currentNote
        
        // Actualizar colores según estado
        if isActive {
            noteLabel.fontColor = .black
            container.alpha = Layout.backgroundAlpha
        } else {
            noteLabel.fontColor = .gray
            container.alpha = Layout.inactiveAlpha
        }
        
        // Animar cambio
        animateUpdate()
    }
    
    private func animateUpdate() {
        let scaleUp = SKAction.scale(to: 1.1, duration: Layout.animationDuration / 2)
        let scaleDown = SKAction.scale(to: 1.0, duration: Layout.animationDuration / 2)
        let sequence = SKAction.sequence([scaleUp, scaleDown])
        noteLabel.run(sequence)
    }
    
    // MARK: - Factory Methods
    static func createForRightSideBar(at position: CGPoint, size: CGSize = Layout.defaultSize, zPosition: CGFloat = 10) -> DetectedNoteCounterNode {
        let node = DetectedNoteCounterNode(size: size)
        node.position = position
        node.zPosition = zPosition
        return node
    }
}

// MARK: - Previews
#if DEBUG
import SwiftUI

extension DetectedNoteCounterNode {
    static func createPreviewScene() -> SKScene {
        let scene = SKScene(size: CGSize(width: 300, height: 150))
        scene.backgroundColor = .clear
        
        let activeNode = DetectedNoteCounterNode()
        activeNode.currentNote = "La4"
        activeNode.isActive = true
        activeNode.position = CGPoint(x: 150, y: 100)
        scene.addChild(activeNode)
        
        let inactiveNode = DetectedNoteCounterNode()
        inactiveNode.currentNote = "-"
        inactiveNode.isActive = false
        inactiveNode.position = CGPoint(x: 150, y: 50)
        scene.addChild(inactiveNode)
        
        return scene
    }
}

struct DetectedNoteCounterPreview: PreviewProvider {
    static var previews: some View {
        ZStack {
            Color.gray.opacity(0.3)
            SpriteView(scene: DetectedNoteCounterNode.createPreviewScene())
        }
        .frame(width: 300, height: 150)
    }
}
#endif
</file>

<file path="MusicBlocks/Paneles/GameOverlayNode.swift">
//
//  GameOverlayNode.swift
//  MusicBlocks
//
//  Created by Jose R. García on 25/2/25.
//

import SpriteKit
import UIKit

class GameOverlayNode: SKNode {
    // Cambiado de private a internal para que las subclases puedan acceder
    struct Layout {
        static let cornerRadius: CGFloat = 20
        static let padding: CGFloat = 30
        static let iconSize: CGFloat = 40
        static let spacing: CGFloat = 15
        static let backgroundAlpha: CGFloat = 0.7
    }
    
    enum OverlayPosition {
        case bottom    // For success and failure overlays
        case center    // For game over overlay
        
        func getPosition(in scene: SKScene) -> CGPoint {
            switch self {
            case .bottom:
                // Position at 10% from bottom of screen
                return CGPoint(x: scene.size.width/2, y: scene.size.height * 0.1)
            case .center:
                // Position at center of screen
                return CGPoint(x: scene.size.width/2, y: scene.size.height/2)
            }
        }
    }
    
    private let backgroundNode: SKShapeNode
    // Cambiado de private a protected para que las subclases puedan acceder
    let contentNode: SKNode
    
    init(size: CGSize) {
        backgroundNode = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
        contentNode = SKNode()
        
        super.init()
        
        setupBackground()
        addChild(contentNode)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupBackground() {
        backgroundNode.fillColor = .white
        backgroundNode.strokeColor = .clear
        backgroundNode.alpha = 0.95
        addChild(backgroundNode)
    }
    
    // Replace the existing show method in GameOverlayNode
    func show(in scene: SKScene, overlayPosition: OverlayPosition = .center, duration: TimeInterval = 0.3) {
        // Set initial state
        alpha = 0
        setScale(0.5)
        
        // Set position using the enum method
        self.position = overlayPosition.getPosition(in: scene)
        
        // Ensure overlay is above other content
        zPosition = 100
        
        let appearAction = SKAction.group([
            SKAction.fadeIn(withDuration: duration),
            SKAction.scale(to: 1.0, duration: duration)
        ])
        
        run(appearAction)
    }
    
    func hide(duration: TimeInterval = 0.3) {
        let disappearAction = SKAction.group([
            SKAction.fadeOut(withDuration: duration),
            SKAction.scale(to: 0.5, duration: duration)
        ])
        
        run(SKAction.sequence([
            disappearAction,
            SKAction.removeFromParent()
        ]))
    }
}

// MARK: - Inicio de Nivel
class LevelStartOverlayNode: GameOverlayNode {
    private var countdownLabel: SKLabelNode?
    private var countdownTimer: Timer?
    private var secondsRemaining: Int = 5
    private var startAction: (() -> Void)?
    
    init(size: CGSize, levelId: Int, levelName: String, startAction: @escaping () -> Void) {
        super.init(size: size)
        self.startAction = startAction
        
        // Hacer el fondo más atractivo con un gradiente
        setupBackground()
        
        // Contenedor para el título y nombre del nivel
        let headerContainer = SKNode()
        
        // Título del nivel con estilo mejorado
        let titleNode = SKLabelNode(text: "Nivel \(levelId)")
        titleNode.fontSize = min(40, size.width * 0.12) // Ajuste responsivo
        titleNode.fontName = "Helvetica-Bold"
        titleNode.fontColor = .purple
        titleNode.position = CGPoint(x: 0, y: size.height * 0.2)
        headerContainer.addChild(titleNode)
        
        // Nombre del nivel con estilo mejorado
        let nameNode = SKLabelNode(text: levelName)
        nameNode.fontSize = min(24, size.width * 0.08) // Ajuste responsivo
        nameNode.fontName = "Helvetica"
        nameNode.fontColor = .darkGray
        nameNode.position = CGPoint(x: 0, y: size.height * 0.08)
        headerContainer.addChild(nameNode)
        
        // Línea separadora
        let separatorLine = SKShapeNode(rectOf: CGSize(width: size.width * 0.8, height: 1))
        separatorLine.fillColor = .lightGray
        separatorLine.strokeColor = .clear
        separatorLine.position = CGPoint(x: 0, y: 0)
        headerContainer.addChild(separatorLine)
        
        contentNode.addChild(headerContainer)
        
        // Mensaje "Preparado"
        let readyNode = SKLabelNode(text: "¡Prepárate!")
        readyNode.fontSize = min(28, size.width * 0.09) // Ajuste responsivo
        readyNode.fontName = "Helvetica-Bold"
        readyNode.fontColor = .orange
        readyNode.position = CGPoint(x: 0, y: -size.height * 0.1)
        contentNode.addChild(readyNode)
        
        // Etiqueta para la cuenta atrás con estilo mejorado
        let countdownNode = SKLabelNode(text: "\(secondsRemaining)")
        countdownNode.fontSize = min(64, size.width * 0.2) // Ajuste responsivo
        countdownNode.fontName = "Helvetica-Bold"
        countdownNode.fontColor = .orange
        countdownNode.position = CGPoint(x: 0, y: -size.height * 0.30)
        contentNode.addChild(countdownNode)
        self.countdownLabel = countdownNode
    }
    
    private func setupBackground() {
        // Calcular el tamaño basado en el tamaño del nodo
        let nodeSize = self.calculateAccumulatedFrame().size
        
        // Personalizar el fondo para mejorar la apariencia
        let backgroundNode = SKShapeNode(rectOf: nodeSize, cornerRadius: Layout.cornerRadius)
        let gradientImage = generateGradientImage(
            from: UIColor.systemIndigo,
            to: UIColor.systemBlue.withAlphaComponent(0.7),
            size: nodeSize
        )
        backgroundNode.fillTexture = SKTexture(image: gradientImage)
        backgroundNode.strokeColor = UIColor.white
        backgroundNode.lineWidth = 2
        backgroundNode.alpha = 0.9
        contentNode.addChild(backgroundNode)
    }
    
    // Función auxiliar para generar un fondo con gradiente
    private func generateGradientImage(from startColor: UIColor, to endColor: UIColor, size: CGSize) -> UIImage {
        let gradientLayer = CAGradientLayer()
        gradientLayer.frame = CGRect(origin: .zero, size: size)
        gradientLayer.colors = [startColor.cgColor, endColor.cgColor]
        gradientLayer.startPoint = CGPoint(x: 0.5, y: 0.0)
        gradientLayer.endPoint = CGPoint(x: 0.5, y: 1.0)
        
        UIGraphicsBeginImageContext(size)
        gradientLayer.render(in: UIGraphicsGetCurrentContext()!)
        let image = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return image ?? UIImage()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func show(in scene: SKScene, overlayPosition: OverlayPosition = .center, duration: TimeInterval = 0.5) {
        super.show(in: scene, overlayPosition: overlayPosition, duration: duration)
        startCountdown()
    }
    
    private func startCountdown() {
        // Establecer el color inicial según el valor inicial (5)
        updateCountdownColor()
        
        countdownTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] timer in
            guard let self = self else {
                timer.invalidate()
                return
            }
            
            self.secondsRemaining -= 1
            self.countdownLabel?.text = "\(self.secondsRemaining)"
            
            // Actualizar el color según el nuevo valor
            self.updateCountdownColor()
            
            // Animar el cambio de número con un efecto más vistoso
            let scaleUp = SKAction.scale(to: 1.3, duration: 0.15)
            let scaleDown = SKAction.scale(to: 1.0, duration: 0.15)
            self.countdownLabel?.run(SKAction.sequence([scaleUp, scaleDown]))
            
            if self.secondsRemaining <= 0 {
                timer.invalidate()
                self.hide()
                self.startAction?()
            }
        }
    }
    
    private func updateCountdownColor() {
        // Asignar colores según el valor de la cuenta atrás
        switch secondsRemaining {
        case 5, 4:
            // 5 y 4 son verdes
            countdownLabel?.fontColor = UIColor.systemGreen
        case 3, 2:
            // 3 y 2 son naranjas
            countdownLabel?.fontColor = UIColor.orange
        case 1, 0:
            // 1 y 0 son rojos
            countdownLabel?.fontColor = UIColor.red
        default:
            // Para cualquier otro número (por seguridad)
            countdownLabel?.fontColor = UIColor.white
        }
    }
    
    override func hide(duration: TimeInterval = 0.3) {
        countdownTimer?.invalidate()
        countdownTimer = nil
        super.hide(duration: duration)
    }
}

// MARK: - Success Overlay
class SuccessOverlayNode: GameOverlayNode {
    init(size: CGSize, multiplier: Int, message: String) {
        super.init(size: size)
        
        let checkmarkNode = SKLabelNode(text: "✓")
        checkmarkNode.fontSize = 30 // Tamaño reducido
        checkmarkNode.fontName = "Helvetica-Bold"
        checkmarkNode.fontColor = getColor(for: multiplier)
        checkmarkNode.position = CGPoint(x: -60, y: 0) // Ajustado horizontalmente
        contentNode.addChild(checkmarkNode)
        
        let messageNode = SKLabelNode(text: message)
        messageNode.fontSize = 16 // Tamaño reducido
        messageNode.fontName = "Helvetica-Bold"
        messageNode.fontColor = getColor(for: multiplier)
        messageNode.position = CGPoint(x: 0, y: 0)
        contentNode.addChild(messageNode)
        
        if multiplier > 1 {
            let multiplierNode = SKLabelNode(text: "x\(multiplier)")
            multiplierNode.fontSize = 18 // Tamaño reducido
            multiplierNode.fontName = "Helvetica-Bold"
            multiplierNode.fontColor = .orange
            multiplierNode.position = CGPoint(x: 60, y: 0) // Ajustado horizontalmente
            contentNode.addChild(multiplierNode)
        }
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func getColor(for multiplier: Int) -> SKColor {
        switch multiplier {
        case 3: return .purple    // Excelente
        case 2: return .green     // Perfecto
        case 1: return .blue      // Bien
        default: return .gray
        }
    }
}

// MARK: - Failure Overlay
class FailureOverlayNode: GameOverlayNode {
    override init(size: CGSize) {
        super.init(size: size)
        
        let xmarkNode = SKLabelNode(text: "✗")
        xmarkNode.fontSize = 30 // Tamaño reducido
        xmarkNode.fontName = "Helvetica-Bold"
        xmarkNode.fontColor = .red
        xmarkNode.position = CGPoint(x: -90, y: 0) // Ajustado horizontalmente
        contentNode.addChild(xmarkNode)
        
        let messageNode = SKLabelNode(text: "¡Intenta de nuevo!")
        messageNode.fontSize = 16 // Tamaño reducido
        messageNode.fontName = "Helvetica-Bold"
        messageNode.fontColor = .red
        messageNode.position = CGPoint(x: 0, y: 0)
        contentNode.addChild(messageNode)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

// MARK: - Game Over Overlay
class GameOverOverlayNode: GameOverlayNode {
    private var restartAction: (() -> Void)?
    
    init(size: CGSize, score: Int, message: String, isVictory: Bool = false, restartAction: @escaping () -> Void) {
        super.init(size: size)
        self.restartAction = restartAction
        
        let titleColor: SKColor = isVictory ? .systemGreen : .purple
        let messageColor: SKColor = isVictory ? .systemGreen : .red
        
        // Título Game Over o Victoria
        let gameoverNode = SKLabelNode(text: isVictory ? "¡Victoria!" : "¡Fin del juego!")
        gameoverNode.fontSize = 32
        gameoverNode.fontName = "Helvetica-Bold"
        gameoverNode.fontColor = titleColor
        gameoverNode.position = CGPoint(x: 0, y: size.height/4)
        contentNode.addChild(gameoverNode)
        
        // Mensaje específico
        let messageNode = SKLabelNode(text: message)
        messageNode.fontSize = 16
        messageNode.fontName = "Helvetica"
        messageNode.fontColor = messageColor
        messageNode.position = CGPoint(x: 0, y: size.height/4 - 40)
        contentNode.addChild(messageNode)
        
        // Puntuación
        let scoreNode = SKLabelNode(text: "Puntuación: \(score)")
        scoreNode.fontSize = 20
        scoreNode.fontName = "Helvetica-Bold"
        scoreNode.fontColor = titleColor
        scoreNode.position = CGPoint(x: 0, y: 0)
        contentNode.addChild(scoreNode)
        
        setupRestartButton(isVictory: isVictory)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupRestartButton(isVictory: Bool) {
        let buttonSize = CGSize(width: 170, height: 50)
        let buttonNode = SKShapeNode(rectOf: buttonSize, cornerRadius: 10)
        buttonNode.fillColor = isVictory ? .systemGreen : .purple
        buttonNode.strokeColor = .clear
        buttonNode.position = CGPoint(x: 0, y: -50)
        buttonNode.name = "restartButton"
        contentNode.addChild(buttonNode)
        
        let buttonText = isVictory ? "Siguiente nivel" : "Intentar de nuevo"
        let buttonLabel = SKLabelNode(text: buttonText)
        buttonLabel.fontSize = 18
        buttonLabel.fontName = "Helvetica-Bold"
        buttonLabel.fontColor = .white
        buttonLabel.verticalAlignmentMode = .center
        buttonNode.addChild(buttonLabel)
    }
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        guard let touch = touches.first else { return }
        let location = touch.location(in: self)
        let nodes = nodes(at: location)
        
        if nodes.contains(where: { $0.name == "restartButton" }) {
            restartAction?()
        }
    }
}

// MARK: - Previews
#if DEBUG
import SwiftUI

struct GameOverlayPreview: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            // Vista del LevelStartOverlay
            SpriteView(scene: {
                let scene = SKScene(size: CGSize(width: 400, height: 300))
                scene.backgroundColor = .white
                
                let levelStartNode = LevelStartOverlayNode(
                    size: CGSize(width: 350, height: 250),
                    levelId: 1,
                    levelName: "¡Comienza la aventura!",
                    startAction: {}
                )
                levelStartNode.position = CGPoint(x: 200, y: 150)
                scene.addChild(levelStartNode)
                
                return scene
            }())
            .frame(width: 400, height: 300)
            .previewDisplayName("Level Start Overlay")
            
            // Vista de los otros overlays
            SpriteView(scene: {
                let scene = SKScene(size: CGSize(width: 400, height: 600))
                scene.backgroundColor = .white
                
                // Success Overlay
                let successNode = SuccessOverlayNode(
                    size: CGSize(width: 300, height: 80),
                    multiplier: 2,
                    message: "¡Perfecto!"
                )
                successNode.position = CGPoint(x: 200, y: 450)
                scene.addChild(successNode)
                
                // Failure Overlay
                let failureNode = FailureOverlayNode(
                    size: CGSize(width: 300, height: 80)
                )
                failureNode.position = CGPoint(x: 200, y: 300)
                scene.addChild(failureNode)
                
                // Game Over Overlay
                let gameOverNode = GameOverOverlayNode(
                    size: CGSize(width: 300, height: 200),
                    score: 1500,
                    message: "¡Juego terminado!",
                    isVictory: true, // Para ver ambas variantes, puedes alternar entre true/false
                    restartAction: {}
                )
                gameOverNode.position = CGPoint(x: 200, y: 150)
                scene.addChild(gameOverNode)
                
                return scene
            }())
            .frame(width: 400, height: 600)
            .previewDisplayName("Game State Overlays")
        }
        .previewLayout(.fixed(width: 400, height: 920))
        .background(Color.gray.opacity(0.1))
    }
}
#endif
</file>

<file path="MusicBlocks/Paneles/ScoreProgressNode.swift">
//
//  ScoreProgressNode.swift
//  MusicBlocks
//
//  Created by Jose R. García on 12/3/25.
//

import SpriteKit

class ScoreProgressNode: SKNode {
    // MARK: - Private Properties
    private var progressBar: SKShapeNode
    private var progressFill: SKShapeNode
    private var stars: [SKSpriteNode] = []
    private var litStars: [Bool] = [] // Añadir un array para seguir el estado de las estrellas
    
    // MARK: - Layout Constants
    private enum Layout {
        static let maxStars: Int = 5
        
        static let starSize: CGFloat = 20
        /// Offset vertical para las estrellas respecto al centro superior de la barra
        /// (ajústalo a 0 si quieres que queden centradas en la altura).
        static let starVerticalOffset: CGFloat = 1
        
        static let barHeight: CGFloat = 8
        
        static let progressBarColor: SKColor = .white.withAlphaComponent(0.6)
        static let progressFillColor: SKColor = .systemPurple
        
        // Animaciones
        static let animationDuration: TimeInterval = 0.3
        static let starAnimationScale: CGFloat = 0.5
        static let starAnimationDuration: TimeInterval = 0.15
        static let starAnimationDelay: TimeInterval = 0.1
    }
    
    private let barWidth: CGFloat
    
    // MARK: - Initialization
    init(width: CGFloat) {
        self.barWidth = width
        
        // En vez de rectOf(...), creamos rect con origen (0,0) y width = barWidth
        progressBar = SKShapeNode(
            rect: CGRect(x: 0, y: 0, width: width, height: Layout.barHeight),
            cornerRadius: Layout.barHeight / 2
        )
        progressFill = SKShapeNode(
            rect: CGRect(x: 0, y: 0, width: 0, height: Layout.barHeight - 2),
            cornerRadius: (Layout.barHeight - 2) / 2
        )
        
        // Inicializar el array de estado de estrellas con todas apagadas
        litStars = Array(repeating: false, count: Layout.maxStars)
        
        super.init()
        setupNodes()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: - Setup Methods
    private func setupNodes() {
        setupProgressBar()
        setupProgressFill()
        setupStars()
    }
    
    /// Barra de fondo, va de x=0 a x=barWidth
    private func setupProgressBar() {
        progressBar.fillColor = Layout.progressBarColor
        progressBar.strokeColor = .clear
        // Su origen local es (0,0)
        progressBar.position = .zero
        addChild(progressBar)
    }
    
    /// Barra "relleno" que crece desde x=0 hacia la derecha
    private func setupProgressFill() {
        progressFill.fillColor = Layout.progressFillColor
        progressFill.strokeColor = .clear
        // También empieza en (0,0)
        progressFill.position = .zero
        addChild(progressFill)
    }

    /// Distribuye las estrellas en el rango [0 .. barWidth]
    private func setupStars() {
        
        for i in 0..<Layout.maxStars {
            let star = SKSpriteNode(imageNamed: "star_empty")
            star.size = CGSize(width: Layout.starSize, height: Layout.starSize)
            
            // Fracción de 0 a 1
            let fraction = CGFloat(i) / CGFloat(Layout.maxStars - 1)
            // X = fraction * barWidth
            let xPos = fraction * barWidth
            
            // Ajusta la altura de las estrellas
            let yPos = (Layout.barHeight / 2) + Layout.starVerticalOffset
            
            star.position = CGPoint(x: xPos, y: yPos)
            stars.append(star)
            addChild(star)
        }
    }
    
    // MARK: - Update Methods
    func updateProgress(score: Int, maxScore: Int) {
        animateProgressBar(score: score, maxScore: maxScore)
        updateStars(score: score, maxScore: maxScore)
    }
    
    private func animateProgressBar(score: Int, maxScore: Int) {
        let fraction = min(CGFloat(score) / CGFloat(maxScore), 1.0)
        let fillWidth = barWidth * fraction
        
        // Redimensionamos el ancho del rect
        let resizeAction = SKAction.resize(toWidth: fillWidth, duration: Layout.animationDuration)
        resizeAction.timingMode = .easeOut
        progressFill.run(resizeAction)
    }
    
    private func updateStars(score: Int, maxScore: Int) {
        // Cinco estrellas: se encienden en 1/5, 2/5, 3/5, 4/5, 5/5 de maxScore
        let step = maxScore / Layout.maxStars
        let thresholds = (1...Layout.maxStars).map { step * $0 }
        
        for (index, threshold) in thresholds.enumerated() {
            let delay = Double(index) * Layout.starAnimationDelay
            updateStar(at: index, lit: score >= threshold, delay: delay)
        }
    }
    
    private func updateStar(at index: Int, lit: Bool, delay: TimeInterval) {
        guard index < stars.count && index < litStars.count else { return }
        
        let currentlyLit = litStars[index]
        
        // Si el estado no cambió, no hacemos nada
        guard lit != currentlyLit else { return }
        
        // Actualizar estado en nuestro array
        litStars[index] = lit
        
        DispatchQueue.main.asyncAfter(deadline: .now() + delay) { [weak self, weak star] in
            // Verificar que el nodo y la referencia aún existen
            guard let star = star, let self = self else { return }
            
            let scaleDown = SKAction.scale(to: Layout.starAnimationScale,
                                          duration: Layout.starAnimationDuration)
            let changeTexture = SKAction.run {
                star.texture = SKTexture(imageNamed: lit ? "star_filled" : "star_empty")
            }
            let scaleUp = SKAction.scale(to: 1.0,
                                        duration: Layout.starAnimationDuration)
            let sequence = SKAction.sequence([scaleDown, changeTexture, scaleUp])
            star.run(sequence)
        }
    }
}

// MARK: - SwiftUI Preview
#if DEBUG
import SwiftUI

struct ScoreProgressNodePreview: PreviewProvider {
    static var previews: some View {
        ScoreProgressNodeContainer()
            .frame(width: 340, height: 120)
            .previewDisplayName("Barra con 5 estrellas (x=0..barWidth)")
    }
}

/// Contenedor SwiftUI que muestra el nodo en una escena de SpriteKit
struct ScoreProgressNodeContainer: View {
    private func createScene(size: CGSize) -> SKScene {
        let scene = SKScene(size: size)
        scene.backgroundColor = .black
        
        // Instanciamos la barra con ancho 300, por ejemplo
        let barWidth: CGFloat = 300
        let progressNode = ScoreProgressNode(width: barWidth)
        
        // Colocamos la barra en x=20, y=centro vertical
        // (así su "lado izquierdo" arranca en x=20)
        progressNode.position = CGPoint(x: 20, y: size.height / 2)
        scene.addChild(progressNode)
        
        // Simulamos un score para ver la barra rellena a ~66%
        progressNode.updateProgress(score: 200, maxScore: 300)
        
        return scene
    }
    
    var body: some View {
        GeometryReader { geometry in
            SpriteView(scene: createScene(size: geometry.size))
        }
    }
}
#endif
</file>

<file path="MusicBlocks/Paneles/StabilityCounterNode.swift">
//
//  StabilityCounterNode.swift
//  MusicBlocks
//
//  Created by Jose R. García on 25/2/25.
//

import SpriteKit

class StabilityCounterNode: SKNode {
    // MARK: - Layout Configuration
    private struct Layout {
        static let primaryFontRatio: CGFloat = 0.4  // Tamaño de fuente relativo a la altura del nodo
        static let secondaryFontRatio: CGFloat = 0.3
        static let cornerRadius: CGFloat = 8
        static let backgroundAlpha: CGFloat = 0.95
        static let animationDuration: TimeInterval = 0.2
        static let shadowRadius: CGFloat = 4.0
        static let shadowOpacity: Float = 0.2
        static let shadowOffset = CGPoint(x: 0, y: -1)
    }
    
    // MARK: - Properties
    private let containerSize: CGSize
    private let container: SKShapeNode
    private let shadowNode: SKEffectNode
    private let timeLabel: SKLabelNode
    private let unitLabel: SKLabelNode
    
    var duration: TimeInterval = 0 {
        didSet {
            updateDisplay()
        }
    }
    
    // MARK: - Initialization
    init(size: CGSize) {
        self.containerSize = size
        
        // Crear nodo de sombra
        shadowNode = SKEffectNode()
        let shadowShape = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
        shadowShape.fillColor = .black
        shadowShape.strokeColor = .clear
        shadowShape.alpha = CGFloat(Layout.shadowOpacity)
        shadowNode.addChild(shadowShape)
        shadowNode.shouldRasterize = true
        shadowNode.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": Layout.shadowRadius])
        shadowNode.position = Layout.shadowOffset
        
        // Inicializar contenedor principal
        container = SKShapeNode(rectOf: size, cornerRadius: Layout.cornerRadius)
        
        // Inicializar etiquetas con tamaños pequeños
        timeLabel = SKLabelNode(fontNamed: "Helvetica-Bold")
        timeLabel.fontSize = size.height * Layout.primaryFontRatio
        timeLabel.verticalAlignmentMode = .center
        timeLabel.horizontalAlignmentMode = .right
        timeLabel.fontColor = .black
        
        unitLabel = SKLabelNode(fontNamed: "Helvetica")
        unitLabel.fontSize = size.height * Layout.secondaryFontRatio
        unitLabel.verticalAlignmentMode = .center
        unitLabel.horizontalAlignmentMode = .left
        unitLabel.fontColor = .gray
        unitLabel.text = "seg"
        
        super.init()
        
        setupNodes()
        updateDisplay()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not sido implementado")
    }
    
    // MARK: - Setup
    private func setupNodes() {
        // Añadir sombra primero
        addChild(shadowNode)
        
        // Configurar contenedor principal
        container.fillColor = .white
        container.strokeColor = .clear
        container.alpha = Layout.backgroundAlpha
        addChild(container)
        
        // Posicionar etiquetas horizontalmente para mejor uso del espacio
        timeLabel.position = CGPoint(x: -containerSize.width * 0.05, y: 0)
        unitLabel.position = CGPoint(x: containerSize.width * 0.05, y: 0)
        
        // Añadir etiquetas al nodo principal (no al contenedor)
        addChild(timeLabel)
        addChild(unitLabel)
    }
    
    // MARK: - Updates
    private func updateDisplay() {
        timeLabel.text = String(format: "%.1f", duration)
        animateUpdate()
    }
    
    private func animateUpdate() {
        let scaleUp = SKAction.scale(to: 1.05, duration: Layout.animationDuration / 2)
        let scaleDown = SKAction.scale(to: 1.0, duration: Layout.animationDuration / 2)
        let sequence = SKAction.sequence([scaleUp, scaleDown])
        timeLabel.run(sequence)
    }
    
    // MARK: - Public Methods
    func reset() {
        duration = 0
    }
}

// MARK: - Previews
#if DEBUG
import SwiftUI

struct StabilityCounterPreview: PreviewProvider {
    static var previews: some View {
        SpriteView(scene: {
            let scene = SKScene(size: CGSize(width: 300, height: 200))
            scene.backgroundColor = .white
            
            let mediumNode = StabilityCounterNode(size: CGSize(width: 120, height: 60))
            mediumNode.position = CGPoint(x: 150, y: 120)
            mediumNode.duration = 5.5
            scene.addChild(mediumNode)
            
            let maxNode = StabilityCounterNode(size: CGSize(width: 120, height: 60))
            maxNode.position = CGPoint(x: 150, y: 60)
            maxNode.duration = 10.0
            scene.addChild(maxNode)
            
            return scene
        }())
        .frame(width: 300, height: 200)
        .previewLayout(.fixed(width: 300, height: 200))
    }
}
#endif
</file>

<file path="MusicBlocks/Paneles/StabilityIndicatorNode.swift">
//
//  StabilityIndicatorNode.swift
//  MusicBlocks
//
//  Created by Jose R. García on 25/2/25.

import SpriteKit

class StabilityIndicatorNode: SKNode {
    // MARK: - Layout Configuration
    private struct Layout {
        static let barWidthRatio: CGFloat = 0.8
        static let markingWidthRatio: CGFloat = 0.6
        static let backgroundAlpha: CGFloat = 0.15
        static let markingsAlpha: CGFloat = 0.3
        static let glowAlpha: CGFloat = 0.8
        static let cornerRadius: CGFloat = 4
        static let animationDuration: TimeInterval = 0.2
    }
    
    // MARK: - Properties
    var containerSize: CGSize {
        didSet {
            updateLayout()
        }
    }
    
    private let backgroundBar: SKShapeNode = SKShapeNode()
    private var markings: [SKShapeNode] = []
    private let glowBar: SKShapeNode = SKShapeNode()
    private var maxDuration: TimeInterval = 10.0
    
    var duration: TimeInterval = 0 {
        didSet {
            updateProgress()
        }
    }
    
    // MARK: - Initialization
    init(size: CGSize) {
        self.containerSize = size
        
        // Creación de tres marcas (por ejemplo, para 0, 5 y 10)
        for _ in 0..<3 {
            let mark = SKShapeNode()
            markings.append(mark)
        }
        
        super.init()
        
        setupNodes()
        updateLayout()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) no ha sido implementado")
    }
    
    // MARK: - Setup
    private func setupNodes() {
        // Configurar la barra de fondo
        backgroundBar.fillColor = .lightGray
        backgroundBar.strokeColor = .clear
        backgroundBar.alpha = Layout.backgroundAlpha
        addChild(backgroundBar)
        
        // Configurar las marcas
        for mark in markings {
            mark.fillColor = .darkGray
            mark.strokeColor = .clear
            mark.alpha = Layout.markingsAlpha
            addChild(mark)
        }
        
        // Agregar glowBar (que se usará para mostrar el progreso)
        addChild(glowBar)
    }
    
    // MARK: - Layout Update
    private func updateLayout() {
        let barWidth = containerSize.width * Layout.barWidthRatio
        let barHeight = containerSize.height
        
        // Actualizar el fondo de la barra - asegurándonos que ocupe todo el espacio disponible
        let bgRect = CGRect(x: -barWidth/2, y: -barHeight/2, width: barWidth, height: barHeight)
        backgroundBar.path = CGPath(roundedRect: bgRect, cornerWidth: Layout.cornerRadius, cornerHeight: Layout.cornerRadius, transform: nil)
        
        // Actualizar la posición y tamaño de cada marca - espaciadas uniformemente
        for (index, mark) in markings.enumerated() {
            let progress = CGFloat(index) / CGFloat(markings.count - 1)
            let yPosition = -containerSize.height * 0.5 + containerSize.height * progress
            
            // CORREGIDO: Ajustar posición para alinearse mejor con la barra
            mark.position = CGPoint(x: 0, y: yPosition)
            
            // Ancho de marca consistente
            let markWidth = barWidth * Layout.markingWidthRatio
            let markHeight: CGFloat = 2.0  // Altura fija para que sea visible
            let markRect = CGRect(x: -markWidth/2, y: -markHeight/2, width: markWidth, height: markHeight)
            mark.path = CGPath(rect: markRect, transform: nil)
        }
        
        updateProgress()
    }

    // MARK: - Updates
    private func updateProgress() {
        let normalizedProgress = CGFloat(min(duration, maxDuration) / maxDuration)
        let progressHeight = containerSize.height * normalizedProgress
        let progressWidth = containerSize.width * Layout.barWidthRatio
        
        // La posición del rectángulo debe partir desde abajo
        let rect = CGRect(x: -progressWidth / 2,
                          y: -containerSize.height / 2,  // Siempre partimos desde abajo
                          width: progressWidth,
                          height: progressHeight)
        
        let path = CGMutablePath()
        if progressHeight > Layout.cornerRadius * 2 {
            path.addRoundedRect(in: rect, cornerWidth: Layout.cornerRadius, cornerHeight: Layout.cornerRadius)
        } else {
            path.addRect(rect)
        }
        
        // Actualización inmediata para mejor rendimiento
        glowBar.path = path
        glowBar.fillColor = getProgressColor()
        glowBar.alpha = normalizedProgress * Layout.glowAlpha
    }
    
    private func getProgressColor() -> SKColor {
        return UIColor(red: 0, green: 0.4, blue: 0.9, alpha: 1.0)
    }
    
    // MARK: - Public Methods
    func reset() {
        duration = 0
        updateProgress()
    }
    
    func setMaxDuration(_ maxDuration: TimeInterval) {
        self.maxDuration = maxDuration
        updateProgress()
    }
}


#if DEBUG
import SwiftUI

// MARK: - Previews
extension StabilityIndicatorNode {
    static func createPreviewScene() -> SKScene {
        let scene = SKScene(size: CGSize(width: 300, height: 200))
        scene.backgroundColor = .white
        
        let states: [(duration: TimeInterval, position: CGPoint)] = [
            (0.0, CGPoint(x: 75, y: 100)),    // Vacío
            (5.0, CGPoint(x: 150, y: 100)),   // Medio
            (10.0, CGPoint(x: 225, y: 100))   // Lleno
        ]
        
        for state in states {
            let node = StabilityIndicatorNode(size: CGSize(width: 40, height: 120))
            node.position = state.position
            node.duration = state.duration
            scene.addChild(node)
        }
        
        return scene
    }
}

struct StabilityIndicatorPreview: PreviewProvider {
    static var previews: some View {
        SpriteView(scene: StabilityIndicatorNode.createPreviewScene())
            .frame(width: 300, height: 200)
            .previewLayout(.fixed(width: 300, height: 200))
    }
}

#endif
</file>

<file path="MusicBlocks/Paneles/TopBar.swift">
//
//  TopBar.swift
//  MusicBlocks
//
//  Created by Jose R. García on 9/23/25.
//

import SpriteKit
import UIKit

class TopBar: SKNode {
    
    enum TopBarType {
        case main       // Para nivel, puntuación y vidas
        case objectives // Para objetivos
    }
    
    // MARK: - Layout
    private struct Layout {
        // Tamaño fijo del TopBar
        static let cornerRadius: CGFloat = 10
        
        // Separaciones
        static let horizontalPadding: CGFloat = 10 // Se usa para desplazar la fila superior hacia la derecha desde el borde izquierdo del contenedor
        static let verticalPadding: CGFloat = 12 // Se usa para desplazar la fila superior hacia abajo desde el borde superior del contenedor.
        
        // Separaciones para la fila inferior
            static let bottomRowHorizontalPadding: CGFloat = 18

        static let itemSpacing: CGFloat = 8
        
        // Texto
        static let fontSize: CGFloat = 14
        
        // Corazones
        static let heartSize: CGFloat = 16
        static let heartSpacing: CGFloat = 6
        
        // Distancia vertical entre fila superior y fila inferior
        static let rowSpacing: CGFloat = 14
    }
    
    // MARK: - Propiedades
    private let barSize: CGSize
    private let type: TopBarType
    
    // Fila superior
    private let topRow = SKNode()
    private var levelLabel: SKLabelNode?
    private var heartsContainer = SKNode()
    
    // Fila inferior
    private let bottomRow = SKNode()
    private var scoreProgressNode: ScoreProgressNode?
    private var objectivePanel: ObjectiveInfoPanel?
    
    // Vidas
    private var heartNodes: [SKSpriteNode] = []
    private var maxLives: Int = 0
    private var maxExtraLives: Int = 0
    private var lives: Int = 0
    
    // MARK: - Init
    private init(width: CGFloat, height: CGFloat, position: CGPoint, type: TopBarType) {
        self.barSize = CGSize(width: width, height: height)
        self.type = type
        super.init()
        
        self.position = position
        
        // Fondo y sombra (definido en tu UIContainer.swift)
        applyContainerStyle(size: barSize)
        
        // Añadir las dos filas
        addChild(topRow)
        addChild(bottomRow)
        
        switch type {
        case .main:
            setupMainTopBar()
        case .objectives:
            // El panel de objetivos se configura luego en configureObjectivesBar(...)
            break
        }
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: - Crear la TopBar
    static func create(width: CGFloat, height: CGFloat, position: CGPoint, type: TopBarType) -> TopBar {
        return TopBar(width: width, height: height, position: position, type: type)
    }
    
    // MARK: - Setup para la barra principal
    private func setupMainTopBar() {
        // Fila superior: Nivel, separador y contenedor de corazones
        levelLabel = SKLabelNode(fontNamed: "Helvetica-Bold")
        levelLabel?.fontSize = Layout.fontSize
        levelLabel?.fontColor = .purple
        levelLabel?.verticalAlignmentMode = .center
        levelLabel?.horizontalAlignmentMode = .left
        levelLabel?.text = "Nivel ?" // Se actualiza en configure(...)
        
        let separator = SKLabelNode(fontNamed: "Helvetica-Bold")
        separator.text = "·"
        separator.fontSize = Layout.fontSize
        separator.fontColor = .darkGray
        separator.verticalAlignmentMode = .center
        separator.horizontalAlignmentMode = .left
        
        // Layout horizontal en topRow
        var currentX: CGFloat = -barSize.width/2 + Layout.horizontalPadding
        let rowY: CGFloat = barSize.height/2 - Layout.verticalPadding
        
        // 1) levelLabel
        if let label = levelLabel {
            label.position = CGPoint(x: currentX, y: rowY)
            topRow.addChild(label)
            currentX += label.frame.width + Layout.itemSpacing
        }
        
        // 2) separador
        separator.position = CGPoint(x: currentX, y: rowY)
        topRow.addChild(separator)
        currentX += separator.frame.width + Layout.itemSpacing + 5
        
        // 3) heartsContainer
        heartsContainer.position = CGPoint(x: currentX, y: rowY)
        topRow.addChild(heartsContainer)
        // (los corazones se crean en setupHearts(...) luego)

    }
    
    private func setupScoreDisplay() {
        let topRowHeight = topRow.calculateAccumulatedFrame().height
        bottomRow.position = CGPoint(
            x: 0,
            y: (barSize.height/2 - Layout.verticalPadding) - topRowHeight - Layout.rowSpacing
        )
        
        // Ahora restamos bottomRowHorizontalPadding en lugar de horizontalPadding
        let availableWidth = barSize.width - (Layout.bottomRowHorizontalPadding * 2)
        
        let progressNode = ScoreProgressNode(width: availableWidth)
        
        // Centrarlo horizontalmente en bottomRow,
        // dejando bottomRowHorizontalPadding desde el borde izquierdo del TopBar
        progressNode.position = CGPoint(
            x: -barSize.width/2 + Layout.bottomRowHorizontalPadding,
            y: 0
        )
        
        bottomRow.addChild(progressNode)
        scoreProgressNode = progressNode
    }

    
    // MARK: - Configuración
    func configure(withLevel level: GameLevel, objectiveTracker: LevelObjectiveTracker) {
        switch type {
        case .main:
            configureMainBar(withLevel: level)
        case .objectives:
            configureObjectivesBar(withLevel: level, objectiveTracker: objectiveTracker)
        }
    }
    
    private func configureMainBar(withLevel level: GameLevel) {
        // 1) Ajustamos el texto y las vidas
        levelLabel?.text = "Nivel \(level.levelId)"

        maxLives = level.lives.initial
        maxExtraLives = level.lives.extraLives.maxExtra
        lives = level.lives.initial

        setupHearts(in: heartsContainer)
        updateLives(lives)

        // 2) En vez de llamar a setupScoreDisplay() directamente,
        //    lo hacemos en la siguiente iteración del runloop:
        DispatchQueue.main.async {
            self.setupScoreDisplay()
        }
    }
    
    private func configureObjectivesBar(withLevel level: GameLevel, objectiveTracker: LevelObjectiveTracker) {
        topRow.removeFromParent()  // si no usas la fila superior

        objectivePanel?.removeFromParent()
        
        let panelSize = CGSize(width: barSize.width, height: barSize.height)
        let panel = ObjectivePanelFactory.createPanel(
            for: level.objectives.primary,
            size: panelSize,
            tracker: objectiveTracker
        )
        objectivePanel = panel
        
        // bottomRow centrado en (0,0)
        bottomRow.position = .zero
        bottomRow.removeAllChildren()
        
        // AHORA, para alinear el borde izquierdo del panel con la TopBar:
        // la TopBar va de x = -barSize.width/2 a x = +barSize.width/2
        // si pones panel.position.x = -barSize.width/2 + 10, dejas 10 px de margen
        panel.position = CGPoint(x: -barSize.width/2 + 10, y: 0)
        
        bottomRow.addChild(panel)
    }


    
    // MARK: - Score y Vidas
    func updateScore(_ newScore: Int) {
        if type == .main,
           let currentLevel = GameManager.shared.currentLevel {
            scoreProgressNode?.updateProgress(score: newScore, maxScore: currentLevel.maxScore)
        }
    }
    
    func updateLives(_ newLives: Int) {
        if type == .main {
            lives = newLives
            updateHeartsDisplay()
        }
    }
    
    // MARK: - Corazones
    private func setupHearts(in container: SKNode) {
        // Limpia corazones anteriores
        heartNodes.forEach { $0.removeFromParent() }
        heartNodes.removeAll()
        
        var currentX: CGFloat = 0
        // Vidas base
        for _ in 0..<maxLives {
            let heart = SKSpriteNode(imageNamed: "heart_filled")
            heart.size = CGSize(width: Layout.heartSize, height: Layout.heartSize)
            heart.position = CGPoint(x: currentX, y: 0)
            container.addChild(heart)
            heartNodes.append(heart)
            currentX += Layout.heartSize + Layout.heartSpacing
        }
        
        // Vidas extra
        for _ in 0..<maxExtraLives {
            let heart = SKSpriteNode(imageNamed: "heart_extra")
            heart.size = CGSize(width: Layout.heartSize, height: Layout.heartSize)
            heart.alpha = 0
            heart.position = CGPoint(x: currentX, y: 0)
            container.addChild(heart)
            heartNodes.append(heart)
            currentX += Layout.heartSize + Layout.heartSpacing
        }
    }
    
    private func updateHeartsDisplay() {
        for (index, heart) in heartNodes.enumerated() {
            heart.alpha = 1.0
            
            if index < maxLives {
                if index < lives {
                    heart.texture = SKTexture(imageNamed: "heart_filled")
                } else {
                    heart.texture = SKTexture(imageNamed: "heart_empty")
                }
            } else if index < (maxLives + maxExtraLives) {
                if index < lives {
                    heart.texture = SKTexture(imageNamed: "heart_extra_filled")
                    heart.alpha = 1.0
                } else {
                    heart.alpha = 0
                }
            }
        }
    }
    
    // MARK: - Objetivos
    func updateObjectiveInfo(with progress: ObjectiveProgress) {
        if type == .objectives {
            objectivePanel?.updateInfo(with: progress)
        }
    }
}


// MARK: - SwiftUI Previews
#if DEBUG
import SwiftUI

struct TopBarPreview: PreviewProvider {
    static var previews: some View {
        TopBarPreviewContainer()
            .previewDisplayName("TopBar")
    }
}

struct TopBarPreviewContainer: View {
    var body: some View {
        GeometryReader { geometry in
            SpriteView(scene: createScene(size: geometry.size))
                .background(Color.gray.opacity(0.2))
        }
    }
    
    private func createScene(size: CGSize) -> SKScene {
        let scene = SKScene(size: size)
        scene.backgroundColor = .darkGray
        
        let level = GameLevel(
            levelId: 1,
            name: "Nivel de prueba",
            maxScore: 600,
            allowedStyles: [],
            fallingSpeed: FallingSpeed(initial: 8.0, increment: 0.0),
            lives: Lives(
                initial: 3,
                extraLives: ExtraLives(scoreThresholds: [500, 1000], maxExtra: 2)
            ),
            objectives: Objectives(primary: Objective(
                type: "score",
                target: 1000,
                timeLimit: 180,
                minimumAccuracy: nil,
                details: nil
            )),
            blocks: [:]
        )
        
        // TopBar de tipo .main (izquierda)
        let topBarWidth = min(size.width * 0.45, 300)
        let topBarHeight: CGFloat = 60
        
        let leftBar = TopBar.create(
            width: topBarWidth,
            height: topBarHeight,
            position: CGPoint(x: size.width/2, y: size.height/2 + 50),
            type: .main
        )
        leftBar.configure(withLevel: level, objectiveTracker: LevelObjectiveTracker(level: level))
        leftBar.updateScore(300)
        leftBar.updateLives(2)
        
        scene.addChild(leftBar)
        
        // TopBar de tipo .objectives (derecha)
        let rightBar = TopBar.create(
            width: topBarWidth,
            height: topBarHeight,
            position: CGPoint(x: size.width/2, y: size.height/2 - 50),
            type: .objectives
        )
        rightBar.configure(withLevel: level, objectiveTracker: LevelObjectiveTracker(level: level))
        let progress = ObjectiveProgress(
            score: 300,
            notesHit: 15,
            accuracySum: 85.0,
            accuracyCount: 1,
            totalBlocksDestroyed: 15,
            timeElapsed: 45
        )
        rightBar.updateObjectiveInfo(with: progress)
        
        scene.addChild(rightBar)
        
        return scene
    }
}
#endif
</file>

<file path="MusicBlocks/Paneles/TopBarComponents.swift">
//
//  TopBarComponents.swift
//  MusicBlocks
//
//  Created by Jose R. García on 14/3/25.
//

import SpriteKit
import UIKit
import Foundation

// MARK: - Constantes y Configuración
private enum TopBarLayout {
    static let cornerRadius: CGFloat = 15
    static let padding: CGFloat = 18
    static let iconTextSpacing: CGFloat = 16      // Reducido para mejor ajuste
    static let fontSize: CGFloat = 14
    static let titleFontSize: CGFloat = 16
    static let smallFontSize: CGFloat = 12
    static let verticalSpacing: CGFloat = 8       // Aumentado para mejor separación
    static let horizontalSpacing: CGFloat = 8
    static let panelHeight: CGFloat = 60
    /// Tamaño máximo para la dimensión más larga del icono.
    static let iconSize: CGFloat = 18
    
    // Valores para layout de columnas en block_destruction
    static let columnWidth: CGFloat = 80          // Ancho de cada columna
    static let rowSpacing: CGFloat = 20           // Espacio vertical entre filas
    static let maxItemsPerColumn: Int = 2         // Máximo de items por columna
    static let maxColumns: Int = 4                // Aumentado a 4 columnas máximo
}

// MARK: - Estructuras de Datos
struct ObjectiveProgress {
    var score: Int = 0
    var notesHit: Int = 0
    var accuracySum: Double = 0
    var accuracyCount: Int = 0
    var blocksByType: [String: Int] = [:]
    var totalBlocksDestroyed: Int = 0
    var timeElapsed: TimeInterval = 0
    
    var averageAccuracy: Double {
        return accuracyCount > 0 ? accuracySum / Double(accuracyCount) : 0
    }
}

// MARK: - Iconos
enum ObjectiveIcon {
    case score
    case totalNotes
    case accuracy
    case blocks
    case time
    
    var imageName: String {
        switch self {
        case .score: return "coin_icon"
        case .totalNotes: return "note_icon"
        case .accuracy: return "target_icon"
        case .blocks: return "defaultBlock_icon"
        case .time: return "timer_icon"
        }
    }
}

// MARK: - Bloque extra: mapeo de estilo -> icono
private let blockStyleIcons: [String: String] = [
    "defaultBlock": "defaultBlock_icon",
    "iceBlock": "iceBlock_icon",
    "hardiceBlock": "hardiceBlock_icon",
    "ghostBlock": "ghostBlock_icon",
    "changingBlock": "changingBlock_icon",
    "explosiveBlock": "explosiveBlock_icon",
]

// MARK: - ObjectiveIconNode
class ObjectiveIconNode: SKNode {
    private let icon: SKSpriteNode
    private let value: SKLabelNode
    
    init(type: ObjectiveIcon) {
        // Cargamos la textura
        let iconTexture = SKTexture(imageNamed: type.imageName)
        
        // Mantener relación de aspecto
        let originalSize = iconTexture.size()
        let w = originalSize.width
        let h = originalSize.height
        
        // Ratio para ajustar la dimensión más larga a 'iconSize'
        let maxDim: CGFloat = TopBarLayout.iconSize
        let scale = max(w, h) > 0 ? (maxDim / max(w, h)) : 1.0
        
        let finalWidth = w * scale
        let finalHeight = h * scale
        
        icon = SKSpriteNode(texture: iconTexture)
        icon.size = CGSize(width: finalWidth, height: finalHeight)
        
        value = SKLabelNode(fontNamed: "Helvetica")
        
        super.init()
        
        // Posicionamos el icono y la etiqueta
        icon.position = CGPoint(x: -TopBarLayout.iconTextSpacing/2, y: 0)
        
        value.fontSize = TopBarLayout.smallFontSize
        value.fontColor = .darkGray
        value.verticalAlignmentMode = .center
        value.horizontalAlignmentMode = .left
        value.position = CGPoint(x: icon.position.x + TopBarLayout.iconTextSpacing, y: 0)
        
        addChild(icon)
        addChild(value)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    func updateValueColor(_ color: SKColor) {
        value.fontColor = color
    }
    
    func updateValue(_ newValue: String) {
        value.text = newValue
    }
}

// MARK: - Nodos Base
class TopBarBaseNode: SKNode {
    var size: CGSize
    
    init(size: CGSize) {
        self.size = size
        super.init()
        setupBackground()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    func setupBackground() {
        let background = SKShapeNode(rectOf: size, cornerRadius: TopBarLayout.cornerRadius)
        background.fillColor = .white
        background.strokeColor = .clear
        background.alpha = 0.95
        addChild(background)
    }
    
    func createLabel(_ text: String, fontSize: CGFloat = TopBarLayout.fontSize) -> SKLabelNode {
        let label = SKLabelNode(fontNamed: "Helvetica")
        label.text = text
        label.fontSize = fontSize
        label.fontColor = .darkGray
        return label
    }
}

// MARK: - Componente de Tiempo
class TimeDisplayNode: SKNode {
    private let timeIcon: SKSpriteNode
    private let timeLabel: SKLabelNode
    private let timeLimit: TimeInterval
    private let startTime: Date
    
    init(timeLimit: TimeInterval) {
        // Crear icono de tiempo
        let iconTexture = SKTexture(imageNamed: "timer_icon")
        timeIcon = SKSpriteNode(texture: iconTexture)
        
        // Mantener la relación de aspecto para el icono del tiempo, si lo deseas
        let originalSize = iconTexture.size()
        let w = originalSize.width
        let h = originalSize.height
        let maxDim: CGFloat = TopBarLayout.iconSize
        let scale = max(w, h) > 0 ? (maxDim / max(w, h)) : 1.0
        
        timeIcon.size = CGSize(width: w * scale, height: h * scale)
        
        self.timeLabel = SKLabelNode(fontNamed: "Helvetica")
        self.timeLimit = timeLimit
        self.startTime = Date()
        
        super.init()
        
        setupTimeComponents()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupTimeComponents() {
        // Posición del icono
        timeIcon.position = CGPoint(x: -TopBarLayout.iconTextSpacing/2, y: 0)
        addChild(timeIcon)
        
        // Configuración de la etiqueta
        timeLabel.fontSize = TopBarLayout.fontSize
        timeLabel.fontColor = .darkGray
        timeLabel.verticalAlignmentMode = .center
        timeLabel.horizontalAlignmentMode = .left
        timeLabel.position = CGPoint(x: timeIcon.position.x + TopBarLayout.iconTextSpacing, y: 0)
        addChild(timeLabel)
        
        // Actualizar el tiempo inicial
        update()
    }
    
    func update() {
        if timeLimit == 0 {
            timeLabel.text = "∞"
            return
        }
        
        let elapsedTime = Date().timeIntervalSince(startTime)
        let remainingTime = max(timeLimit - elapsedTime, 0)
        let minutes = Int(remainingTime) / 60
        let seconds = Int(remainingTime) % 60
        
        timeLabel.text = String(format: "%02d:%02d", minutes, seconds)
        timeLabel.fontColor = remainingTime < 30 ? .red : .darkGray
    }
}

// MARK: - Panel Base de Objetivos
class ObjectiveInfoPanel: TopBarBaseNode {
    weak var objectiveTracker: LevelObjectiveTracker?
    
    // Icono único para "score", "time", etc.
    private var objectiveIconNode: ObjectiveIconNode?
    private var timeIconNode: ObjectiveIconNode?
    
    // Lista de iconos por estilo de bloque
    private var blockIcons: [String: ObjectiveIconNode] = [:]
    
    // Contenedor para el objetivo "block_destruction"
    private var blockDestructionContainer: SKNode?
    
    init(size: CGSize, objectiveTracker: LevelObjectiveTracker) {
        self.objectiveTracker = objectiveTracker
        super.init(size: size)
        setupPanel()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func setupBackground() {
        // No crear fondo blanco para el panel de objetivos
    }
    
    func setupPanel() {
        guard let objective = objectiveTracker?.getPrimaryObjective() else { return }
        
        let contentContainer = SKNode()
        contentContainer.position = CGPoint(x: TopBarLayout.padding, y: 0)
        addChild(contentContainer)
        
        switch objective.type {
        case "block_destruction":
            // Para block_destruction, creamos un contenedor especial que organizará los bloques en columnas
            let container = SKNode()
            contentContainer.addChild(container)
            blockDestructionContainer = container
            
            // Ya no creamos el timeIconNode aquí, lo incluiremos en el contenedor de columnas
            
        case "total_blocks":
            // Para total_blocks, solo mostramos el total y opcionalmente el tiempo
            objectiveIconNode = ObjectiveIconNode(type: .blocks)
            if let objIcon = objectiveIconNode {
                objIcon.position = CGPoint(x: 0, y: TopBarLayout.verticalSpacing * 2)
                contentContainer.addChild(objIcon)
            }
            
            // Si hay límite de tiempo
            if objective.timeLimit != nil {
                timeIconNode = ObjectiveIconNode(type: .time)
                if let timeIcon = timeIconNode {
                    timeIcon.position = CGPoint(x: 0, y: -TopBarLayout.verticalSpacing * 2)
                    contentContainer.addChild(timeIcon)
                }
            }
            
        default:
            let iconType: ObjectiveIcon = getObjectiveIconType(for: objective.type)
            objectiveIconNode = ObjectiveIconNode(type: iconType)
            if let objIcon = objectiveIconNode {
                objIcon.position = CGPoint(x: 0, y: TopBarLayout.verticalSpacing * 2)
                contentContainer.addChild(objIcon)
            }
            
            timeIconNode = ObjectiveIconNode(type: .time)
            if let timeIcon = timeIconNode {
                timeIcon.position = CGPoint(x: 0, y: -TopBarLayout.verticalSpacing * 2)
                contentContainer.addChild(timeIcon)
            }
        }
    }

    
    private func createBlockIconNode(for blockType: String) -> ObjectiveIconNode {
        let imageName = blockStyleIcons[blockType] ?? "default_block_icon"
        let iconTexture = SKTexture(imageNamed: imageName)
        
        // Mantener la relación de aspecto
        let originalSize = iconTexture.size()
        let w = originalSize.width
        let h = originalSize.height
        let maxDim: CGFloat = TopBarLayout.iconSize
        let scale = max(w, h) > 0 ? (maxDim / max(w, h)) : 1.0
        
        let finalWidth = w * scale
        let finalHeight = h * scale
        
        // Creamos un icono .blocks
        let node = ObjectiveIconNode(type: .blocks)
        
        // Reemplazamos textura y tamaño del SKSpriteNode "existingIcon"
        if let existingIcon = node.children.first as? SKSpriteNode {
            existingIcon.texture = iconTexture
            existingIcon.size = CGSize(width: finalWidth, height: finalHeight)
        }
        
        return node
    }
    
    private func getObjectiveIconType(for objectiveType: String) -> ObjectiveIcon {
        switch objectiveType {
        case "score": return .score
        case "total_notes": return .totalNotes
        case "note_accuracy": return .accuracy
        case "block_destruction", "total_blocks": return .blocks
        default: return .score
        }
    }
    
    func updateInfo(with progress: ObjectiveProgress) {
        guard let objective = objectiveTracker?.getPrimaryObjective() else { return }
        
        switch objective.type {
        case "block_destruction":
            if let details = objective.details {
                // Actualizar el layout de los bloques en formato de columnas
                updateBlockDestructionLayout(with: progress, details: details)
            }
            
            if let timeLimit = objective.timeLimit {
                updateTimeIcon(progress: progress, timeLimit: timeLimit)
            } else {
                timeIconNode?.updateValue("∞")
            }
            
        default:
            switch objective.type {
            case "score":
                objectiveIconNode?.updateValue("\(progress.score)/\(objective.target ?? 0)")
            case "total_notes":
                objectiveIconNode?.updateValue("\(progress.notesHit)/\(objective.target ?? 0)")
            case "note_accuracy":
                let accuracy = Int(progress.averageAccuracy * 100)
                objectiveIconNode?.updateValue("\(accuracy)%")
            case "total_blocks":
                objectiveIconNode?.updateValue("\(progress.totalBlocksDestroyed)/\(objective.target ?? 0)")
            default:
                break
            }
            
            if let timeLimit = objective.timeLimit {
                updateTimeIcon(progress: progress, timeLimit: timeLimit)
            } else {
                timeIconNode?.updateValue("∞")
            }
        }
    }
    
    // Método para actualizar el layout de block_destruction en formato de columnas
    private func updateBlockDestructionLayout(with progress: ObjectiveProgress, details: [String: Int]) {
         // Limpiar el contenedor existente si hay uno
         blockDestructionContainer?.removeAllChildren()
         guard let container = blockDestructionContainer else { return }
         
         guard let objective = objectiveTracker?.getPrimaryObjective() else { return }
         
         // Crear una lista de todos los elementos a mostrar (bloques + tiempo si hay límite)
         var displayItems: [(type: String, label: String, isTimeIcon: Bool)] = []
         
         // Añadir bloques
         for (blockType, required) in details {
             let destroyed = progress.blocksByType[blockType, default: 0]
             let text = "\(destroyed)/\(required)"
             displayItems.append((type: blockType, label: text, isTimeIcon: false))
         }
         
         // Añadir tiempo si hay límite
         if let timeLimit = objective.timeLimit {
             let timeLimitInterval = TimeInterval(timeLimit)
             let remainingTime = max(timeLimitInterval - progress.timeElapsed, 0)
             let minutes = Int(remainingTime) / 60
             let seconds = Int(remainingTime) % 60
             let timeText = String(format: "%02d:%02d", minutes, seconds)
             displayItems.append((type: "time", label: timeText, isTimeIcon: true))
         }
         
         // Calcular cuántas columnas necesitamos
         let totalItems = displayItems.count
         let columnsNeeded = min((totalItems + 1) / 2, TopBarLayout.maxColumns) // Máximo 4 columnas
         
         // Calcular posición inicial
         var startX: CGFloat = 0
         
         // Si tenemos más de una columna, alineamos desde la izquierda
         if columnsNeeded > 1 {
             startX = -((CGFloat(columnsNeeded - 1) * TopBarLayout.columnWidth) / 2)
         }
         
         var currentX = startX
         var currentY: CGFloat = TopBarLayout.rowSpacing // Primera fila
         var itemsInCurrentColumn = 0
         
         // Organizar bloques en columnas
        for (_, item) in displayItems.enumerated() {
             // Si completamos 2 items en la columna actual, pasamos a la siguiente columna
             if itemsInCurrentColumn >= TopBarLayout.maxItemsPerColumn {
                 currentX += TopBarLayout.columnWidth
                 currentY = TopBarLayout.rowSpacing // Volvemos a la primera fila
                 itemsInCurrentColumn = 0
             }
             
             // Crear nodo para este elemento
             let iconNode: ObjectiveIconNode
             
             if item.isTimeIcon {
                 iconNode = ObjectiveIconNode(type: .time)
             } else {
                 iconNode = createBlockIconNode(for: item.type)
             }
             
             // Posicionar según la columna y fila actual
             let yPos = currentY - (CGFloat(itemsInCurrentColumn) * TopBarLayout.rowSpacing)
             iconNode.position = CGPoint(x: currentX, y: yPos)
             
             // Actualizar valor
             iconNode.updateValue(item.label)
             
             // Si es el icono de tiempo y queda poco tiempo, colorear en rojo
             if item.isTimeIcon {
                 if let timeLimit = objective.timeLimit {
                     let timeLimitInterval = TimeInterval(timeLimit)
                     let remainingTime = max(timeLimitInterval - progress.timeElapsed, 0)
                     if remainingTime < 30 {
                         iconNode.updateValueColor(.red)
                     }
                 }
             }
             
             // Añadir al contenedor
             container.addChild(iconNode)
             
             // Actualizar contadores
             itemsInCurrentColumn += 1
         }
         
         // Posicionar el contenedor en la parte superior del panel
         container.position = CGPoint(x: 0, y: TopBarLayout.verticalSpacing * 2)
     }
    
    private func updateTimeIcon(progress: ObjectiveProgress, timeLimit: Int) {
        let timeLimitInterval = TimeInterval(timeLimit)
        let remainingTime = max(timeLimitInterval - progress.timeElapsed, 0)
        let minutes = Int(remainingTime) / 60
        let seconds = Int(remainingTime) % 60
        let timeText = String(format: "%02d:%02d", minutes, seconds)
        
        timeIconNode?.updateValue(timeText)
        
        if remainingTime < 30 {
            timeIconNode?.updateValueColor(.red)
        } else {
            timeIconNode?.updateValueColor(.darkGray)
        }
    }
}

    // MARK: - Fábrica de Paneles
    class ObjectivePanelFactory {
        static func createPanel(for objective: Objective, size: CGSize, tracker: LevelObjectiveTracker) -> ObjectiveInfoPanel {
            return ObjectiveInfoPanel(size: size, objectiveTracker: tracker)
        }
    }

// MARK: - Preview
#if DEBUG
import SwiftUI

/// Vista previa que muestra cada ObjectiveInfoPanel en una escena separada
struct ObjectivePanelsPreview: PreviewProvider {
    static var previews: some View {
        VStack {
            ScoreObjectivePreviewContainer()
                .frame(height: 150)
                .padding(.bottom, 10)
                .previewDisplayName("Score Objective")
            
            TotalNotesObjectivePreviewContainer()
                .frame(height: 150)
                .padding(.bottom, 10)
                .previewDisplayName("Total Notes Objective")
            
            NoteAccuracyObjectivePreviewContainer()
                .frame(height: 150)
                .padding(.bottom, 10)
                .previewDisplayName("Note Accuracy Objective")
            
            BlockDestructionObjectivePreviewContainer()
                .frame(height: 150)
                .padding(.bottom, 10)
                .previewDisplayName("Block Destruction Objective (Columnas)")
            
            TotalBlocksObjectivePreviewContainer()
                .frame(height: 150)
                .previewDisplayName("Total Blocks Objective")
        }
    }
}

// Contenedor base para reutilizar código
protocol ObjectivePreviewContainer: View {
    var objectiveType: String { get }
    func createObjectiveDetails() -> [String: Int]?
    func createBlocksDestroyed() -> [String: Int]
    func createAllowedStyles() -> [String]
}

extension ObjectivePreviewContainer {
    func createPreviewScene(size: CGSize) -> SKScene {
        let scene = SKScene(size: size)
        scene.scaleMode = .resizeFill
        scene.backgroundColor = .lightGray
        
        let objectiveDetails = createObjectiveDetails()
        let allowedStyles = createAllowedStyles()
        let blocksDestroyed = createBlocksDestroyed()
        
        let objective = Objective(
            type: objectiveType,
            target: 1000,
            timeLimit: 180,
            minimumAccuracy: objectiveType == "note_accuracy" ? 0.85 : nil,
            details: objectiveDetails
        )
        
        let level = GameLevel(
            levelId: 1,
            name: "Nivel de prueba",
            maxScore: 500,
            allowedStyles: allowedStyles,
            fallingSpeed: FallingSpeed(initial: 8.0, increment: 0.0),
            lives: Lives(
                initial: 3,
                extraLives: ExtraLives(scoreThresholds: [], maxExtra: 0)
            ),
            objectives: Objectives(primary: objective),
            blocks: [:]
        )
        
        let tracker = LevelObjectiveTracker(level: level)
        let progress = ObjectiveProgress(
            score: 350,
            notesHit: 40,
            accuracySum: 85.0,
            accuracyCount: 100,
            blocksByType: blocksDestroyed,
            totalBlocksDestroyed: blocksDestroyed.values.reduce(0, +),
            timeElapsed: 60
        )
        
        let panelSize = CGSize(width: size.width * 0.8, height: size.height * 0.7)
        let panel = ObjectivePanelFactory.createPanel(for: objective, size: panelSize, tracker: tracker)
        panel.updateInfo(with: progress)
        
        panel.position = CGPoint(x: size.width/2, y: size.height/2)
        scene.addChild(panel)
        
        return scene
    }
}

// Implementaciones específicas para cada tipo de objetivo
struct ScoreObjectivePreviewContainer: View, ObjectivePreviewContainer {
    var objectiveType: String { "score" }
    
    func createObjectiveDetails() -> [String: Int]? { nil }
    func createBlocksDestroyed() -> [String: Int] { [:] }
    func createAllowedStyles() -> [String] { [] }
    
    var body: some View {
        GeometryReader { geometry in
            SpriteView(scene: createPreviewScene(size: geometry.size))
                .background(Color.gray.opacity(0.2))
        }
    }
}

struct TotalNotesObjectivePreviewContainer: View, ObjectivePreviewContainer {
    var objectiveType: String { "total_notes" }
    
    func createObjectiveDetails() -> [String: Int]? { nil }
    func createBlocksDestroyed() -> [String: Int] { [:] }
    func createAllowedStyles() -> [String] { [] }
    
    var body: some View {
        GeometryReader { geometry in
            SpriteView(scene: createPreviewScene(size: geometry.size))
                .background(Color.gray.opacity(0.2))
        }
    }
}

struct NoteAccuracyObjectivePreviewContainer: View, ObjectivePreviewContainer {
    var objectiveType: String { "note_accuracy" }
    
    func createObjectiveDetails() -> [String: Int]? { nil }
    func createBlocksDestroyed() -> [String: Int] { [:] }
    func createAllowedStyles() -> [String] { [] }
    
    var body: some View {
        GeometryReader { geometry in
            SpriteView(scene: createPreviewScene(size: geometry.size))
                .background(Color.gray.opacity(0.2))
        }
    }
}

struct BlockDestructionObjectivePreviewContainer: View, ObjectivePreviewContainer {
    var objectiveType: String { "block_destruction" }
    
    func createObjectiveDetails() -> [String: Int]? {
        return [
            "defaultBlock": 5,
            "iceBlock": 3,
            "hardiceBlock": 7,
            "ghostBlock": 4,
            "changingBlock": 6,
            "explosiveBlock": 2
        ]
    }
    
    func createBlocksDestroyed() -> [String: Int] {
        return [
            "defaultBlock": 2,
            "iceBlock": 3,
            "hardiceBlock": 5,
            "ghostBlock": 1,
            "changingBlock": 4,
            "explosiveBlock": 0
        ]
    }
    
    func createAllowedStyles() -> [String] {
        return ["defaultBlock", "iceBlock", "hardiceBlock", "ghostBlock", "changingBlock", "explosiveBlock"]
    }
    
    var body: some View {
        GeometryReader { geometry in
            SpriteView(scene: createPreviewScene(size: geometry.size))
                .background(Color.gray.opacity(0.2))
        }
    }
    
    // Sobrescribir la función createPreviewScene para asegurar que incluya tiempo
    func createPreviewScene(size: CGSize) -> SKScene {
        let scene = SKScene(size: size)
        scene.scaleMode = .resizeFill
        scene.backgroundColor = .lightGray
        
        let objectiveDetails = createObjectiveDetails()
        let allowedStyles = createAllowedStyles()
        let blocksDestroyed = createBlocksDestroyed()
        
        let objective = Objective(
            type: objectiveType,
            target: 1000,
            timeLimit: 180, // Asegurar que tenga límite de tiempo
            minimumAccuracy: nil,
            details: objectiveDetails
        )
        
        let level = GameLevel(
            levelId: 1,
            name: "Nivel de prueba",
            maxScore: 500,
            allowedStyles: allowedStyles,
            fallingSpeed: FallingSpeed(initial: 8.0, increment: 0.0),
            lives: Lives(
                initial: 3,
                extraLives: ExtraLives(scoreThresholds: [], maxExtra: 0)
            ),
            objectives: Objectives(primary: objective),
            blocks: [:]
        )
        
        let tracker = LevelObjectiveTracker(level: level)
        let progress = ObjectiveProgress(
            score: 350,
            notesHit: 40,
            accuracySum: 85.0,
            accuracyCount: 100,
            blocksByType: blocksDestroyed,
            totalBlocksDestroyed: blocksDestroyed.values.reduce(0, +),
            timeElapsed: 60
        )
        
        let panelSize = CGSize(width: size.width * 0.8, height: size.height * 0.7)
        let panel = ObjectivePanelFactory.createPanel(for: objective, size: panelSize, tracker: tracker)
        panel.updateInfo(with: progress)
        
        panel.position = CGPoint(x: size.width/2, y: size.height/2)
        scene.addChild(panel)
        
        return scene
    }
}

struct TotalBlocksObjectivePreviewContainer: View, ObjectivePreviewContainer {
    var objectiveType: String { "total_blocks" }
    
    func createObjectiveDetails() -> [String: Int]? { nil }
    
    func createBlocksDestroyed() -> [String: Int] {
        // Para total_blocks solo importa el total, no los detalles por tipo
        return [
            "defaultBlock": 3,
            "iceBlock": 5,
            "hardiceBlock": 2,
        ]
    }
    
    func createAllowedStyles() -> [String] {
        return ["defaultBlock", "iceBlock", "hardiceBlock"]
    }
    
    var body: some View {
        GeometryReader { geometry in
            SpriteView(scene: createPreviewScene(size: geometry.size))
                .background(Color.gray.opacity(0.2))
        }
    }
}
#endif
</file>

<file path="MusicBlocks/Paneles/TuningIndicatorNode.swift">
//
//  TuningIndicatorNode.swift
//  MusicBlocks
//
//  Created by Jose R. García on 25/2/25.
//

//
//  TuningIndicatorNode.swift
//  MusicBlocks
//
//  Creado por Jose R. García el 25/2/25.
//

import SpriteKit

// Extensión para limitar valores numéricos
extension Comparable {
    func clamped(to range: ClosedRange<Self>) -> Self {
        return min(max(self, range.lowerBound), range.upperBound)
    }
}

class TuningIndicatorNode: SKNode {
    // MARK: - Layout Configuration
    private struct Layout {
        static let barWidthRatio: CGFloat = 0.8
        static let markingWidthRatio: CGFloat = 0.6
        // Cambiamos el ratio del indicador para que ocupe todo el ancho de la barra
        static let indicatorSizeRatio: CGFloat = 1.0  // Cambiado de 0.15 a 1.0
        static let backgroundAlpha: CGFloat = 0.15
        static let markingsAlpha: CGFloat = 0.3
        static let glowAlpha: CGFloat = 0.8
        static let inactiveAlpha: CGFloat = 0.2
        static let animationDuration: TimeInterval = 0.2
        static let glowRadius: Float = 15.0
        static let glowLineWidth: CGFloat = 8.0
    }
    
    // MARK: - Properties
    var containerSize: CGSize {
        didSet {
            updateLayout()
        }
    }
    
    private let backgroundBar: SKShapeNode = SKShapeNode()
    private var markings: [SKShapeNode] = []
    
    // Indicador central
    private let indicatorContainer: SKNode = SKNode()
    private let indicatorCore: SKShapeNode = SKShapeNode()
    
    // Glow de la barra (se muestra como contorno)
    private let barGlow: SKEffectNode = SKEffectNode()
    private let barGlowShape: SKShapeNode = SKShapeNode()
    
    var deviation: Double = 0 {
        didSet {
            updateIndicator()
        }
    }
    
    var isActive: Bool = false {
        didSet {
            updateIndicator()
        }
    }
    
    // MARK: - Initialization
    init(size: CGSize) {
        self.containerSize = size
        
        // Crear marcas basadas en valores fijos [-25, -10, 0, 10, 25]
        let markValues = [-25, -10, 0, 10, 25]
        for _ in markValues {
            let mark = SKShapeNode()
            markings.append(mark)
        }
        
        super.init()
        
        setupNodes()
        updateLayout()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) no ha sido implementado")
    }
    
    // MARK: - Setup
    private func setupNodes() {
        // Aplicar estilo común del contenedor
        applyContainerStyle(size: containerSize)
        
        // Mantener configuración del glow
        barGlow.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": Layout.glowRadius])
        barGlow.shouldRasterize = true
        barGlow.addChild(barGlowShape)
        barGlow.zPosition = -1
        addChild(barGlow)
        
        // Configurar marcas
        for mark in markings {
            mark.fillColor = .darkGray
            mark.strokeColor = .clear
            mark.alpha = Layout.markingsAlpha
            addChild(mark)
        }
        
        // Configurar indicador central
        addChild(indicatorContainer)
        
        // Configurar el indicador core (círculo que ocupa todo el ancho de la barra)
        let barWidth = containerSize.width * Layout.barWidthRatio
        let indicatorDiameter = barWidth // El diámetro será igual al ancho de la barra
        let indicatorRadius = indicatorDiameter / 2
        
        indicatorCore.path = CGPath(ellipseIn: CGRect(x: -indicatorRadius,
                                                     y: -indicatorRadius,
                                                     width: indicatorDiameter,
                                                     height: indicatorDiameter),
                                  transform: nil)
        indicatorCore.strokeColor = .clear
        indicatorContainer.addChild(indicatorCore)
        
        updateIndicator()
    }
    
    // MARK: - Layout Update
    private func updateLayout() {
        let barWidth = containerSize.width * Layout.barWidthRatio
        let barHeight = containerSize.height
        
        let bgRect = CGRect(x: -barWidth/2, y: -barHeight/2, width: barWidth, height: barHeight)
        backgroundBar.path = CGPath(rect: bgRect, transform: nil)
        
        barGlowShape.path = CGPath(rect: bgRect, transform: nil)
        barGlowShape.lineWidth = Layout.glowLineWidth
        
        // Actualizar marcas
        for (index, mark) in markings.enumerated() {
            let progress = CGFloat(index) / CGFloat(markings.count - 1)
            let yPosition = -containerSize.height / 2 + containerSize.height * progress
            mark.position = CGPoint(x: 0, y: yPosition)
            let markWidth: CGFloat
            // Se define una marca central más ancha (por ejemplo, índice 2)
            if index == 2 {
                markWidth = barWidth * 0.8
            } else {
                markWidth = barWidth * Layout.markingWidthRatio
            }
            let markRect = CGRect(x: -markWidth/2, y: -0.5, width: markWidth, height: 1)
            mark.path = CGPath(rect: markRect, transform: nil)
        }
        
        updateIndicator()
    }
    
    // MARK: - Updates
    private func updateIndicator() {
        let normalizedDeviation = CGFloat((deviation + 25) / 50).clamped(to: 0...1)
        let barWidth = containerSize.width * Layout.barWidthRatio
        let indicatorRadius = barWidth * Layout.indicatorSizeRatio
        let effectiveHeight = containerSize.height - (indicatorRadius * 2)
        let minY = -containerSize.height / 2 + indicatorRadius
        let yPosition = minY + (effectiveHeight * normalizedDeviation)
        
        // Asegúrate de que el indicador tenga una forma definida
        if indicatorCore.path == nil {
            indicatorCore.path = CGPath(ellipseIn: CGRect(x: -indicatorRadius, y: -indicatorRadius,
                                                       width: indicatorRadius*2, height: indicatorRadius*2), transform: nil)
        }
        
        let moveAction = SKAction.move(to: CGPoint(x: 0, y: yPosition), duration: Layout.animationDuration)
        moveAction.timingMode = .easeOut
        indicatorContainer.run(moveAction)
        
        let color = getDeviationColor()
        indicatorCore.fillColor = color
        indicatorCore.alpha = isActive ? Layout.glowAlpha : Layout.inactiveAlpha
        
        barGlowShape.strokeColor = color
        barGlowShape.fillColor = .clear
        barGlowShape.alpha = isActive ? Layout.glowAlpha : Layout.inactiveAlpha
    }
    
    private func getDeviationColor() -> SKColor {
        guard isActive else {
            return .gray
        }
        let absDeviation = abs(deviation)
        if absDeviation < 5 {
            return .green
        } else if absDeviation < 15 {
            return .orange
        } else {
            return .red
        }
    }
}


#if DEBUG
import SwiftUI

// MARK: - Previews
extension TuningIndicatorNode {
    static func createPreviewScene() -> SKScene {
        let scene = SKScene(size: CGSize(width: 300, height: 200))
        scene.backgroundColor = .white
        
        let states: [(deviation: Double, isActive: Bool, position: CGPoint)] = [
            (0, true, CGPoint(x: 75, y: 100)),     // Perfecta afinación
            (12, true, CGPoint(x: 150, y: 100)),   // Desviación leve
            (-20, true, CGPoint(x: 225, y: 100))   // Desviación grande
        ]
        
        for state in states {
            let node = TuningIndicatorNode(size: CGSize(width: 20, height: 190))
            node.position = state.position
            node.deviation = state.deviation
            node.isActive = state.isActive
            scene.addChild(node)
        }
        
        return scene
    }
}

struct TuningIndicatorPreview: PreviewProvider {
    static var previews: some View {
        SpriteView(scene: TuningIndicatorNode.createPreviewScene())
            .frame(width: 300, height: 200)
            .previewLayout(.fixed(width: 300, height: 200))
    }
}

#endif
</file>

<file path="MusicBlocks/Paneles/UIContainer.swift">
//
//  UIContainer.swift 
//  MusicBlocks
//
//  Created by Jose R. García on 8/3/25.
//

import SpriteKit

struct CommonStyle {
    static let containerBackgroundColor: SKColor = .white
    static let containerBackgroundAlpha: CGFloat = 0.85
    static let containerCornerRadius: CGFloat = 12
    static let shadowColor: SKColor = .black
    static let shadowRadius: Float = 4.0
    static let shadowOpacity: Float = 0.2
    static let shadowOffset = CGPoint(x: 0, y: -2)
}

extension SKNode {
    func applyContainerStyle(size: CGSize) {
        // Crear y configurar sombra
        let shadowNode = SKEffectNode()
        shadowNode.filter = CIFilter(name: "CIGaussianBlur", parameters: ["inputRadius": CommonStyle.shadowRadius])
        shadowNode.shouldRasterize = true
        
        let shadowShape = SKShapeNode(rectOf: size, cornerRadius: CommonStyle.containerCornerRadius)
        shadowShape.fillColor = CommonStyle.shadowColor
        shadowShape.strokeColor = .clear
        shadowShape.alpha = CGFloat(CommonStyle.shadowOpacity)
        shadowShape.position = CommonStyle.shadowOffset
        shadowNode.addChild(shadowShape)
        
        // Crear y configurar contenedor principal
        let container = SKShapeNode(rectOf: size, cornerRadius: CommonStyle.containerCornerRadius)
        container.fillColor = CommonStyle.containerBackgroundColor
        container.strokeColor = .clear
        container.alpha = CommonStyle.containerBackgroundAlpha
        
        // Añadir nodos en orden correcto
        addChild(shadowNode)
        addChild(container)
    }
}
</file>

<file path="MusicBlocks/Preview Content/Preview Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="MusicBlocks/BackgroundPatternNode.swift">
//
//  BackgroundPatternNode.swift
//  MusicBlocks
//
//  Created by Jose R. García on 27/2/25.
//

import SpriteKit

class BackgroundPatternNode: SKNode {
    // MARK: - Properties
    let pastelColors: [UIColor]
    private let contrastColor: UIColor
    private let opacity: CGFloat
    private let colors: [UIColor] = []

    // Configuración de elementos
    private let numberOfWaves = 8
    private let numberOfLines = 12
    private let numberOfCircles = 6
    private let numberOfDiagonals = 15
    private let numberOfNotes = 10
    
    // Rangos para símbolos musicales
    private let notesSizeRange: ClosedRange<CGFloat> = 20...50
    private let notesRotationRange: ClosedRange<CGFloat> = -45...45
    
    private let musicImages = [
        "MusicalSymbol_01", "MusicalSymbol_02", "MusicalSymbol_03", "MusicalSymbol_04", "MusicalSymbol_05",
        "MusicalSymbol_06", "MusicalSymbol_07", "MusicalSymbol_08", "MusicalSymbol_09", "MusicalSymbol_10",
        "MusicalSymbol_11", "MusicalSymbol_12", "MusicalSymbol_13", "MusicalSymbol_14", "MusicalSymbol_15",
        "MusicalSymbol_16", "MusicalSymbol_17", "MusicalSymbol_18", "MusicalSymbol_19", "MusicalSymbol_20",
        "MusicalSymbol_21", "MusicalSymbol_22", "MusicalSymbol_23"
    ]
    
    // MARK: - Inicialización
    init(size: CGSize) {
        // Se generan dos colores pastel para el degradado
        self.pastelColors = Self.generatePastelColors()
        // Se calcula un color de contraste (por ejemplo, complementario del primero)
        self.contrastColor = Self.contrastingColor(for: pastelColors.first ?? .white)
        self.opacity = CGFloat.random(in: 0.1...0.2)
        super.init()
        
        // Se agrega el fondo degradado
        addGradientBackground(size: size, colors: pastelColors)
        
        // Se agregan las capas de formas y símbolos en color de contraste
        setupLayers(size: size)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implementado")
    }
    
    // MARK: - Métodos de Configuración
    private func addGradientBackground(size: CGSize, colors: [UIColor]) {
        let texture = gradientTexture(size: size, colors: colors)
        let backgroundNode = SKSpriteNode(texture: texture)
        
        // Forzamos anclaje en la esquina inferior izquierda
        backgroundNode.anchorPoint = CGPoint(x: 0, y: 0)
        
        // Así, position (0,0) en el padre coincide con la esquina inferior izqda.
        backgroundNode.position = .zero
        
        backgroundNode.size = size
        backgroundNode.zPosition = -1
        addChild(backgroundNode)
    }

    
    private func setupLayers(size: CGSize) {
        addWavesLayer(size: size)
        addLinesLayer(size: size)
        addCirclesLayer(size: size)
        addDiagonalBarsLayer(size: size)
        addNotesLayer(size: size)
    }
    
    // MARK: - Creación de Capas
    private func addWavesLayer(size: CGSize) {
        let path = CGMutablePath()
        
        for i in 0...numberOfWaves {
            let x = CGFloat(i) * size.width / CGFloat(numberOfWaves)
            path.move(to: CGPoint(x: x, y: 0))
            path.addCurve(
                to: CGPoint(x: x, y: size.height),
                control1: CGPoint(x: x + 60 * sin(CGFloat(i)), y: size.height * 0.3),
                control2: CGPoint(x: x - 60 * cos(CGFloat(i)), y: size.height * 0.7)
            )
        }
        
        let shapeNode = SKShapeNode(path: path)
        shapeNode.strokeColor = contrastColor
        shapeNode.lineWidth = 1.5
        shapeNode.alpha = opacity * 0.7
        addChild(shapeNode)
    }
    
    private func addLinesLayer(size: CGSize) {
        let path = CGMutablePath()
        
        for _ in 0..<numberOfLines {
            let start = CGPoint(
                x: .random(in: 0...size.width),
                y: .random(in: 0...size.height)
            )
            let end = CGPoint(
                x: .random(in: 0...size.width),
                y: .random(in: 0...size.height)
            )
            path.move(to: start)
            path.addLine(to: end)
        }
        
        let shapeNode = SKShapeNode(path: path)
        shapeNode.strokeColor = contrastColor
        shapeNode.lineWidth = 1.0
        shapeNode.alpha = opacity * 0.6
        addChild(shapeNode)
    }
    
    private func addCirclesLayer(size: CGSize) {
        for _ in 0..<numberOfCircles {
            let diameter = CGFloat.random(in: 40...180)
            let circle = SKShapeNode(circleOfRadius: diameter / 2)
            circle.position = CGPoint(
                x: .random(in: 0...size.width),
                y: .random(in: 0...size.height)
            )
            circle.strokeColor = contrastColor
            circle.lineWidth = 1.5
            circle.alpha = opacity * 0.5
            addChild(circle)
        }
    }
    
    private func addDiagonalBarsLayer(size: CGSize) {
        let path = CGMutablePath()
        let spacing: CGFloat = 50
        let rotationAngle: CGFloat = .pi / 4
        
        for x in stride(from: -size.width, through: size.width * 2, by: spacing) {
            let transform = CGAffineTransform(rotationAngle: rotationAngle)
            let start = CGPoint(x: x, y: 0).applying(transform)
            let end = CGPoint(x: x, y: size.height).applying(transform)
            
            path.move(to: start)
            path.addLine(to: end)
        }
        
        let shapeNode = SKShapeNode(path: path)
        shapeNode.strokeColor = contrastColor
        shapeNode.lineWidth = 1.0
        shapeNode.alpha = opacity * 0.4
        addChild(shapeNode)
    }
    
    private func addNotesLayer(size: CGSize) {
        for _ in 0..<numberOfNotes {
            guard let imageName = musicImages.randomElement() else { continue }
            
            let noteSize = CGFloat.random(in: notesSizeRange)
            let texture = SKTexture(imageNamed: imageName)
            let noteNode = SKSpriteNode(texture: texture)
            
            noteNode.size = CGSize(width: noteSize, height: noteSize)
            noteNode.position = CGPoint(
                x: .random(in: 0...size.width),
                y: .random(in: 0...size.height)
            )
            noteNode.zRotation = CGFloat.random(in: notesRotationRange) * .pi / 180
            noteNode.alpha = opacity * 0.8
            noteNode.color = contrastColor
            noteNode.colorBlendFactor = 1.0
            
            addChild(noteNode)
        }
    }
    
    // MARK: - Métodos Auxiliares
    
    private static func generatePastelColors() -> [UIColor] {
        let baseHues = [
            CGFloat.random(in: 0...1),
            CGFloat.random(in: 0...1)
        ]
        
        return baseHues.map { hue in
            UIColor(
                hue: hue,
                saturation: CGFloat.random(in: 0.3...0.4),
                brightness: CGFloat.random(in: 0.9...1.0),
                alpha: 1.0
            )
        }
    }
    
    private static func contrastingColor(for color: UIColor) -> UIColor {
        var hue: CGFloat = 0, saturation: CGFloat = 0, brightness: CGFloat = 0, alpha: CGFloat = 0
        if color.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: &alpha) {
            // Se calcula el color complementario
            let complementaryHue = (hue + 0.5).truncatingRemainder(dividingBy: 1.0)
            return UIColor(
                hue: complementaryHue,
                saturation: max(saturation, 0.7),
                brightness: max(brightness - 0.5, 0.3),
                alpha: 1.0
            )
        }
        return .black
    }
    
    private func gradientTexture(size: CGSize, colors: [UIColor]) -> SKTexture {
        let gradientLayer = CAGradientLayer()
        gradientLayer.frame = CGRect(origin: .zero, size: size)
        gradientLayer.colors = colors.map { $0.cgColor }
        gradientLayer.startPoint = CGPoint(x: 0, y: 0)
        gradientLayer.endPoint = CGPoint(x: 1, y: 1)
        
        UIGraphicsBeginImageContext(gradientLayer.frame.size)
        guard let context = UIGraphicsGetCurrentContext() else {
            return SKTexture()
        }
        gradientLayer.render(in: context)
        let image = UIGraphicsGetImageFromCurrentImageContext() ?? UIImage()
        UIGraphicsEndImageContext()
        return SKTexture(image: image)
    }
}

#if DEBUG
import SwiftUI
import SpriteKit

struct BackgroundPatternNodePreview: UIViewRepresentable {
    let sceneSize: CGSize
    func makeUIView(context: Context) -> SKView {
        // Se crea una SKView con el tamaño de la preview
        let skView = SKView(frame: CGRect(origin: .zero, size: sceneSize))
        
        // Se configura la escena para que se redimensione automáticamente
        let scene = SKScene(size: sceneSize)
        scene.scaleMode = .resizeFill
        scene.backgroundColor = .white
        
        // Se crea y posiciona el BackgroundPatternNode
        let patternNode = BackgroundPatternNode(size: sceneSize)
        patternNode.position = CGPoint(x: sceneSize.width / 2, y: sceneSize.height / 2)
        scene.addChild(patternNode)
        
        skView.presentScene(scene)
        return skView
    }
    
    func updateUIView(_ uiView: SKView, context: Context) {
        // Se actualiza el tamaño de la escena para ocupar todo el espacio de la SKView
        if let scene = uiView.scene {
            scene.size = uiView.bounds.size
        }
    }
}

struct BackgroundPatternNode_Previews: PreviewProvider {
    static var previews: some View {
        GeometryReader { geometry in
            BackgroundPatternNodePreview(sceneSize: geometry.size)
        }
        .ignoresSafeArea()
        .previewDevice("iPhone 16 Pro")
    }
}

#endif
</file>

<file path="MusicBlocks/game_levels.json">
{
    /*
    Configuración principal del juego MusicBlocks
    Última actualización: 29-02-2025
    */
    "game_version": "0.7",
    /*
    Tipos de objetivos soportados:
    score: Alcanzar una puntuación específica en un tiempo límite
    total_notes: Acertar un número de notas específico
    note_accuracy: Acertar un número determinado de notas con cierta precisión de afinación
    block_destruction: Destruir un número específico de bloques de ciertos tipos
    total_blocks: Destruir un número total de bloques sin importar el tipo
    */
    "objective_types": {
        // El tipo de objetivo score, total_notes, note_accuracy, block_destruction, total_blocks
        "score": {
            "type": "score",
            "description": "Alcanzar una puntuación específica en un tiempo límite",
            "params": {
                "target": 100, // La puntuación a alcanzar
                "time_limit": 180 // Límite de tiempo (0 para sin límite)
            }
        },
        "total_notes": {
            "type": "total_notes",
            "description": "Acertar un número de notas específico",
            "params": {
                "target": 50, // El número de notas a acertar
                "time_limit": 90 // Límite de tiempo (0 para sin límite)
            }
        },
        "note_accuracy": {
            "type": "note_accuracy",
            "description": "Acertar un número de notas con cierta precisión",
            "params": {
                "target": 10, // El número de notas a acertar
                "minimum_accuracy": 0.8, // Precisión mínima requerida
                "time_limit": 90 // Límite de tiempo (0 para sin límite)
            }
        },
        "block_destruction": {
            "type": "block_destruction",
            "description": "Destruir bloques específicos",
            "params": {
                "details": {
                    "ghostBlock": 2, // El tipo de bloque y el número de bloques a acertar
                    "hardIceBlock": 3,
                    "defaultBlock": 6
                },
                "time_limit": 90, // Límite de tiempo (0 para sin límite)
            }
        },
        "total_blocks": {
            "type": "total_blocks",
            "description": "Destruir un número total de bloques",
            "params": {
                "target": 15, // El número de bloques a destruir
                "time_limit": 240 // Límite de tiempo (0 para sin límite)
            }
        }
    },
    "accuracy_thresholds": {
        "perfect": {
            "threshold": 0.95,
            "multiplier": 2.0
        },
        "excellent": {
            "threshold": 0.80,
            "multiplier": 1.5
        },
        "good": {
            "threshold": 0.60,
            "multiplier": 1.0
        }
    },
    "levels": [
        {
            "level_id": 0,
            "name": "Tutorial",
            "max_score": 500,
            "allowed_styles": ["defaultBlock"], // Estilos de bloque en el nivel
            "falling_speed": {
                "initial": 8.0,  // Velocidad de caida inicial 8.0 segundos
                "increment": 0.0 // Incremento de velocidad de caida. Quitar 0.0 segundos en cada bloque
            },
            "lives": {
                "initial": 3,  // Número de vidas al inicio del nivel
                "extra_lives": {
                    "score_thresholds": [500, 1000],  // Puntuaciones necesarias para ganar vidas extra
                    "max_extra": 1  // Máximo de vidas extra en el nivel
                }
            },
            "objectives": {
                "primary": {
                    "type": "score",
                    "target": 100,
                    "time_limit": 180
                }
            },
            "blocks": {
                "defaultBlock": {
                    "notes": [      // Notas disponibles del bloque
                        "SOL4",
                        "LA4",
                        "SI4"
                    ],
                    "requiredHits": 1, // Aciertos necesarios para destruir bloque
                    "requiredTime": 0.8, // Tiempo necesarios aguantando la nota para destruir bloque
                    "style": "default",  // Nombre del estilo del bloque
                    "weight": 1, // Peso para probabilidad en generarse el bloque
                    "base_points": 5  // Puntos base al destruirlo
                }
            }
        },
        {
            "level_id": 1,
            "name": "¡Comienza la aventura!",
            "max_score": 600,
            "allowed_styles": ["defaultBlock", "iceBlock"],
            "falling_speed": {
                "initial": 7.0,  // Velocidad de caida inicial
                "increment": 0.1 // Incremento de velocidad de caida
            },
            "lives": {
                "initial": 3,  // Número de vidas al inicio del nivel
                "extra_lives": {
                    "score_thresholds": [500, 1000],  // Puntuaciones necesarias para ganar vidas extra
                    "max_extra": 2  // Máximo de vidas extra en el nivel
                }
            },
            "objectives": {
                "primary": {
                    "type": "note_accuracy",
                    "target": 10,  // número de notas a acertar
                    "minimum_accuracy": 0.8,  // 80% de precisión mínima
                    "time_limit": 0  // 0 significa sin límite de tiempo
                }

            },
            "blocks": {
                "defaultBlock": {
                    "notes": [
                        "SOL4",
                        "LA4",
                        "SI4"
                    ],
                    "requiredHits": 1,
                    "requiredTime": 0.8,
                    "style": "defaultBlock",
                    "weight": 0.8,
                    "base_points": 5
                },
                "iceBlock": {
                    "notes": [
                        "FA#4",
                        "DO5"
                    ],
                    "requiredHits": 2,
                    "requiredTime": 1.2,
                    "style": "iceBlock",
                    "weight": 0.2,
                    "base_points": 10
                }
            }
        },
        {
            "level_id": 2,
            "name": "Más bloques...!",
            "max_score": 700,
            "allowed_styles": ["defaultBlock", "hardIceBlock", "ghostBlock"],
            "falling_speed": {
                "initial": 6.0,  // Velocidad de caida inicial
                "increment": 0.2 // Incremento de velocidad de caida
            },
            "lives": {
                "initial": 3,  // Número de vidas al inicio del nivel
                "extra_lives": {
                    "score_thresholds": [500, 1000],  // Puntuaciones necesarias para ganar vidas extra
                    "max_extra": 2  // Máximo de vidas extra en el nivel
                }
            },
            "objectives": {
                "primary": { // El objetivo principal que debe cumplirse para completar el nivel
                    "type": "total_blocks",
                    "target": 15,  // destruir 15 bloques en total
                    "time_limit": 240
                }
            },
            "blocks": {
                "defaultBlock": {
                    "notes": [
                        "SOL4",
                        "LA4",
                        "SI4"
                    ],
                    "requiredHits": 1,
                    "requiredTime": 0.8,
                    "style": "defaultBlock",
                    "weight": 0.4,
                    "base_points": 10
                },
                "hardIceBlock": {
                    "notes": [
                        "DO6",
                        "LA5",
                        "SI5"
                    ],
                    "requiredHits": 3,
                    "requiredTime": 1.6,
                    "style": "hardIceBlock",
                    "weight": 0.3,
                    "base_points": 20
                },
                "ghostBlock": {
                    "notes": [
                        "SOL5",
                        "FA5",
                        "MI4"
                    ],
                    "requiredHits": 1,
                    "requiredTime": 1,
                    "style": "ghostBlock",
                    "weight": 0.3,
                    "base_points": 25
                }
            }
        }
    ],
    "medals": {
        "notes_hit": [
            {
                "name": "Aprendiz del Pentagrama",
                "requirement": "50 notas acertadas",
                "image": "Badge-azul-1",
                "objective": {
                    "type": "notes_hit",
                    "target": 50,
                    "lifetime": true
                }
            },
            {
                "name": "Intérprete Prometedor",
                "requirement": "250 notas acertadas",
                "image": "Badge-azul-2",
                "objective": {
                    "type": "notes_hit",
                    "target": 250,
                    "lifetime": true
                }
            },
            {
                "name": "Virtuoso del Ritmo",
                "requirement": "500 notas acertadas",
                "image": "Badge-azul-3",
                "objective": {
                    "type": "notes_hit",
                    "target": 500,
                    "lifetime": true
                }
            },
            {
                "name": "Maestro Melódico",
                "requirement": "1000 notas acertadas",
                "image": "Badge-azul-4",
                "objective": {
                    "type": "notes_hit",
                    "target": 1000,
                    "lifetime": true
                }
            },
            {
                "name": "Leyenda Musical",
                "requirement": "5000 notas acertadas",
                "image": "Badge-azul-5",
                "objective": {
                    "type": "notes_hit",
                    "target": 5000,
                    "lifetime": true
                }
            }
        ],
        "play_time": [
            {
                "name": "Toca y Aprende",
                "requirement": "30 minutos jugados",
                "image": "Badge-rojo-1",
                "objective": {
                    "type": "play_time",
                    "target": 1800,  // 30 minutos en segundos
                    "lifetime": true
                }
            },
            {
                "name": "Sesión de Ensayo",
                "requirement": "2 horas jugadas",
                "image": "Badge-rojo-2",
                "objective": {
                    "type": "play_time",
                    "target": 7200,  // 2 horas en segundos
                    "lifetime": true
                }
            },
            {
                "name": "Músico Apasionado",
                "requirement": "10 horas jugadas",
                "image": "Badge-rojo-3",
                "objective": {
                    "type": "play_time",
                    "target": 36000,  // 10 horas en segundos
                    "lifetime": true
                }
            },
            {
                "name": "Compositor Dedicado",
                "requirement": "25 horas jugadas",
                "image": "Badge-rojo-4",
                "objective": {
                    "type": "play_time",
                    "target": 90000,  // 25 horas en segundos
                    "lifetime": true
                }
            },
            {
                "name": "Eterno Virtuoso",
                "requirement": "50 horas jugadas",
                "image": "Badge-rojo-5",
                "objective": {
                    "type": "play_time",
                    "target": 180000,  // 50 horas en segundos
                    "lifetime": true
                }
            }
        ],
        "streaks": [
            {
                "name": "Afinado",
                "requirement": "10 notas seguidas sin errores",
                "image": "Badge-oro-1",
                "objective": {
                    "type": "streak",
                    "target": 10,
                    "reset_on_fail": true
                }
            },
            {
                "name": "Cuerda Perfecta",
                "requirement": "50 notas seguidas sin errores",
                "image": "Badge-oro-2",
                "objective": {
                    "type": "streak",
                    "target": 50,
                    "reset_on_fail": true
                }
            },
            {
                "name": "Ejecutante de Concierto",
                "requirement": "100 notas seguidas sin errores",
                "image": "Badge-oro-3",
                "objective": {
                    "type": "streak",
                    "target": 100,
                    "reset_on_fail": true
                }
            },
            {
                "name": "Prodigio Preciso",
                "requirement": "250 notas seguidas sin errores",
                "image": "Badge-oro-4",
                "objective": {
                    "type": "streak",
                    "target": 250,
                    "reset_on_fail": true
                }
            },
            {
                "name": "Músico Impecable",
                "requirement": "500 notas seguidas sin errores",
                "image": "Badge-oro-5",
                "objective": {
                    "type": "streak",
                    "target": 500,
                    "reset_on_fail": true
                }
            }
        ],
        "perfect_tuning": [
            {
                "name": "Afinación Perfecta",
                "requirement": "Completa un nivel con 100% de precisión",
                "image": "Badge-multi-1",
                "objective": {
                    "type": "perfect_tuning",
                    "target": 1,
                    "accuracy": 1.0,
                    "lifetime": true
                }
            },
            {
                "name": "Maestro de la Afinación",
                "requirement": "Completa 5 niveles con 100% de precisión",
                "image": "Badge-multi-2",
                "objective": {
                    "type": "perfect_tuning",
                    "target": 5,
                    "accuracy": 1.0,
                    "lifetime": true
                }
            },
            {
                "name": "Ejecutor Infalible",
                "requirement": "Completa 10 niveles con 100% de precisión",
                "image": "Badge-multi-3",
                "objective": {
                    "type": "perfect_tuning",
                    "target": 10,
                    "accuracy": 1.0,
                    "lifetime": true
                }
            },
            {
                "name": "Perfección Sonora",
                "requirement": "Completa 25 niveles con 100% de precisión",
                "image": "Badge-multi-4",
                "objective": {
                    "type": "perfect_tuning",
                    "target": 25,
                    "accuracy": 1.0,
                    "lifetime": true
                }
            },
            {
                "name": "Leyenda de la Precisión",
                "requirement": "Completa 50 niveles con 100% de precisión",
                "image": "Badge-multi-5",
                "objective": {
                    "type": "perfect_tuning",
                    "target": 50,
                    "accuracy": 1.0,
                    "lifetime": true
                }
            }
        ]
    }
}
</file>

<file path="MusicBlocks/GameEngine.swift">
//
//  GameEngine.swift
//  MusicBlocks
//
//  Created by Jose R. García on 13/3/25.
//

import Foundation
import SpriteKit

class GameEngine: ObservableObject {
    // MARK: - Published Properties
    @Published var score: Int = 0
    @Published var lives: Int = 0
    @Published var gameState: GameState = .countdown
    @Published var noteState: NoteState = .waiting
    @Published var combo: Int = 0
    
    // MARK: - Private Properties
    private let tunerEngine: TunerEngine
    private let gameManager = GameManager.shared
    private weak var blockManager: BlocksManager?
    var objectiveTracker: LevelObjectiveTracker?
    
    // Configuración del nivel
    private var maxExtraLives: Int = 0
    private var scoreThresholdsForExtraLives: [Int] = []
    
    // Constantes de tiempo
    private struct TimeConstants {
        static let errorDisplayTime: TimeInterval = 2.0
        static let silenceThreshold: TimeInterval = 0.3
        static let minimalNoteDetectionTime: TimeInterval = 0.5
        static let acceptableDeviation: Double = 10.0
    }
    
    // Estado del juego
    private var isShowingError: Bool = false
    private var isInSuccessState: Bool = false
    
    // Métricas de partidas
    private var gamesWon: Int = 0
    private var gamesLost: Int = 0
    
    // Métricas de la partida actual
    private var gameStartTime: Date?
    private var notesHitInGame: Int = 0
    private var bestStreakInGame: Int = 0
    private var totalAccuracyInGame: Double = 0.0
    private var accuracyMeasurements: Int = 0
    
    // Seguimiento de bloques por estilo en el nivel actual
    private var blockHitsByStyle: [String: Int] = [:]
    
    // MARK: - Initialization
    /// Inicializa el GameEngine con el TunerEngine y el BlocksManager (que puede ser nil)
    init(tunerEngine: TunerEngine = .shared, blockManager: BlocksManager?) {
        self.tunerEngine = tunerEngine
        self.blockManager = blockManager
        gameState = .countdown
        print("GameEngine inicializado. Estado inicial: \(gameState)")
    }
    
    // MARK: - Game Control
    /// Inicia una nueva partida, reseteando todas las métricas y configurando el nivel actual.
    func startNewGame() {
        guard let currentLevel = gameManager.currentLevel else {
            print("No se pudo iniciar el juego: no hay nivel actual")
            return
        }
        
        print("Iniciando nueva partida para el nivel \(currentLevel.levelId)")
        resetGameState()
        
        // Reiniciar contadores por estilo de bloque
        blockHitsByStyle.removeAll()
        for style in currentLevel.allowedStyles {
            blockHitsByStyle[style] = 0
        }
        
        // Inicializar métricas de partida
        gameStartTime = Date()
        notesHitInGame = 0
        bestStreakInGame = 0
        totalAccuracyInGame = 0.0
        accuracyMeasurements = 0
        
        // Crear tracker para objetivos
        objectiveTracker = LevelObjectiveTracker(level: currentLevel)
        
        // Configurar vidas y puntuación
            lives = currentLevel.lives.initial
            maxExtraLives = currentLevel.lives.extraLives.maxExtra
            scoreThresholdsForExtraLives = currentLevel.lives.extraLives.scoreThresholds
            
            // Añadir notificación para actualizar la UI con los valores iniciales
            NotificationCenter.default.post(
                name: NSNotification.Name("GameDataUpdated"),
                object: nil,
                userInfo: [
                    "score": score,
                    "lives": lives,
                    "resetObjectives": true // Flag para indicar reinicio completo
                ]
            )
        
        // Iniciar generación de bloques
        blockManager?.startBlockGeneration()
        
        // Cambiar estado del juego a 'playing'
        gameState = .playing
        
        print("🎮 Nuevo juego iniciado - Nivel: \(currentLevel.levelId)")
    }
    
    /// Pausa la partida actual.
    func pauseGame() {
        guard case .playing = gameState else { return }
        gameState = .paused
        blockManager?.stopBlockGeneration()
        print("Juego pausado")
    }
    
    /// Reanuda la partida pausada.
    func resumeGame() {
        guard case .paused = gameState else { return }
        gameState = .playing
        blockManager?.startBlockGeneration()
        print("Juego reanudado")
    }
    
    /// Finaliza la partida, calcula estadísticas y actualiza el perfil del usuario.
    func endGame(reason: GameOverReason) {
        gameState = .gameOver(reason: reason)
        blockManager?.stopBlockGeneration()
        
        // Actualización final de la UI antes de terminar
           NotificationCenter.default.post(
               name: NSNotification.Name("GameDataUpdated"),
               object: nil,
               userInfo: [
                   "score": score,
                   "lives": lives,
                   "gameOver": true,
                   "reason": reason.rawValue
               ]
           )
        
        let playTime = gameStartTime.map { Date().timeIntervalSince($0) } ?? 0
        let averageAccuracy = accuracyMeasurements > 0 ? totalAccuracyInGame / Double(accuracyMeasurements) : 0.0
        let requiredScore = gameManager.currentLevel?.requiredScore ?? 0
        let isGameWon = reason != .blocksOverflow && score >= requiredScore
        
        if isGameWon {
            gamesWon += 1
        } else {
            gamesLost += 1
        }
        
        let userProfile = UserProfile.load()
        var updatedProfile = userProfile
        updatedProfile.updateStatistics(
            score: score,
            noteHit: false,
            accuracy: averageAccuracy,
            levelCompleted: isGameWon,
            isPerfect: averageAccuracy >= 0.95,
            playTime: playTime,
            gamesWon: gamesWon,
            gamesLost: gamesLost
        )
        
        print("📊 Estadísticas finales:")
        print("Tiempo jugado: \(Int(playTime))s, Notas acertadas: \(notesHitInGame), Mejor racha: \(bestStreakInGame), Precisión: \(Int(averageAccuracy * 100))%")
        print("Estado: \(isGameWon ? "Victoria" : "Derrota")")
        print("Total partidas - Ganadas: \(gamesWon), Perdidas: \(gamesLost)")
        
        let totalBlocksAcertados = blockHitsByStyle.values.reduce(0, +)
        print("Bloques acertados: \(totalBlocksAcertados)")
        for (style, count) in blockHitsByStyle {
            print("• \(style): \(count)")
        }
        
        resetGameState()
    }
    
    // MARK: - Note Processing
    /// Compara la nota detectada con el objetivo y delega el manejo correcto o incorrecto.
    func checkNote(currentNote: String, deviation: Double, isActive: Bool) {
        guard case .playing = gameState, !isInSuccessState, !isShowingError else {
            return
        }
        
        guard let currentBlock = blockManager?.getCurrentBlock(), isActive else {
            print("No se procesará nota: no hay bloque activo o no está activa")
            return
        }
        
        print("🎯 Comparando nota detectada (\(currentNote)) con objetivo (\(currentBlock.note)), desviación: \(deviation)")
        
        if currentNote == currentBlock.note {
            handleCorrectNote(deviation: deviation, block: currentBlock)
        } else {
            handleWrongNote()
        }
    }
    
    // MARK: - Note Handling
    /// Maneja la nota correcta: actualiza el progreso del bloque y, si se cumplen los requisitos, registra el éxito.
    private func handleCorrectNote(deviation: Double, block: BlockInfo) {
        if blockManager?.updateCurrentBlockProgress(hitTime: Date()) == true {
            handleSuccess(deviation: deviation, blockConfig: block.config)
        } else {
            noteState = .correct(deviation: deviation)
        }
        combo += 1
    }
    
    /// Maneja el caso de nota incorrecta: reduce vidas y reinicia el progreso del bloque.
    private func handleWrongNote() {
        guard !isShowingError else { return }
        isShowingError = true
        lives -= 1
        combo = 0
        noteState = .wrong
        blockManager?.resetCurrentBlockProgress()
        
        // Añadir notificación para actualizar la UI inmediatamente
        NotificationCenter.default.post(
            name: NSNotification.Name("GameDataUpdated"),
            object: nil,
            userInfo: ["lives": lives, "combo": combo]
        )
        
        if lives <= 0 {
            endGame(reason: .noLives)
            return
        }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + TimeConstants.errorDisplayTime) { [weak self] in
            self?.isShowingError = false
            self?.noteState = .waiting
        }
    }
    
    /// Maneja el éxito al completar el bloque: actualiza estadísticas, suma puntos y verifica objetivos.
    private func handleSuccess(deviation: Double, blockConfig: Block) {
        isInSuccessState = true
        
        if let currentBlock = blockManager?.getCurrentBlock() {
            blockHitsByStyle[currentBlock.style] = (blockHitsByStyle[currentBlock.style] ?? 0) + 1
            print("📊 Bloques acertados actualizados:")
            for (style, count) in blockHitsByStyle {
                print("• \(style): \(count)")
            }
        }
        
        let accuracy = calculateAccuracy(deviation: deviation)
        let (baseScore, message) = calculateScore(accuracy: accuracy, blockConfig: blockConfig)
        let comboBonus = calculateComboBonus(baseScore: baseScore)
        let finalScore = baseScore + comboBonus
        score += finalScore
        
        checkForExtraLife(currentScore: score)
        
        // Obtener el estilo del bloque actual
        let blockStyle = blockManager?.getCurrentBlock()?.style ?? "defaultBlock"
        
        // Actualizar TODOS los datos relevantes para CUALQUIER tipo de objetivo
            objectiveTracker?.updateProgress(
                score: score,             // Para objetivos tipo "score"
                noteHit: true,            // Para objetivos tipo "total_notes"
                accuracy: accuracy,       // Para objetivos tipo "note_accuracy"
                blockDestroyed: blockStyle // Para objetivos tipo "block_destruction" y "total_blocks"
            )
            
            // Enviar notificación con TODOS los datos relevantes
        // Enviar notificación después de actualizar el tracker
        NotificationCenter.default.post(
            name: NSNotification.Name("GameDataUpdated"),
            object: nil,
            userInfo: [
                "lives": lives,
                "combo": combo,
                "noteState": "wrong"
            ]
        )
        
        if let primaryComplete = objectiveTracker?.checkObjectives(), primaryComplete {
            endGame(reason: .victory)
        }
        
        noteState = .success(
            multiplier: finalScore / blockConfig.basePoints,
            message: "\(message) (\(combo)x Combo!)"
        )
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
            self?.isInSuccessState = false
            self?.noteState = .waiting
        }
    }
    
    // MARK: - Score Calculation
    /// Calcula la precisión a partir de la desviación.
    private func calculateAccuracy(deviation: Double) -> Double {
        let absDeviation = abs(deviation)
        if absDeviation > TimeConstants.acceptableDeviation { return 0.0 }
        return 1.0 - (absDeviation / TimeConstants.acceptableDeviation)
    }
    
    /// Calcula la puntuación base y un mensaje en función de la precisión.
    private func calculateScore(accuracy: Double, blockConfig: Block) -> (score: Int, message: String) {
        guard let thresholds = gameManager.gameConfig?.accuracyThresholds else {
            return (blockConfig.basePoints, "¡Bien!")
        }
        
        if accuracy >= thresholds.perfect.threshold {
            return (Int(Double(blockConfig.basePoints) * thresholds.perfect.multiplier), "¡Perfecto!")
        } else if accuracy >= thresholds.excellent.threshold {
            return (Int(Double(blockConfig.basePoints) * thresholds.excellent.multiplier), "¡Excelente!")
        } else if accuracy >= thresholds.good.threshold {
            return (Int(Double(blockConfig.basePoints) * thresholds.good.multiplier), "¡Bien!")
        }
        
        return (0, "Fallo")
    }
    
    /// Calcula el bono por combo.
    private func calculateComboBonus(baseScore: Int) -> Int {
        let comboMultiplier = min(combo, 10)
        return baseScore * (comboMultiplier - 1) / 2
    }
    
    // MARK: - Lives Management
    /// Verifica y concede vidas extra si se alcanza el umbral de puntuación.
    private func checkForExtraLife(currentScore: Int) {
        for threshold in scoreThresholdsForExtraLives {
            if currentScore >= threshold && lives < (gameManager.currentLevel?.lives.initial ?? 3) + maxExtraLives {
                lives += 1
                print("🎉 Vida extra ganada. Vidas actuales: \(lives)")
                
                // Añadir notificación para actualizar la UI inmediatamente
                NotificationCenter.default.post(
                    name: NSNotification.Name("GameDataUpdated"),
                    object: nil,
                    userInfo: ["lives": lives]
                )
                
                if let index = scoreThresholdsForExtraLives.firstIndex(of: threshold) {
                    scoreThresholdsForExtraLives.remove(at: index)
                }
                break
            }
        }
    }
    
    // MARK: - State Management
    /// Resetea todas las métricas y estados de la partida.
    private func resetGameState() {
        score = 0
        combo = 0
        isShowingError = false
        isInSuccessState = false
        noteState = .waiting
        gameStartTime = nil
        notesHitInGame = 0
        bestStreakInGame = 0
        totalAccuracyInGame = 0.0
        accuracyMeasurements = 0
        blockHitsByStyle.removeAll()
        print("🔄 Estado del juego reseteado.")
    }
    
    // MARK: - Block Monitoring
    /// Comprueba si algún bloque ha alcanzado la zona límite (danger zone).
    func checkBlocksPosition() {
        if blockManager?.hasBlocksBelowLimit() == true {
            print("🔥 Game Over: Bloques han alcanzado la zona de peligro.")
            endGame(reason: .blocksOverflow)
        }
    }
    
    /// Retorna el progreso del objetivo actual.
    func getLevelProgress() -> Double {
        return objectiveTracker?.getProgress() ?? 0
    }
    
    /// Devuelve el resumen de bloques acertados por estilo.
    func getBlockHitsByStyle() -> [String: Int] {
        return blockHitsByStyle
    }
}

// MARK: - AudioControllerDelegate
extension GameEngine: AudioControllerDelegate {
    /// Recibe la nota detectada y la procesa.
    func audioController(_ controller: AudioController, didDetectNote note: String, frequency: Float, amplitude: Float, deviation: Double) {
        print("AudioControllerDelegate - Nota detectada: \(note), Frecuencia: \(frequency)")
        self.checkNote(currentNote: note, deviation: deviation, isActive: true)
    }
    
    /// Se invoca cuando se detecta silencio.
    func audioControllerDidDetectSilence(_ controller: AudioController) {
        print("AudioControllerDelegate - Silencio detectado.")
        self.checkNote(currentNote: "-", deviation: 0, isActive: false)
    }
    
    /// Devuelve el tiempo requerido para mantener la nota, consultando el bloque actual.
    func audioControllerRequiredHoldTime(_ controller: AudioController) -> TimeInterval {
        if let currentBlock = blockManager?.getCurrentBlock() {
            print("AudioControllerDelegate - Required hold time para el bloque actual: \(currentBlock.config.requiredTime) segundos")
            return currentBlock.config.requiredTime
        }
        print("AudioControllerDelegate - No hay bloque activo, se retorna 1.0 segundo por defecto")
        return 1.0
    }
}
</file>

<file path="MusicBlocks/GameLevelProcessor.swift">
//
//  GameLevelProcessor.swift
//  MusicBlocks
//
//  Created by Jose R. García on 28/2/25.
//

import Foundation

// Estructuras para almacenar la configuración del juego
struct GameConfig: Codable {
    let gameVersion: String
    let objectiveTypes: ObjectiveTypes
    let accuracyThresholds: AccuracyThresholds
    let levels: [GameLevel]
    let medals: Medals
    
    enum CodingKeys: String, CodingKey {
        case gameVersion = "game_version"
        case objectiveTypes = "objective_types"
        case accuracyThresholds = "accuracy_thresholds"
        case levels
        case medals
    }
}

struct ObjectiveTypes: Codable {
    let score: ObjectiveTypeDefinition
    let totalNotes: ObjectiveTypeDefinition
    let noteAccuracy: ObjectiveTypeDefinition
    let blockDestruction: ObjectiveTypeDefinition
    let totalBlocks: ObjectiveTypeDefinition
    
    enum CodingKeys: String, CodingKey {
        case score
        case totalNotes = "total_notes"
        case noteAccuracy = "note_accuracy"
        case blockDestruction = "block_destruction"
        case totalBlocks = "total_blocks"
    }
}

struct ObjectiveTypeDefinition: Codable {
    let type: String?
    let description: String
    let params: ObjectiveParams
}

struct ObjectiveParams: Codable {
    let target: Int?
    let timeLimit: Int?
    let minimumAccuracy: Double?
    let details: [String: Int]?
    
    enum CodingKeys: String, CodingKey {
        case target
        case timeLimit = "time_limit"
        case minimumAccuracy = "minimum_accuracy"
        case details
    }
}

struct AccuracyThresholds: Codable {
    let perfect: AccuracyLevel
    let excellent: AccuracyLevel
    let good: AccuracyLevel
}

struct AccuracyLevel: Codable {
    let threshold: Double
    let multiplier: Double
}

struct GameLevel: Codable {
    let levelId: Int
    let name: String
    let maxScore: Int
    let allowedStyles: [String]
    let fallingSpeed: FallingSpeed
    let lives: Lives
    let objectives: Objectives
    let blocks: [String: Block]
    
    var requiredScore: Int {
            // Si el objetivo primario es de tipo "score", usar ese valor
            if objectives.primary.type == "score" {
                return objectives.primary.target ?? 0
            }
            // Si no, usar un valor por defecto basado en los bloques
            return blocks.values.reduce(0) { $0 + ($1.basePoints * 10) }
        }
    
    enum CodingKeys: String, CodingKey {
        case levelId = "level_id"
        case name
        case maxScore = "max_score"
        case allowedStyles = "allowed_styles"
        case fallingSpeed = "falling_speed"
        case lives
        case objectives
        case blocks
    }
}

struct FallingSpeed: Codable {
    let initial: Double
    let increment: Double
}

struct Lives: Codable {
    let initial: Int
    let extraLives: ExtraLives
    
    enum CodingKeys: String, CodingKey {
        case initial
        case extraLives = "extra_lives"
    }
}

struct ExtraLives: Codable {
    let scoreThresholds: [Int]
    let maxExtra: Int
    
    enum CodingKeys: String, CodingKey {
        case scoreThresholds = "score_thresholds"
        case maxExtra = "max_extra"
    }
}

struct Objectives: Codable {
    let primary: Objective
}

struct Objective: Codable {
    let type: String
    let target: Int?
    let timeLimit: Int?
    let minimumAccuracy: Double?
    let details: [String: Int]?
    
    enum CodingKeys: String, CodingKey {
        case type
        case target
        case timeLimit = "time_limit"
        case minimumAccuracy = "minimum_accuracy"
        case details
    }
}

struct Block: Codable {
    let notes: [String]
    let requiredHits: Int
    let requiredTime: Double
    let style: String
    let weight: Double
    let basePoints: Int
    
    enum CodingKeys: String, CodingKey {
        case notes
        case requiredHits
        case requiredTime
        case style
        case weight
        case basePoints = "base_points"
    }
}

struct Medals: Codable {
    let notesHit: [Medal]
    let playTime: [Medal]
    let streaks: [Medal]
    let perfectTuning: [Medal]
    
    enum CodingKeys: String, CodingKey {
        case notesHit = "notes_hit"
        case playTime = "play_time"
        case streaks
        case perfectTuning = "perfect_tuning" 
    }
}

struct Medal: Codable {
    let name: String
    let requirement: String
    let image: String
    let objective: MedalObjective
}

struct MedalObjective: Codable {
    let type: String
    let target: Int
    let lifetime: Bool?
    let resetOnFail: Bool?
    let accuracy: Double?
    
    enum CodingKeys: String, CodingKey {
        case type
        case target
        case lifetime
        case resetOnFail = "reset_on_fail"
        case accuracy
    }
}

class GameLevelProcessor {
    
    /// Procesa el JSON que contiene comentarios y convierte los datos para su uso en la app
    /// - Parameter jsonString: String con el JSON que puede contener comentarios
    /// - Returns: Objeto GameConfig con la configuración del juego o nil si hay error
    static func processGameLevelsJSON(_ jsonString: String) -> GameConfig? {
        // Paso 1: Eliminar los comentarios multilinea /* ... */
        var cleanedJSON = removeMultilineComments(from: jsonString)
        
        // Paso 2: Eliminar los comentarios de una sola línea // ...
        cleanedJSON = removeSingleLineComments(from: cleanedJSON)
        
        // Paso 3: Parsear el JSON limpio
        if let jsonData = cleanedJSON.data(using: .utf8) {
            do {
                let decoder = JSONDecoder()
                let gameConfig = try decoder.decode(GameConfig.self, from: jsonData)
                return gameConfig
            } catch {
                print("Error decoding JSON: \(error)")
                print("Problema en: \(error.localizedDescription)")
                if let decodingError = error as? DecodingError {
                    switch decodingError {
                    case .dataCorrupted(let context):
                        print("Data corrupted: \(context)")
                    case .keyNotFound(let key, let context):
                        print("Key not found: \(key) in \(context)")
                    case .typeMismatch(let type, let context):
                        print("Type mismatch: \(type) in \(context)")
                    case .valueNotFound(let type, let context):
                        print("Value not found: \(type) in \(context)")
                    @unknown default:
                        print("Unknown decoding error")
                    }
                }
                
                // Imprime el JSON limpio para facilitar la depuración
                print("JSON limpio que causó el error:")
                print(cleanedJSON)
            }
        }
        return nil
    }
    
    /// Carga el archivo game_levels.json y procesa sus datos
    /// - Returns: Objeto GameConfig con los datos del juego
    static func loadGameLevelsFromFile() -> GameConfig? {
        guard let path = Bundle.main.path(forResource: "game_levels", ofType: "json") else {
            print("No se pudo encontrar el archivo game_levels.json")
            return nil
        }
        
        do {
            let jsonString = try String(contentsOfFile: path, encoding: .utf8)
            return processGameLevelsJSON(jsonString)
        } catch {
            print("Error al leer el archivo game_levels.json: \(error)")
            return nil
        }
    }
    
    /// Guarda la configuración del juego en un archivo JSON
    /// - Parameters:
    ///   - gameConfig: Configuración del juego a guardar
    ///   - fileName: Nombre del archivo sin extensión
    /// - Returns: Verdadero si la operación fue exitosa, falso en caso contrario
    static func saveGameConfigToFile(_ gameConfig: GameConfig, fileName: String = "game_levels") -> Bool {
        do {
            let encoder = JSONEncoder()
            encoder.outputFormatting = .prettyPrinted
            let jsonData = try encoder.encode(gameConfig)
            
            if let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {
                let fileURL = documentsDirectory.appendingPathComponent("\(fileName).json")
                try jsonData.write(to: fileURL)
                return true
            }
        } catch {
            print("Error al guardar la configuración: \(error)")
        }
        return false
    }
    
    // MARK: - Métodos privados para procesar el JSON
    
    private static func removeMultilineComments(from input: String) -> String {
        var result = ""
        var inMultilineComment = false
        var i = input.startIndex
        
        while i < input.endIndex {
            // Detectar inicio de comentario multilínea
            if i < input.index(before: input.endIndex) &&
               input[i] == "/" && input[input.index(after: i)] == "*" {
                inMultilineComment = true
                i = input.index(after: i)  // Saltar el "/"
            }
            // Detectar fin de comentario multilínea
            else if inMultilineComment && i < input.index(before: input.endIndex) &&
                    input[i] == "*" && input[input.index(after: i)] == "/" {
                inMultilineComment = false
                i = input.index(i, offsetBy: 2)  // Saltar "*/"
                continue
            }
            
            // Si no estamos en un comentario, añadir el caracter al resultado
            if !inMultilineComment {
                result.append(input[i])
            }
            
            i = input.index(after: i)
        }
        
        return result
    }
    
    private static func removeSingleLineComments(from input: String) -> String {
        var result = ""
        var inString = false
        var inSingleLineComment = false
        var i = input.startIndex
        
        while i < input.endIndex {
            let currentChar = input[i]
            
            // Manejar inicio/fin de cadenas de texto
            if currentChar == "\"" {
                // Verificar que la comilla no esté escapada
                if i > input.startIndex && input[input.index(before: i)] != "\\" {
                    inString = !inString
                }
            }
            
            // Detectar inicio de comentario de una línea (solo fuera de cadenas de texto)
            if !inString && i < input.index(before: input.endIndex) &&
               currentChar == "/" && input[input.index(after: i)] == "/" {
                inSingleLineComment = true
            }
            
            // Fin de línea termina un comentario de una línea
            if inSingleLineComment && (currentChar == "\n" || currentChar == "\r") {
                inSingleLineComment = false
                // Preservamos los saltos de línea para mantener la estructura del documento
                result.append(currentChar)
            }
            // Si no estamos en un comentario, añadir el caracter al resultado
            else if !inSingleLineComment {
                result.append(currentChar)
            }
            
            i = input.index(after: i)
        }
        
        return result
    }
    
    // MARK: - Métodos de acceso para usar los datos en la aplicación
    
    /// Obtiene los niveles disponibles en el juego
    /// - Parameter gameConfig: Configuración del juego
    /// - Returns: Array de niveles
    static func getLevels(from gameConfig: GameConfig) -> [GameLevel] {
        return gameConfig.levels
    }
    
    /// Obtiene los tipos de objetivos disponibles en el juego
    /// - Parameter gameConfig: Configuración del juego
    /// - Returns: Tipos de objetivos
    static func getObjectiveTypes(from gameConfig: GameConfig) -> ObjectiveTypes {
        return gameConfig.objectiveTypes
    }
    
    /// Obtiene los umbrales de precisión para las calificaciones
    /// - Parameter gameConfig: Configuración del juego
    /// - Returns: Umbrales de precisión
    static func getAccuracyThresholds(from gameConfig: GameConfig) -> AccuracyThresholds {
        return gameConfig.accuracyThresholds
    }
    
    /// Obtiene las medallas disponibles en el juego
    /// - Parameter gameConfig: Configuración del juego
    /// - Returns: Configuración de medallas
    static func getMedals(from gameConfig: GameConfig) -> Medals {
        return gameConfig.medals
    }
    
    /// Obtiene un nivel específico por su ID
    /// - Parameters:
    ///   - gameConfig: Configuración del juego
    ///   - id: ID del nivel
    /// - Returns: El nivel solicitado o nil si no existe
    static func getLevel(from gameConfig: GameConfig, withId id: Int) -> GameLevel? {
        if let level = gameConfig.levels.first(where: { $0.levelId == id }) {
            print("Nivel \(id) encontrado:")
            print("- Estilos permitidos: \(level.allowedStyles)")
            print("- Bloques configurados:")
            for (style, block) in level.blocks {
                print("  • \(style):")
                print("    - Notas: \(block.notes)")
                print("    - Estilo: \(block.style)")
                print("    - Peso: \(block.weight)")
            }
            return level
        }
        return nil
    }
    
    /// Obtiene los bloques disponibles en un nivel específico
    /// - Parameter level: Nivel del juego
    /// - Returns: Diccionario con los bloques disponibles
    static func getBlocks(from level: GameLevel) -> [String: Block] {
        return level.blocks
    }
    
    /// Corrige una versión JSON existente para adaptarla a los cambios de estructura
    /// - Parameter jsonString: Contenido del archivo JSON a corregir
    /// - Returns: JSON corregido o nil si hay error
    static func fixJSONStructure(_ jsonString: String) -> String? {
        // Primero limpiamos los comentarios
        var cleanedJSON = removeMultilineComments(from: jsonString)
        cleanedJSON = removeSingleLineComments(from: cleanedJSON)
        
        return cleanedJSON
    }
}
</file>

<file path="MusicBlocks/GameManager.swift">
//
//  GameManager.swift
//  MusicBlocks
//
//  Created by Jose R. García on 7/3/25.
//

import Foundation

class GameManager {
    // MARK: - Singleton
    static let shared = GameManager()
    
    // MARK: - Properties
    private(set) var gameConfig: GameConfig?
    private(set) var currentLevel: GameLevel?
    private var userProfile: UserProfile
    
    // MARK: - Game Statistics
    private(set) var totalGamesPlayed: Int = 0
    private(set) var highScores: [Int: Int] = [:] // [levelId: highScore]
    private(set) var lastPlayedLevel: Int = 0
    
    // MARK: - Constants
    private struct Constants {
        static let maxUnlockedLevel = 10
        static let tutorialLevelId = 0
        static let defaultLives = 3
    }
    
    // MARK: - Initialization
    private init() {
        userProfile = UserProfile.load()
        loadGameConfig()
        loadStatistics()
    }
    
    // MARK: - Configuration Loading
    private func loadGameConfig() {
        if let config = GameLevelProcessor.loadGameLevelsFromFile() {
            print("✅ Configuración del juego cargada")
            print("📊 Número de niveles: \(config.levels.count)")
            gameConfig = config
        } else {
            print("❌ Error al cargar la configuración del juego")
        }
    }
    
    private func loadStatistics() {
        totalGamesPlayed = userProfile.statistics.totalGamesPlayed
        lastPlayedLevel = userProfile.statistics.currentLevel
    }
    
    // MARK: - Level Management
    func loadLevel(_ levelId: Int) -> Bool {
        guard let config = gameConfig else {
            print("❌ Error: No se pudo cargar la configuración del juego")
            return false
        }
        
        // Verificar si el nivel está desbloqueado
        if !isLevelUnlocked(levelId) {
            print("🔒 Nivel \(levelId) bloqueado")
            return false
        }
        
        // Intentar cargar el nivel solicitado
        if let level = GameLevelProcessor.getLevel(from: config, withId: levelId) {
            currentLevel = level
            lastPlayedLevel = levelId
            userProfile.statistics.currentLevel = levelId
            userProfile.save()
            
            print("✅ Nivel \(levelId) cargado: \(level.name)")
            return true
        }
        
        // Si falla, intentar cargar el tutorial
        if let tutorialLevel = GameLevelProcessor.getLevel(from: config, withId: Constants.tutorialLevelId) {
            currentLevel = tutorialLevel
            print("ℹ️ Cargando tutorial por defecto")
            return true
        }
        
        print("❌ Error: No se pudo cargar ningún nivel")
        return false
    }
    
    func isLevelUnlocked(_ levelId: Int) -> Bool {
        // El tutorial siempre está desbloqueado
        if levelId == Constants.tutorialLevelId { return true }
        
        // Verificar progreso del usuario
        let previousLevelCompleted = highScores[levelId - 1] != nil
        return levelId <= Constants.maxUnlockedLevel && previousLevelCompleted
    }
    
    // MARK: - Game Progress
    func updateGameStatistics(levelId: Int, score: Int, completed: Bool) {
        // Actualizar estadísticas locales
        totalGamesPlayed += 1
        
        // Actualizar high score si es necesario
        if let currentHighScore = highScores[levelId] {
            if score > currentHighScore {
                highScores[levelId] = score
                print("🏆 Nuevo récord en nivel \(levelId): \(score)")
            }
        } else {
            highScores[levelId] = score
            print("🎮 Primera puntuación en nivel \(levelId): \(score)")
        }
        
        // Actualizar perfil de usuario
        userProfile.updateStatistics(
            score: score,
            accuracy: calculateAccuracyForLevel(score),
            levelCompleted: completed,
            isPerfect: isLevelPerfect(score),
            playTime: calculatePlayTime()
        )
        
        // Si completó el nivel, actualizar progreso
        if completed {
            if levelId >= userProfile.statistics.currentLevel {
                userProfile.statistics.currentLevel = levelId + 1
            }
        }
        
        userProfile.save()
    }
    
    // MARK: - Helper Methods
    private func calculateAccuracyForLevel(_ score: Int) -> Double {
        guard let level = currentLevel, level.requiredScore > 0 else { return 0.0 }
        return Double(score) / Double(level.requiredScore)
    }

    private func isLevelPerfect(_ score: Int) -> Bool {
        guard let level = currentLevel else { return false }
        let perfectThreshold = level.requiredScore * 3 / 2 // 150% del score requerido
        return score >= perfectThreshold
    }
    
    private func calculatePlayTime() -> TimeInterval {
        // Implementar lógica para calcular el tiempo de juego de la sesión actual
        return 60.0 // Por ahora retornamos un valor fijo de 1 minuto
    }
    
    // MARK: - Level Information
    func getLevelInfo(_ levelId: Int) -> (name: String, highScore: Int)? {
        guard let level = gameConfig?.levels.first(where: { level in
            level.levelId == levelId
        }) else {
            return nil
        }
        
        return (level.name, highScores[levelId] ?? 0)
    }
    
    func getNextUnlockedLevel() -> Int? {
        // El nivel actual siempre está desbloqueado
        let currentLevel = userProfile.statistics.currentLevel
        if !hasCompletedLevel(currentLevel) {
            return currentLevel
        }
        return nil
    }
    
    func hasCompletedLevel(_ levelId: Int) -> Bool {
        guard let level = gameConfig?.levels.first(where: { level in
            level.levelId == levelId
        }) else {
            return false
        }
        
        let currentScore = highScores[levelId] ?? 0
        return currentScore >= level.requiredScore
    }
    
    // MARK: - Level Configuration Access
    var accuracyThresholds: AccuracyThresholds? {
        gameConfig?.accuracyThresholds
    }
    
    var availableLevels: [GameLevel] {
        gameConfig?.levels ?? []
    }
    
    var currentLevelBlocks: [String: Block]? {
        currentLevel?.blocks
    }
    
    var currentLevelSpeed: FallingSpeed? {
        currentLevel?.fallingSpeed
    }
    
    var currentLevelStyles: [String]? {
        currentLevel?.allowedStyles
    }
    
    // MARK: - Game State Validation
    func isValidStyle(_ style: String) -> Bool {
        currentLevel?.allowedStyles.contains(style) ?? false
    }
    
    func getBlockConfig(for style: String) -> Block? {
        currentLevel?.blocks[style]
    }
    
    // MARK: - User Progress
    func resetProgress() {
        userProfile = UserProfile()
        userProfile.save()
        loadStatistics()
    }
    
    func getProgressSummary() -> String {
        """
        🎮 Partidas jugadas: \(totalGamesPlayed)
        🏆 Niveles completados: \(highScores.count)
        📊 Último nivel jugado: \(lastPlayedLevel)
        """
    }
    
}
</file>

<file path="MusicBlocks/GameTypes.swift">
//
//  GameTypes.swift
//  MusicBlocks
//
//  Created by Jose R. García on 7/3/25.
//

import Foundation
import SpriteKit

// MARK: - Block Types
struct BlockInfo {
    let node: SKNode
    let note: String
    let style: String
    let config: Block
    let requiredHits: Int
    let requiredTime: TimeInterval
    var currentHits: Int = 0
    var holdStartTime: Date?
}

// MARK: - Game States
enum GameState {
    case countdown
    case playing
    case paused
    case gameOver(reason: GameOverReason)
}

enum GameOverReason: String {
    case noLives = "noLives"
    case blocksOverflow = "blocksOverflow"
    case victory = "victory"
    
    var message: String {
        switch self {
        case .noLives:
            return "¡Te has quedado sin vidas!"
        case .blocksOverflow:
            return "¡Los bloques han llegado demasiado abajo!"
        case .victory:
            return "¡Nivel completado!"
        }
    }
    
    var isVictory: Bool {
        if case .victory = self {
            return true
        }
        return false
    }
}

// En GameTypes.swift
enum NoteStateType: String {
    case waiting = "waiting"
    case correct = "correct"
    case wrong = "wrong"
    case success = "success"
}


enum NoteState: Equatable {
    case waiting
    case correct(deviation: Double)
    case wrong
    case success(multiplier: Int, message: String)
}
</file>

<file path="MusicBlocks/GameUIManager.swift">
//
//  GameUIManager.swift
//  MusicBlocks
//
//  Created by Jose R. García on 7/3/25.
//

import SpriteKit
import UIKit

class GameUIManager {
    // MARK: - Properties
    private weak var scene: SKScene?
    private weak var mainAreaNode: SKNode?
    private var backgroundPattern: BackgroundPatternNode!
    var leftTopBarNode: TopBar?
    var rightTopBarNode: TopBar?
    private var currentOverlay: GameOverlayNode?
    private var objectiveTracker: LevelObjectiveTracker?
    
    // Indicadores
    var stabilityIndicatorNode: StabilityIndicatorNode!
    var stabilityCounterNode: StabilityCounterNode!
    var tuningIndicatorNode: TuningIndicatorNode!
    var detectedNoteCounterNode: DetectedNoteCounterNode!
    
    // Dimensiones
    private var mainAreaHeight: CGFloat = 0
    private var mainAreaWidth: CGFloat = 0
    
    // MARK: - Layout Configuration
    private struct Layout {
        static let margins = UIEdgeInsets(
            top: 6,
            left: 6,
            bottom: UIScreen.main.bounds.height * 0.05,
            right: 6
        )
        static let cornerRadius: CGFloat = 15
        static let verticalSpacing: CGFloat = 5
        
        // Proporciones de las áreas principales
        static let topBarHeightRatio: CGFloat = 0.08
        static let mainAreaHeightRatio: CGFloat = 0.74
        static let sideBarWidthRatio: CGFloat = 0.07
        static let mainAreaWidthRatio: CGFloat = 0.75
        static let sideBarHeightRatio: CGFloat = 0.4
        
        // TopBars específicas
        static let topBarWidthRatio: CGFloat = 0.490  // Aumentado de 0.47 para que sean más anchas
        static let topBarSpacing: CGFloat = 4         // Reducido de 8 para que estén más juntas
        
        // Efectos visuales
        static let shadowRadius: CGFloat = 8.0
        static let shadowOpacity: Float = 0.8
        static let shadowOffset = CGPoint(x: 0, y: -2)
        static let containerAlpha: CGFloat = 0.95
    }
    
    // MARK: - Initialization
    init(scene: SKScene) {
        self.scene = scene
        setupUI()
    }
    
    // MARK: - Public Methods
    func setupUI() {
        setupBackground()
        setupLayout()
    }
    
    func updateUI(score: Int, lives: Int) {
        leftTopBarNode?.updateScore(score)
        leftTopBarNode?.updateLives(lives)
        
        // Crear un objeto ObjectiveProgress con los datos actuales
        if let tracker = objectiveTracker {
            tracker.updateProgress(score: score)
            
            // Obtener el progreso actual directamente
            let progress = tracker.getCurrentProgress()
            
            // Actualizar el panel de objetivos con estos datos
            rightTopBarNode?.updateObjectiveInfo(with: progress)
        }
    }
    
    
    // MARK: - Setup Methods
    private func setupBackground() {
        guard let scene = scene else { return }
        backgroundPattern = BackgroundPatternNode(size: scene.size)
        backgroundPattern.zPosition = -10
        scene.addChild(backgroundPattern)
    }
    
    private func setupLayout() {
        guard let scene = scene else { return }
        
        let safeWidth = scene.size.width - Layout.margins.left - Layout.margins.right
        let safeHeight = scene.size.height - Layout.margins.top - Layout.margins.bottom
        
        let topBarHeight = safeHeight * Layout.topBarHeightRatio
        let mainAreaHeight = safeHeight * Layout.mainAreaHeightRatio
        let mainAreaWidth = safeWidth * Layout.mainAreaWidthRatio
        let sideBarWidth = safeWidth * Layout.sideBarWidthRatio
        let sideBarHeight = safeHeight * Layout.sideBarHeightRatio
        
        setupTopBars(width: safeWidth, height: topBarHeight)
        setupMainArea(width: mainAreaWidth, height: mainAreaHeight, topBarHeight: topBarHeight)
        setupSideBars(width: sideBarWidth, height: sideBarHeight, topBarHeight: topBarHeight)
    }
    
    private func setupTopBars(width: CGFloat, height: CGFloat) {
        guard let scene = scene else { return }
        let safeAreaTop = (scene.view?.safeAreaInsets.top ?? 0)
        
        // Calcular dimensiones
        let topBarWidth = width * Layout.topBarWidthRatio
        let yPosition = scene.size.height - safeAreaTop - height / 2
        
        // Calcular posiciones X
        // Ajustamos las posiciones para que estén más cerca de los bordes
        let leftXPosition = Layout.margins.left + topBarWidth/2
        let rightXPosition = scene.size.width - Layout.margins.right - topBarWidth/2
        
        // Crear TopBars
        leftTopBarNode = TopBar.create(
            width: topBarWidth,
            height: height,
            position: CGPoint(x: leftXPosition, y: yPosition),
            type: .main
        )
        
        rightTopBarNode = TopBar.create(
            width: topBarWidth,
            height: height,
            position: CGPoint(x: rightXPosition, y: yPosition),
            type: .objectives
        )
        
        if let leftBar = leftTopBarNode, let rightBar = rightTopBarNode {
            leftBar.zPosition = 100
            rightBar.zPosition = 100
            
            // Configurar las barras
            if let currentLevel = GameManager.shared.currentLevel {
                objectiveTracker = LevelObjectiveTracker(level: currentLevel)
                
                if let tracker = objectiveTracker {
                    leftBar.configure(withLevel: currentLevel, objectiveTracker: tracker)
                    rightBar.configure(withLevel: currentLevel, objectiveTracker: tracker)
                    leftBar.updateLives(currentLevel.lives.initial)
                    leftBar.updateScore(0)
                }
            }
            
            // Añadir a la escena
            scene.addChild(leftBar)
            scene.addChild(rightBar)
            
            // Debug de posiciones
            //            print("Left TopBar position: \(leftXPosition)")
            //            print("Right TopBar position: \(rightXPosition)")
            //            print("TopBar width: \(topBarWidth)")
            //            print("Scene width: \(scene.size.width)")
        }
    }
    
    private func setupMainArea(width: CGFloat, height: CGFloat, topBarHeight: CGFloat) {
        guard let scene = scene else { return }
        
        mainAreaWidth = width
        mainAreaHeight = height
        
        // Crear el contenedor principal sin fondo ni bordes
        let containerNode = SKNode()
        containerNode.position = CGPoint(
            x: scene.size.width/2,
            y: scene.size.height/2 - Layout.verticalSpacing
        )
        containerNode.zPosition = 1
        
        // Añadir línea límite con efecto de "danger zone"
        addDangerZone(to: containerNode, width: width, height: height)
        
        // Contenido principal (bloques)
        let mainContent = SKNode()
        mainContent.zPosition = 2
        containerNode.addChild(mainContent)
        mainAreaNode = mainContent
        scene.addChild(containerNode)
        
        //  print("MainArea configurada - Tamaño: \(width)x\(height)")
    }
    
    private func addDangerZone(to container: SKNode, width: CGFloat, height: CGFloat) {
        guard let scene = scene else { return }
        
        let dangerZone = SKNode()
        dangerZone.zPosition = 1
        
        // Calcular la posición del límite (en la parte inferior)
        let bottomLimit = -(height/2)
        
        // Crear el área de advertencia usando el ancho total de la pantalla y extendiendo hasta el fondo
        let warningArea = SKShapeNode(rect: CGRect(
            x: -scene.size.width/2,
            y: bottomLimit - scene.size.height, // Extender hacia abajo
            width: scene.size.width,
            height: scene.size.height // Usar toda la altura restante de la pantalla
        ))
        warningArea.fillColor = UIColor.red
        warningArea.strokeColor = UIColor.clear
        warningArea.alpha = 0.15
        
        // La línea límite permanece en la misma posición
        let limitLine = SKShapeNode(rect: CGRect(
            x: -scene.size.width/2,
            y: bottomLimit,
            width: scene.size.width,
            height: 2
        ))
        limitLine.fillColor = UIColor.red
        limitLine.strokeColor = UIColor.clear
        limitLine.alpha = 0.8
        
        // Animación de parpadeo solo para la línea
        let fadeSequence = SKAction.sequence([
            SKAction.fadeAlpha(to: 0.3, duration: 0.5),
            SKAction.fadeAlpha(to: 0.8, duration: 0.5)
        ])
        limitLine.run(SKAction.repeatForever(fadeSequence))
        
        dangerZone.addChild(warningArea)
        dangerZone.addChild(limitLine)
        
        container.addChild(dangerZone)
    }
    
    private func createDangerMarker(size: CGSize) -> SKShapeNode {
        let path = CGMutablePath()
        path.move(to: CGPoint(x: 0, y: 0))
        path.addLine(to: CGPoint(x: size.width, y: 0))
        path.addLine(to: CGPoint(x: size.width, y: -size.height))
        path.addLine(to: CGPoint(x: 0, y: -size.height))
        path.closeSubpath()
        
        let marker = SKShapeNode(path: path)
        marker.fillColor = UIColor.red
        marker.strokeColor = UIColor.clear
        marker.alpha = 0.8
        
        // Añadir efecto de parpadeo
        let fadeSequence = SKAction.sequence([
            SKAction.fadeAlpha(to: 0.3, duration: 0.5),
            SKAction.fadeAlpha(to: 0.8, duration: 0.5)
        ])
        marker.run(SKAction.repeatForever(fadeSequence))
        
        return marker
    }
    
    private func setupSideBars(width: CGFloat, height: CGFloat, topBarHeight: CGFloat) {
        setupLeftSideBar(width: width, height: height)
        setupRightSideBar(width: width, height: height)
    }
    
    private func setupLeftSideBar(width: CGFloat, height: CGFloat) {
        guard let scene = scene else { return }
        let position = CGPoint(
            x: Layout.margins.left + width/2 + 10,
            y: scene.size.height/2 - (Layout.verticalSpacing/2)
        )
        
        // Crear el contenedor y aplicar el estilo directamente
        let leftBar = SKNode()
        leftBar.position = position
        leftBar.zPosition = 1
        leftBar.applyContainerStyle(size: CGSize(width: width, height: height))
        scene.addChild(leftBar)
        
        setupStabilityIndicators(in: leftBar, at: position, width: width, height: height)
    }
    
    private func setupRightSideBar(width: CGFloat, height: CGFloat) {
        guard let scene = scene else { return }
        let position = CGPoint(
            x: scene.size.width - Layout.margins.right - width/2 - 10,
            y: scene.size.height/2 - (Layout.verticalSpacing/2)
        )
        
        // Crear el contenedor y aplicar el estilo directamente
        let rightBar = SKNode()
        rightBar.position = position
        rightBar.zPosition = 1
        rightBar.applyContainerStyle(size: CGSize(width: width, height: height))
        scene.addChild(rightBar)
        
        setupTuningIndicators(in: rightBar, at: position, width: width, height: height)
    }
    
    // MARK: - Indicator Setup
    private func setupStabilityIndicators(in container: SKNode, at position: CGPoint, width: CGFloat, height: CGFloat) {
        guard let scene = scene else { return }
        stabilityIndicatorNode = StabilityIndicatorNode(size: CGSize(width: width * 0.6, height: height * 0.9))
        stabilityIndicatorNode.position = .zero
        stabilityIndicatorNode.zPosition = 10
        container.addChild(stabilityIndicatorNode)
        
        let counterYPosition = position.y - height/2 - 30
        stabilityCounterNode = StabilityCounterNode(size: CGSize(width: width * 2.0, height: 30))
        stabilityCounterNode.position = CGPoint(x: position.x, y: counterYPosition)
        stabilityCounterNode.zPosition = 10
        scene.addChild(stabilityCounterNode)
    }
    
    private func setupTuningIndicators(in container: SKNode, at position: CGPoint, width: CGFloat, height: CGFloat) {
        guard let scene = scene else { return }
        tuningIndicatorNode = TuningIndicatorNode(size: CGSize(width: width * 0.6, height: height * 0.9))
        tuningIndicatorNode.position = .zero
        tuningIndicatorNode.zPosition = 10
        container.addChild(tuningIndicatorNode)
        
        let counterYPosition = position.y - height/2 - 30
        detectedNoteCounterNode = DetectedNoteCounterNode(size: CGSize(width: width * 2.0, height: 30))
        detectedNoteCounterNode.position = CGPoint(x: position.x, y: counterYPosition)
        detectedNoteCounterNode.zPosition = 10
        scene.addChild(detectedNoteCounterNode)
    }
    
    
    // MARK: - Overlay Methods
    func showLevelStartOverlay(for level: GameLevel, completion: @escaping () -> Void) {
        guard let scene = scene else { return }
        currentOverlay?.removeFromParent()
        
        // Actualizar las vidas en la TopBar antes de mostrar el overlay
        updateUI(score: 0, lives: level.lives.initial)
        
        let overlaySize = CGSize(width: scene.size.width * 0.7, height: scene.size.height * 0.45)
        let overlay = LevelStartOverlayNode(
            size: overlaySize,
            levelId: level.levelId,
            levelName: level.name,
            startAction: completion
        )
        
        scene.addChild(overlay)
        currentOverlay = overlay
        
        overlay.show(in: scene, overlayPosition: .center)
    }
    
    func showSuccessOverlay(multiplier: Int, message: String) {
        guard let scene = scene else { return }
        currentOverlay?.removeFromParent()
        
        let overlaySize = CGSize(width: 350, height: 60)
        let overlay = SuccessOverlayNode(
            size: overlaySize,
            multiplier: multiplier,
            message: message
        )
        scene.addChild(overlay)
        currentOverlay = overlay
        
        overlay.show(in: scene, overlayPosition: .bottom)
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak overlay] in
            overlay?.hide()
        }
    }
    
    func showFailureOverlay() {
        guard let scene = scene else { return }
        currentOverlay?.removeFromParent()
        
        let overlaySize = CGSize(width: 350, height: 60)
        let overlay = FailureOverlayNode(size: overlaySize)
        scene.addChild(overlay)
        currentOverlay = overlay
        
        overlay.show(in: scene, overlayPosition: .bottom)
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak overlay] in
            overlay?.hide()
        }
    }
    
    func showGameOverOverlay(score: Int, message: String, isVictory: Bool, onRestart: @escaping () -> Void) {
        guard let scene = scene else { return }
        currentOverlay?.removeFromParent()
        
        let overlaySize = CGSize(width: 400, height: 300)
        let overlay = GameOverOverlayNode(
            size: overlaySize,
            score: score,
            message: message,
            isVictory: isVictory,
            restartAction: onRestart
        )
        
        scene.addChild(overlay)
        currentOverlay = overlay
        
        overlay.show(in: scene, overlayPosition: .center)
    }
    
    // MARK: - Public Accessors
    func getMainAreaNode() -> SKNode? {
        return mainAreaNode
    }
    
    func getMainAreaDimensions() -> (width: CGFloat, height: CGFloat) {
        return (mainAreaWidth, mainAreaHeight)
    }
    
    // Método adicional para actualizar el progreso del objetivo
    func updateObjectiveProgress(
        score: Int? = nil,
        noteHit: Bool? = nil,
        accuracy: Double? = nil,
        blockDestroyed: String? = nil,
        deltaTime: TimeInterval? = nil
    ) {
        objectiveTracker?.updateProgress(
            score: score,
            noteHit: noteHit,
            accuracy: accuracy,
            blockDestroyed: blockDestroyed,
            deltaTime: deltaTime
        )
    }
    
    public func configureTopBars(withLevel level: GameLevel, objectiveTracker: LevelObjectiveTracker) {
        leftTopBarNode?.configure(withLevel: level, objectiveTracker: objectiveTracker)
        rightTopBarNode?.configure(withLevel: level, objectiveTracker: objectiveTracker)
    }
}
</file>

<file path="MusicBlocks/LevelObjectiveTracker.swift">
//
//  LevelObjectiveTracker.swift
//  MusicBlocks
//
//  Created by Jose R. García on 8/3/25.
//

import Foundation

class LevelObjectiveTracker {
    private let primaryObjective: Objective
    private var currentProgress: ObjectiveProgress
    
    
    init(level: GameLevel) {
        self.primaryObjective = level.objectives.primary
        self.currentProgress = ObjectiveProgress()
        
        // Inicializar contadores para cada estilo permitido en el nivel
        for style in level.allowedStyles {
            currentProgress.blocksByType[style] = 0
        }
    }

        
    func getPrimaryObjective() -> Objective {
        return primaryObjective
    }
    
    // MARK: - Progress Updates
    
    func updateProgress(score: Int? = nil,
                       noteHit: Bool? = nil,
                       accuracy: Double? = nil,
                       blockDestroyed: String? = nil,
                       deltaTime: TimeInterval? = nil) {
        // Actualizar score - Para objetivos tipo "score"
        if let score = score {
            currentProgress.score = score
        }
        
        // Actualizar notas acertadas - Para objetivos tipo "total_notes"
        if let noteHit = noteHit, noteHit {
            currentProgress.notesHit += 1
        }
        
        // Actualizar precisión - Para objetivos tipo "note_accuracy"
        if let accuracy = accuracy {
            currentProgress.accuracySum += accuracy
            currentProgress.accuracyCount += 1
        }
        
        // Actualizar bloques destruidos - Para objetivos tipo "block_destruction" y "total_blocks"
        if let blockType = blockDestroyed {
            currentProgress.blocksByType[blockType, default: 0] += 1
            currentProgress.totalBlocksDestroyed += 1
        }
        
        // Actualizar tiempo
        if let deltaTime = deltaTime {
            currentProgress.timeElapsed += deltaTime
        }
        
        // Al final, después de todas las actualizaciones, notificar el cambio
            NotificationCenter.default.post(
                name: NSNotification.Name("GameDataUpdated"),
                object: nil,
                userInfo: [:]  // No necesitamos pasar datos, solo forzar la actualización
            )
    }
    
    // MARK: - Objective Checking
    
    func checkObjectives() -> Bool {
            return checkObjective(primaryObjective)
        }
        
        private func checkObjective(_ objective: Objective) -> Bool {
            switch objective.type {
            case "score":
                return currentProgress.score >= (objective.target ?? 0)
                
            case "total_notes":
                return currentProgress.notesHit >= (objective.target ?? 0)
                
            case "note_accuracy":
                return currentProgress.notesHit >= (objective.target ?? 0) &&
                       currentProgress.averageAccuracy >= (objective.minimumAccuracy ?? 0)
                
            case "block_destruction":
                guard let details = objective.details else { return false }
                // All blocks must reach their target
                return details.allSatisfy { blockType, required in
                    currentProgress.blocksByType[blockType, default: 0] >= required
                }
                
            case "total_blocks":
                return currentProgress.totalBlocksDestroyed >= (objective.target ?? 0)
                
            default:
                return false
            }
        }
    
    // MARK: - Progress Information
    
    func getProgress() -> Double {
            return calculateProgress(for: primaryObjective)
        }
        
        func getCurrentProgress() -> ObjectiveProgress {
            return currentProgress
        }
        
        private func calculateProgress(for objective: Objective) -> Double {
            switch objective.type {
            case "score":
                let target = Double(objective.target ?? 1)
                return min(Double(currentProgress.score) / target, 1.0)
                
            case "total_notes":
                let target = Double(objective.target ?? 1)
                return min(Double(currentProgress.notesHit) / target, 1.0)
                
            case "note_accuracy":
                let noteProgress = Double(currentProgress.notesHit) / Double(objective.target ?? 1)
                let accuracyProgress = currentProgress.averageAccuracy / (objective.minimumAccuracy ?? 1.0)
                return min(min(noteProgress, accuracyProgress), 1.0)
                
            case "block_destruction":
                guard let details = objective.details else { return 0 }
                let progressByType = details.map { blockType, required in
                    Double(currentProgress.blocksByType[blockType, default: 0]) / Double(required)
                }
                // Always use min since we now require all blocks to be destroyed
                return min(progressByType.min() ?? 0, 1.0)
                
            case "total_blocks":
                let target = Double(objective.target ?? 1)
                return min(Double(currentProgress.totalBlocksDestroyed) / target, 1.0)
                
            default:
                return 0
            }
        }
    }
</file>

<file path="MusicBlocks/MusicBlocksScene.swift">
//
//  MusicBlocksScene.swift
//  MusicBlocks
//
//  Created by Jose R. García on 14/3/25.
//

import SpriteKit
import UIKit
import SwiftUI

class MusicBlocksScene: SKScene {
    @Environment(\.screenSize) var screenSize
    
    // MARK: - Managers
    private let audioController = AudioController.sharedInstance
    private let gameManager = GameManager.shared
    private var gameEngine: GameEngine!
    private var blocksManager: BlocksManager!
    private var uiManager: GameUIManager!
    private var objectiveTracker: LevelObjectiveTracker?
    
    // MARK: - Game State
    private var lastUpdateTime: TimeInterval = 0
    private var lastTimeUpdate: TimeInterval = 0
    private let timeUpdateInterval: TimeInterval = 1.0 // Actualizar cada segundo
    
    // MARK: - Lifecycle Methods
    override func didMove(to view: SKView) {
        super.didMove(to: view)
        print("🎬 Scene did move to view")
        
        setupManagers()
        setupGame()
        
        // Añadir observador para actualizaciones de todos los datos del juego
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleGameDataUpdate(_:)),
            name: NSNotification.Name("GameDataUpdated"),
            object: nil
        )
    }
    
    override func willMove(from view: SKView) {
        super.willMove(from: view)
        print("⏹️ Deteniendo juego")
        audioController.stop()
        blocksManager.stopBlockGeneration()
        
        // Eliminar observador al salir de la escena
        NotificationCenter.default.removeObserver(self)
    }
    
    // MARK: - Score Update Handler
    @objc func handleGameDataUpdate(_ notification: Notification) {
        let userData = notification.userInfo ?? [:]
        let score = userData["score"] as? Int ?? gameEngine.score
        let lives = userData["lives"] as? Int ?? gameEngine.lives
        
        // Actualizar la UI principal
        uiManager.updateUI(score: score, lives: lives)
        
        // Manejar overlays según información en la notificación
        if userData["noteState"] as? String == "success" {
            let multiplier = userData["multiplier"] as? Int ?? 1
            let message = userData["message"] as? String ?? "¡Bien!"
            uiManager.showSuccessOverlay(multiplier: multiplier, message: message)
        } else if userData["noteState"] as? String == "wrong" {
            uiManager.showFailureOverlay()
        }
        
        // Manejar game over
        if let gameOver = userData["gameOver"] as? Bool, gameOver {
            let isVictory = userData["isVictory"] as? Bool ?? false
            let reasonMessage = userData["reasonMessage"] as? String ?? (isVictory ? "¡Victoria!" : "Fin del juego")
            
            uiManager.showGameOverOverlay(
                score: score,
                message: reasonMessage,
                isVictory: isVictory
            ) { [weak self] in
                self?.setupGame()
            }
        }
    }
    
    // MARK: - Setup Methods
        private func setupManagers() {
            // Primero cargar el nivel inicial
            let userProfile = UserProfile.load()
            _ = gameManager.loadLevel(userProfile.statistics.currentLevel)
            
            // Crear tracker para el nivel actual
            if let currentLevel = gameManager.currentLevel {
                objectiveTracker = LevelObjectiveTracker(level: currentLevel)
            }
            
            // Inicializar UI Manager
            uiManager = GameUIManager(scene: self)
            
            // Obtener dimensiones del área principal
            let (mainAreaWidth, mainAreaHeight) = uiManager.getMainAreaDimensions()
            
            // Inicializar BlocksManager
            blocksManager = BlocksManager(
                blockSize: CGSize(
                    width: mainAreaWidth * 0.9,
                    height: mainAreaHeight * 0.15
                ),
                blockSpacing: mainAreaHeight * 0.02,
                mainAreaNode: uiManager.getMainAreaNode(),
                mainAreaHeight: mainAreaHeight
            )
            
            // Inicializar GameEngine
            gameEngine = GameEngine(blockManager: blocksManager)
            
            // Asignar el tracker de objetivos al motor de juego
            gameEngine.objectiveTracker = objectiveTracker
            
            // Configurar el delegado de audio
            guard let engine = gameEngine else {
                fatalError("GameEngine no se ha inicializado correctamente")
            }
            audioController.delegate = engine
            
            // IMPORTANTE: Actualizar UI con las vidas iniciales después de que todo esté configurado
            if let currentLevel = gameManager.currentLevel {
                uiManager.updateUI(score: 0, lives: currentLevel.lives.initial)
            }
        }
    
    private func setupGame() {
        // Cargar nivel desde el perfil del usuario
        let userProfile = UserProfile.load()
        print("Intentando cargar nivel \(userProfile.statistics.currentLevel)")
        
        if gameManager.loadLevel(userProfile.statistics.currentLevel) {
            if let currentLevel = gameManager.currentLevel {
                startLevel(currentLevel)
            }
        } else {
            print("Error al cargar nivel, intentando cargar tutorial")
            if gameManager.loadLevel(0) {
                if let tutorialLevel = gameManager.currentLevel {
                    startLevel(tutorialLevel)
                }
            }
        }
    }
    
    private func startLevel(_ level: GameLevel) {
        print("Iniciando nivel \(level.levelId): \(level.name)")
        
        // Detener audio y limpiar bloques
        audioController.stop()
        blocksManager.clearBlocks()
        
        // Configurar UI antes del overlay
        if let tracker = objectiveTracker {
            uiManager.configureTopBars(withLevel: level, objectiveTracker: tracker)
        }
        uiManager.updateUI(score: 0, lives: level.lives.initial)
        
        // Mostrar overlay de inicio de nivel
        uiManager.showLevelStartOverlay(for: level) { [weak self] in
            self?.startGameplay()
        }
    }
    
    private func startGameplay() {
        print("Iniciando gameplay")
        
        // Inicializar el motor del juego (esto ya configura las métricas y genera bloques)
        gameEngine.startNewGame()
        
        // Esperar un pequeño retraso para que el fade out de la música de fondo finalice antes de iniciar el audio.
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
            self.audioController.start()
            print("✅ Motor de audio iniciado")
            self.blocksManager.startBlockGeneration()
            print("✅ Gameplay iniciado")
        }
    }
    
    // MARK: - Update Methods
    override func update(_ currentTime: TimeInterval) {
        // Mantener la actualización original
        lastUpdateTime = currentTime
        
        // Si el juego está en curso, comprobar la posición de los bloques
        if case .playing = gameEngine.gameState {
            // Comprobar posición de bloques primero
            gameEngine.checkBlocksPosition()
            
            // Actualizar el tiempo si ha pasado el intervalo
            if currentTime - lastTimeUpdate >= timeUpdateInterval {
                lastTimeUpdate = currentTime
                updateTimeDisplay()
            }
            
            // Luego actualizar el estado del juego
            updateGameState()
        }
    }

    // Añadir este método para actualizar la información del tiempo
    private func updateTimeDisplay() {
        if let tracker = objectiveTracker {
            // Incrementar el tiempo transcurrido
            tracker.updateProgress(deltaTime: timeUpdateInterval)
            
            // Esto ya debería desencadenar una notificación que actualizará la UI
            // Pero por si acaso, podemos forzar una actualización
            let progress = tracker.getCurrentProgress()
            uiManager.rightTopBarNode?.updateObjectiveInfo(with: progress)
        }
    }
    
    private func updateGameState() {
        // Actualizar indicadores de estabilidad
        uiManager.stabilityIndicatorNode.duration = audioController.stabilityDuration
        uiManager.stabilityCounterNode.duration = audioController.stabilityDuration
        
        // Actualizar UI según estado del juego
        updateGameUI()
    }
    
    private func updateGameUI() {
        uiManager.updateUI(score: gameEngine.score, lives: gameEngine.lives)
        
        switch gameEngine.gameState {
        case .playing:
            handleGameplayState()
        case .gameOver(let reason):
            handleGameOver(reason: reason)
        case .paused:
            break // Manejar pausa si es necesario
        case .countdown:
            break // La cuenta atrás la maneja el overlay
        }
    }
    
    // MARK: - Game State Handling
    private func handleGameplayState() {
        switch gameEngine.noteState {
        case .success(let multiplier, let message):
            uiManager.showSuccessOverlay(multiplier: multiplier, message: message)
        case .wrong:
            uiManager.showFailureOverlay()
        default:
            break
        }
    }
    
    private func handleGameOver(reason: GameOverReason) {
        audioController.stop()
        blocksManager.stopBlockGeneration()
        
        // Actualizar estadísticas del juego
        if let currentLevel = gameManager.currentLevel {
            // Actualizar con el estado de victoria
            gameManager.updateGameStatistics(
                levelId: currentLevel.levelId,
                score: gameEngine.score,
                completed: reason == .victory
            )
        }
        
        // Determinar el mensaje según la razón
        let message = switch reason {
        case .blocksOverflow:
            "¡Los bloques han alcanzado la zona de peligro!"
        case .noLives:
            "¡Te has quedado sin vidas!"
        case .victory:
            "¡Nivel completado!"
        }
        
        print("🔴 Game Over: \(message)")
        
        // Mostrar overlay con el mensaje específico
        uiManager.showGameOverOverlay(
            score: gameEngine.score,
            message: message,
            isVictory: reason == .victory
        ) { [weak self] in
            self?.setupGame()
        }
    }
    
    // MARK: - AudioControllerDelegate
    func audioController(_ controller: AudioController, didDetectNote note: String, frequency: Float, amplitude: Float, deviation: Double) {
        // Actualizar indicadores de nota
        uiManager.detectedNoteCounterNode?.currentNote = note
        uiManager.detectedNoteCounterNode?.isActive = true
        uiManager.tuningIndicatorNode.deviation = deviation
        uiManager.tuningIndicatorNode.isActive = true
        
        // Procesar nota detectada
        gameEngine.checkNote(
            currentNote: note,
            deviation: deviation,
            isActive: true
        )
        
        // Actualizar la información del objetivo en la UI
            if let progress = objectiveTracker?.getCurrentProgress() {
                uiManager.rightTopBarNode?.updateObjectiveInfo(with: progress)
            }
    }
    
    func audioControllerDidDetectSilence(_ controller: AudioController) {
        // Actualizar indicadores visuales
        uiManager.detectedNoteCounterNode?.isActive = false
        uiManager.tuningIndicatorNode.isActive = false
        
        // Procesar silencio
        gameEngine.checkNote(
            currentNote: "-",
            deviation: 0,
            isActive: false
        )
    }
    
}

// MARK: - Environment Values
private struct ScreenSizeKey: EnvironmentKey {
    static let defaultValue: CGSize = UIScreen.main.bounds.size
}

extension EnvironmentValues {
    var screenSize: CGSize {
        get { self[ScreenSizeKey.self] }
        set { self[ScreenSizeKey.self] = newValue }
    }
}

// MARK: - SwiftUI Representative
struct SpriteViewRepresentable: UIViewRepresentable {
    let size: CGSize
    
    func makeUIView(context: Context) -> SKView {
        let view = SKView(frame: .zero)
        view.preferredFramesPerSecond = 60
        view.ignoresSiblingOrder = true
        
        let scene = MusicBlocksScene()
        scene.scaleMode = .resizeFill
        scene.size = size
        view.presentScene(scene)
        
        return view
    }
    
    func updateUIView(_ uiView: SKView, context: Context) {
        if let scene = uiView.scene {
            scene.size = size
        }
    }
}

struct MusicBlocksSceneView: View {
    var body: some View {
        GeometryReader { geometry in
            SpriteView(scene: MusicBlocksScene(size: geometry.size))
                .ignoresSafeArea()
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .navigationBarHidden(true)
        }
    }
}

#if DEBUG
import SwiftUI

struct MusicBlocksScene_Previews: PreviewProvider {
    static var previews: some View {
        MusicBlocksSceneView()
            .previewDevice("iPhone 16")
    }
}
#endif
</file>

</files>
